###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    20/Oct/2014  18:58:39 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\8-22\0最新有用\修改中2013.8.12Texas             #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Compone #
#                          nts\osal\common\OSAL.c                             #
#    Command line       =  -f "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wEndev #
#                          .cfg" (-DCPU32MHZ -DFORCE_MAC_NEAR                 #
#                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS    #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfi #
#                          g.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800   #
#                          -DZDAPP_CONFIG_PAN_ID=0x1234                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=30            #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=10000       #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\8-22\0最新有用\修改中20 #
#                          13.8.12Texas Instruments                           #
#                          longmenshan\ZStack-1.4.3-1.2.1\Components\osal\com #
#                          mon\OSAL.c" -D CC2430EB -D NWK_AUTO_POLL -D        #
#                          REFLECTOR -D ZTOOL_P1 -D MT_TASK -D MT_ZDO -D      #
#                          xLCD_SUPPORTED=DEBUG -D POWER_SAVING -lC           #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\List\" -lA           #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\List\"               #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\Obj\" -e             #
#                          --require_prototypes -z9 --no_code_motion --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network formaton\CC2430DB\" -I    #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\SOURCE\" -I                   #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I     #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MT\"   #
#                          -I "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\IN #
#                          CLUDE\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas #
#                           Instruments longmenshan\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\network                          #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\TA #
#                          RGET\CC2430EB\" -I "C:\8-22\0最新有用\修改中2013.8 #
#                          .12Texas Instruments longmenshan\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\network                  #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\M #
#                          CU\CCSOC\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\I #
#                          NCLUDE\" -I "C:\8-22\0最新有用\修改中2013.8.12Texa #
#                          s Instruments longmenshan\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          AF\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas    #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          NWK\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SEC\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SYS\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          ZDO\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\F #
#                          8W\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas    #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\" #
#                           -I "C:\8-22\0最新有用\修改中2013.8.12Texas        #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SADDR\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SDATA\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\IN #
#                          CLUDE\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas #
#                           Instruments longmenshan\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\network                          #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\HI #
#                          GH_LEVEL\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\" -I "C:\8-22\0最新有用\修改中2013.8 #
#                          .12Texas Instruments longmenshan\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\network                  #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\SINGLE_CHIP\" -I "D:\XP的D\Program   #
#                          file\IAR\8051\INC\" -I "D:\XP的D\Program           #
#                          file\IAR\8051\INC\CLIB\"                           #
#    List file          =  C:\8-22\0最新有用\修改中2013.8.12Texas             #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\List\OSAL.lst        #
#    Object file        =  C:\8-22\0最新有用\修改中2013.8.12Texas             #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\Obj\OSAL.r51         #
#                                                                             #
#                                                                             #
###############################################################################

C:\8-22\0最新有用\修改中2013.8.12Texas Instruments longmenshan\ZStack-1.4.3-1.2.1\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6          
      7            Description:    This API allows the software components in the Z-stack to be written
      8                            independently of the specifics of the operating system, kernel or tasking
      9                            environment (including control loops or connect-to-interrupt systems).
     10          
     11          
     12            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com. 
     41          **************************************************************************************************/
     42          
     43          /*********************************************************************
     44           * INCLUDES
     45           */
     46          
     47          #include <stdlib.h>
     48          #include <string.h>
     49          
     50          #include "ZComDef.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Tasks.h"
     53          #include "OSAL_Custom.h"
     54          #include "OSAL_Memory.h"
     55          #include "OSAL_PwrMgr.h"
     56          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     57          
     58          #include "OnBoard.h"
     59          
     60          /* HAL */
     61          #include "hal_drivers.h"
     62          extern uint8 halWait(unsigned char wait);
     63          
     64          /*********************************************************************
     65           * MACROS
     66           */
     67          
     68          #define OSAL_MSG_LEN(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)->len
     69          
     70          #define OSAL_MSG_ID(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)->dest_id
     71          
     72          /*********************************************************************
     73           * CONSTANTS
     74           */
     75          
     76          /*********************************************************************
     77           * TYPEDEFS
     78           */
     79          
     80          /*********************************************************************
     81           * GLOBAL VARIABLES
     82           */
     83          
     84          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     85          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     86          
     87          #if defined( OSAL_TOTAL_MEM )
     88            UINT16 osal_msg_cnt;
     89          #endif
     90          
     91          /*********************************************************************
     92           * EXTERNAL VARIABLES
     93           */
     94          
     95          /*********************************************************************
     96           * EXTERNAL FUNCTIONS
     97           */
     98          
     99          /*********************************************************************
    100           * LOCAL VARIABLES
    101           */
    102          
    103          
    104          /*********************************************************************
    105           * LOCAL FUNCTION PROTOTYPES
    106           */
    107          
    108          /*********************************************************************
    109           * HELPER FUNCTIONS
    110           */
    111          /* very ugly stub so Keil can compile */
    112          #ifdef __KEIL__
    113          char *  itoa ( int value, char * buffer, int radix )
    114          {
    115            return(buffer);
    116          }
    117          #endif
    118          
    119          /*********************************************************************
    120           * @fn      osal_strlen
    121           *
    122           * @brief
    123           *
    124           *   Calculates the length of a string.  The string must be null
    125           *   terminated.
    126           *
    127           * @param   char *pString - pointer to text string
    128           *
    129           * @return  int - number of characters
    130           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    131          int osal_strlen( char *pString )
   \                     osal_strlen:
    132          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    133            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   02....       LJMP    ?Subroutine19 & 0xFFFF
    134          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    135          
    136          /*********************************************************************
    137           * @fn      osal_memcpy
    138           *
    139           * @brief
    140           *
    141           *   Generic memory copy.
    142           *
    143           *   Note: This function differs from the standard memcpy(), since
    144           *         it returns the pointer to the next destination byte. The
    145           *         standard memcpy() returns the original destination address.
    146           *
    147           * @param   dst - destination address
    148           * @param   src - source address
    149           * @param   len - number of bytes to copy
    150           *
    151           * @return  pointer to end of destination buffer
    152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    153          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    154          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   740B         MOV     A,#0xb
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 1,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
    155            byte *pDst;
    156            const byte GENERIC *pSrc;
    157          
    158            pSrc = src;
   \   000017   A9..         MOV     R1,?V0 + 0
   \   000019   AA..         MOV     R2,?V0 + 1
   \   00001B   FB           MOV     R3,A
    159            pDst = dst;
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   800D         SJMP    ??osal_memcpy_0
    160          
    161            while ( len-- )
    162              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   000022   12....       LCALL   ?C_GPTR_LOAD
   \   000025   F0           MOVX    @DPTR,A
   \   000026   E9           MOV     A,R1
   \   000027   2401         ADD     A,#0x1
   \   000029   09           INC     R1
   \   00002A   EA           MOV     A,R2
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FA           MOV     R2,A
   \   00002E   A3           INC     DPTR
   \                     ??osal_memcpy_0:
   \   00002F   EC           MOV     A,R4
   \   000030   FE           MOV     R6,A
   \   000031   ED           MOV     A,R5
   \   000032   FF           MOV     R7,A
   \   000033   74FF         MOV     A,#-0x1
   \   000035   2E           ADD     A,R6
   \   000036   1C           DEC     R4
   \   000037   74FF         MOV     A,#-0x1
   \   000039   3F           ADDC    A,R7
   \   00003A   FD           MOV     R5,A
   \   00003B   EE           MOV     A,R6
   \   00003C   7001         JNZ     ??osal_memcpy_2
   \   00003E   EF           MOV     A,R7
   \                     ??osal_memcpy_2:
   \   00003F   70E1         JNZ     ??osal_memcpy_1
    163          
    164            return ( pDst );
   \   000041   AA82         MOV     R2,DPL
   \   000043   AB83         MOV     R3,DPH
   \   000045                REQUIRE ?Subroutine20
   \   000045                ; // Fall through to label ?Subroutine20
    165          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    166          
    167          /*********************************************************************
    168           * @fn      osal_cpyExtAddr
    169           *
    170           * @brief
    171           *
    172           *   Copy extended addresses.  This function will copy 8 bytes.
    173           *
    174           * @param   dest  destination address pointer
    175           * @param   src   source address pointer
    176           *
    177           * @return  dest + Z_EXTADDR_LEN
    178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    179          void *osal_cpyExtAddr( void *dest, void *src )
   \                     osal_cpyExtAddr:
    180          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    181            return osal_memcpy( dest, src, Z_EXTADDR_LEN );
   \   000005                ; Setup parameters for call to function osal_memcpy
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   75..00       MOV     ?V0 + 2,#0x0
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000011   7C08         MOV     R4,#0x8
   \   000013   7D00         MOV     R5,#0x0
   \   000015   12....       LCALL   ??osal_memcpy?relay
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001D   80..         SJMP    ?Subroutine20
    182          }
    183          
    184          /*********************************************************************
    185           * @fn      osal_memset
    186           *
    187           * @brief
    188           *
    189           *   Set memory buffer to value.
    190           *
    191           * @param   dest - pointer to buffer
    192           * @param   value - what to set each byte of the message
    193           * @param   size - how big
    194           *
    195           * @return  value of next widget, 0 if no widget found
    196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    197          void *osal_memset( void *dest, byte value, int len )
   \                     osal_memset:
    198          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    199            return memset( dest, value, len );
   \   000005                ; Setup parameters for call to function memset
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000E   E9           MOV     A,R1
   \   00000F   FC           MOV     R4,A
   \   000010   7D00         MOV     R5,#0x0
   \   000012   12....       LCALL   ??memset?relay
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001A   02....       LJMP    ?Subroutine21 & 0xFFFF
    200          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    201          
    202          /*********************************************************************
    203           * @fn      osal_build_uint16
    204           *
    205           * @brief
    206           *
    207           *   Build a uint16 out of 2 bytes (0 then 1).
    208           *
    209           * @param   swapped - 0 then 1
    210           *
    211           * @return  uint16
    212           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    213          uint16 osal_build_uint16( byte *swapped )
   \                     osal_build_uint16:
    214          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    215            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FC           MOV     R4,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   EC           MOV     A,R4
   \   00000F   FA           MOV     R2,A
   \   000010   E9           MOV     A,R1
   \   000011   FB           MOV     R3,A
   \   000012   02....       LJMP    ?Subroutine23 & 0xFFFF
    216          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    217          
    218          /*********************************************************************
    219           * @fn      osal_build_uint32
    220           *
    221           * @brief
    222           *
    223           *   Build a uint32 out of sequential bytes.
    224           *
    225           * @param   swapped - sequential bytes
    226           * @param   len - number of bytes in the byte array
    227           *
    228           * @return  uint32
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          uint32 osal_build_uint32( byte *swapped, byte len )
   \                     osal_build_uint32:
    231          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    232            if ( len == 2 )
   \   000005   7402         MOV     A,#0x2
   \   000007   69           XRL     A,R1
   \   000008   701D         JNZ     ??osal_build_uint32_0
    233              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000011   78..         MOV     R0,#?V0 + 4
   \   000013   12....       LCALL   ?L_SHL
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   79..         MOV     R1,#?V0 + 4
   \   00001A   12....       LCALL   ?L_ADD
   \   00001D   AA..         MOV     R2,?V0 + 0
   \   00001F   AB..         MOV     R3,?V0 + 1
   \   000021   AC..         MOV     R4,?V0 + 2
   \   000023   AD..         MOV     R5,?V0 + 3
   \   000025   8059         SJMP    ??osal_build_uint32_1
    234            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   000027   7403         MOV     A,#0x3
   \   000029   69           XRL     A,R1
   \   00002A   7016         JNZ     ??osal_build_uint32_2
    235              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000033   12....       LCALL   ?L_SHL
   \   000036   78..         MOV     R0,#?V0 + 0
   \   000038   79..         MOV     R1,#?V0 + 4
   \   00003A   12....       LCALL   ?L_ADD
   \   00003D   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000040   80CF         SJMP    ??CrossCallReturnLabel_36
    236            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   000042   7404         MOV     A,#0x4
   \   000044   69           XRL     A,R1
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   702D         JNZ     ??osal_build_uint32_3
    237              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   00004B   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00004E   12....       LCALL   ?L_SHL
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   79..         MOV     R1,#?V0 + 4
   \   000055   12....       LCALL   ?L_ADD
   \   000058   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00005B   78..         MOV     R0,#?V0 + 4
   \   00005D   12....       LCALL   ?L_SHL
   \   000060   78..         MOV     R0,#?V0 + 0
   \   000062   79..         MOV     R1,#?V0 + 4
   \   000064   12....       LCALL   ?L_ADD
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F5..         MOV     ?V0 + 4,A
   \   000071   75..00       MOV     ?V0 + 6,#0x0
   \   000074   7418         MOV     A,#0x18
   \   000076   8099         SJMP    ??CrossCallReturnLabel_36
    238            else
    239              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_3:
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   7B00         MOV     R3,#0x0
   \   00007C   7C00         MOV     R4,#0x0
   \   00007E   7D00         MOV     R5,#0x0
   \                     ??osal_build_uint32_1:
   \   000080                REQUIRE ?Subroutine24
   \   000080                ; // Fall through to label ?Subroutine24
    240          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 4,A
   \   000009   75..00       MOV     ?V0 + 5,#0x0
   \   00000C   7410         MOV     A,#0x10
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   75..00       MOV     ?V0 + 2,#0x0
   \   000009   75..00       MOV     ?V0 + 3,#0x0
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F5..         MOV     ?V0 + 4,A
   \   000010   75..00       MOV     ?V0 + 5,#0x0
   \   000013   75..00       MOV     ?V0 + 6,#0x0
   \   000016   75..00       MOV     ?V0 + 7,#0x0
   \   000019   7408         MOV     A,#0x8
   \   00001B   22           RET
    241          
    242          #if !defined ( ZBIT ) && !defined ( ZBIT2 )
    243          /*********************************************************************
    244           * @fn      _ltoa
    245           *
    246           * @brief
    247           *
    248           *   convert a long unsigned int to a string.
    249           *
    250           * @param  l - long to convert
    251           * @param  buf - buffer to convert to
    252           * @param  radix - 10 dec, 16 hex
    253           *
    254           * @return  pointer to buffer
    255           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    256          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    257          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 36
   \   000005   74DC         MOV     A,#-0x24
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   EC           MOV     A,R4
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   ED           MOV     A,R5
   \   000019   F0           MOVX    @DPTR,A
    258          #if defined( __GNUC__ )
    259            return ( (char*)ltoa( l, buf, radix ) );
    260          #else
    261            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   00001A   7406         MOV     A,#0x6
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   7583..       MOV     DPH,#((`?<Constant "">` >> 8) & 0xff)
   \   000026   7582..       MOV     DPL,#(`?<Constant "">` & 0xff)
   \   000029   740A         MOV     A,#0xa
   \   00002B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00002E   7583..       MOV     DPH,#((`?<Constant "">_1` >> 8) & 0xff)
   \   000031   7582..       MOV     DPL,#(`?<Constant "">_1` & 0xff)
   \   000034   740A         MOV     A,#0xa
   \   000036   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000039   7583..       MOV     DPH,#((`?<Constant "">_2` >> 8) & 0xff)
   \   00003C   7582..       MOV     DPL,#(`?<Constant "">_2` & 0xff)
   \   00003F   740A         MOV     A,#0xa
   \   000041   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    262            unsigned short num1, num2, num3;
    263            unsigned char i;
    264          
    265            buf[0] = '\0';
   \   000044   7434         MOV     A,#0x34
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00004C   E4           CLR     A
   \   00004D   F0           MOVX    @DPTR,A
    266          
    267            if ( radix == 10 )
   \   00004E   740A         MOV     A,#0xa
   \   000050   69           XRL     A,R1
   \   000051   6003         JZ      $+5
   \   000053   02....       LJMP    ??_ltoa_0 & 0xFFFF
    268            {
    269              num1 = l % 10000;
   \   000056   7402         MOV     A,#0x2
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   78..         MOV     R0,#?V0 + 4
   \   00005D   12....       LCALL   ?L_MOV_X
   \   000060   90....       MOV     DPTR,#__Constant_2710
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_X
   \   000068   78..         MOV     R0,#?V0 + 4
   \   00006A   79..         MOV     R1,#?V0 + 0
   \   00006C   12....       LCALL   ?UL_DIV_MOD
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   E5..         MOV     A,?V0 + 0
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   E5..         MOV     A,?V0 + 1
   \   00007B   F0           MOVX    @DPTR,A
    270              num2 = (l / 10000) % 10000;
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   78..         MOV     R0,#?V0 + 4
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   90....       MOV     DPTR,#__Constant_2710
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?L_MOV_X
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   79..         MOV     R1,#?V0 + 0
   \   000092   12....       LCALL   ?UL_DIV_MOD
   \   000095   90....       MOV     DPTR,#__Constant_2710
   \   000098   78..         MOV     R0,#?V0 + 0
   \   00009A   12....       LCALL   ?L_MOV_X
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   79..         MOV     R1,#?V0 + 0
   \   0000A1   12....       LCALL   ?UL_DIV_MOD
   \   0000A4   AE..         MOV     R6,?V0 + 0
   \   0000A6   AF..         MOV     R7,?V0 + 1
    271              num3 = (unsigned short)(l / 100000000);
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   78..         MOV     R0,#?V0 + 4
   \   0000AF   12....       LCALL   ?L_MOV_X
   \   0000B2   90....       MOV     DPTR,#__Constant_5f5e100
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?L_MOV_X
   \   0000BA   78..         MOV     R0,#?V0 + 4
   \   0000BC   79..         MOV     R1,#?V0 + 0
   \   0000BE   12....       LCALL   ?UL_DIV_MOD
   \   0000C1   85....       MOV     ?V0 + 6,?V0 + 4
   \   0000C4   85....       MOV     ?V0 + 7,?V0 + 5
    272          
    273              if (num3) _itoa(num3, tmp3, 10);
   \   0000C7   E5..         MOV     A,?V0 + 6
   \   0000C9   7002         JNZ     ??_ltoa_1
   \   0000CB   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_1:
   \   0000CD   6012         JZ      ??_ltoa_2
   \   0000CF                ; Setup parameters for call to function _itoa
   \   0000CF   790A         MOV     R1,#0xa
   \   0000D1   741A         MOV     A,#0x1a
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   AC82         MOV     R4,DPL
   \   0000D8   AD83         MOV     R5,DPH
   \   0000DA   AA..         MOV     R2,?V0 + 6
   \   0000DC   AB..         MOV     R3,?V0 + 7
   \   0000DE   12....       LCALL   ??_itoa?relay
    274              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_2:
   \   0000E1   EE           MOV     A,R6
   \   0000E2   7001         JNZ     ??_ltoa_3
   \   0000E4   EF           MOV     A,R7
   \                     ??_ltoa_3:
   \   0000E5   6012         JZ      ??_ltoa_4
   \   0000E7                ; Setup parameters for call to function _itoa
   \   0000E7   790A         MOV     R1,#0xa
   \   0000E9   7410         MOV     A,#0x10
   \   0000EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EE   AC82         MOV     R4,DPL
   \   0000F0   AD83         MOV     R5,DPH
   \   0000F2   EE           MOV     A,R6
   \   0000F3   FA           MOV     R2,A
   \   0000F4   EF           MOV     A,R7
   \   0000F5   FB           MOV     R3,A
   \   0000F6   12....       LCALL   ??_itoa?relay
    275              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_4:
   \   0000F9   85..82       MOV     DPL,?XSP + 0
   \   0000FC   85..83       MOV     DPH,?XSP + 1
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   7002         JNZ     ??_ltoa_5
   \   000102   A3           INC     DPTR
   \   000103   E0           MOVX    A,@DPTR
   \                     ??_ltoa_5:
   \   000104   600A         JZ      ??CrossCallReturnLabel_18
   \   000106                ; Setup parameters for call to function _itoa
   \   000106   790A         MOV     R1,#0xa
   \   000108   7406         MOV     A,#0x6
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   12....       LCALL   ?Subroutine7 & 0xFFFF
    276          
    277              if (num3)
   \                     ??CrossCallReturnLabel_18:
   \   000110   E5..         MOV     A,?V0 + 6
   \   000112   7002         JNZ     ??_ltoa_6
   \   000114   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_6:
   \   000116   602C         JZ      ??_ltoa_7
    278              {
    279                strcpy((char*)buf, (char const*)tmp3);
   \   000118                ; Setup parameters for call to function strcpy
   \   000118   741A         MOV     A,#0x1a
   \   00011A   12....       LCALL   ?XSTACK_DISP0_8
   \   00011D   AC82         MOV     R4,DPL
   \   00011F   AD83         MOV     R5,DPH
   \   000121   7434         MOV     A,#0x34
   \   000123   12....       LCALL   ?XSTACK_DISP0_8
   \   000126   12....       LCALL   ?Subroutine5 & 0xFFFF
    280                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \                     ??CrossCallReturnLabel_14:
   \   000129   800C         SJMP    ??CrossCallReturnLabel_5
    281                  strcat((char*)buf, "0");
   \                     ??_ltoa_8:
   \   00012B                ; Setup parameters for call to function strcat
   \   00012B   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   00012D   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   00012F   7434         MOV     A,#0x34
   \   000131   12....       LCALL   ?XSTACK_DISP0_8
   \   000134   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000137   85....       MOV     ?V0 + 2,?V0 + 0
   \   00013A                ; Setup parameters for call to function strlen
   \   00013A   7410         MOV     A,#0x10
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000142   40E7         JC      ??_ltoa_8
    282              }
    283              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_7:
   \   000144                ; Setup parameters for call to function strcat
   \   000144   7410         MOV     A,#0x10
   \   000146   12....       LCALL   ?XSTACK_DISP0_8
   \   000149   AC82         MOV     R4,DPL
   \   00014B   AD83         MOV     R5,DPH
   \   00014D   7434         MOV     A,#0x34
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   12....       LCALL   ?Subroutine6 & 0xFFFF
    284              if (num3 || num2)
   \                     ??CrossCallReturnLabel_16:
   \   000155   7002         JNZ     ??_ltoa_9
   \   000157   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_9:
   \   000159   7006         JNZ     ??_ltoa_10
   \   00015B   EE           MOV     A,R6
   \   00015C   7001         JNZ     ??_ltoa_11
   \   00015E   EF           MOV     A,R7
   \                     ??_ltoa_11:
   \   00015F   601E         JZ      ??_ltoa_12
    285              {
    286                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_10:
   \   000161   75..00       MOV     ?V0 + 0,#0x0
   \   000164   800C         SJMP    ??CrossCallReturnLabel_6
    287                  strcat((char*)buf, "0");
   \                     ??_ltoa_13:
   \   000166                ; Setup parameters for call to function strcat
   \   000166   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   000168   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   00016A   7434         MOV     A,#0x34
   \   00016C   12....       LCALL   ?XSTACK_DISP0_8
   \   00016F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000172   85....       MOV     ?V0 + 2,?V0 + 0
   \   000175                ; Setup parameters for call to function strlen
   \   000175   7406         MOV     A,#0x6
   \   000177   12....       LCALL   ?XSTACK_DISP0_8
   \   00017A   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00017D   40E7         JC      ??_ltoa_13
    288              }
    289              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_12:
   \   00017F                ; Setup parameters for call to function strcat
   \   00017F   7406         MOV     A,#0x6
   \   000181   12....       LCALL   ?XSTACK_DISP0_8
   \   000184   AC82         MOV     R4,DPL
   \   000186   AD83         MOV     R5,DPH
   \   000188   7434         MOV     A,#0x34
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   12....       LCALL   ?Subroutine6 & 0xFFFF
    290              if (!num3 && !num2 && !num1)
   \                     ??CrossCallReturnLabel_17:
   \   000190   7002         JNZ     ??_ltoa_14
   \   000192   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_14:
   \   000194   7022         JNZ     ??_ltoa_15
   \                     ??_ltoa_16:
   \   000196   EE           MOV     A,R6
   \   000197   7001         JNZ     ??_ltoa_17
   \   000199   EF           MOV     A,R7
   \                     ??_ltoa_17:
   \   00019A   701C         JNZ     ??_ltoa_15
   \   00019C   85..82       MOV     DPL,?XSP + 0
   \   00019F   85..83       MOV     DPH,?XSP + 1
   \   0001A2   E0           MOVX    A,@DPTR
   \   0001A3   7002         JNZ     ??_ltoa_18
   \   0001A5   A3           INC     DPTR
   \   0001A6   E0           MOVX    A,@DPTR
   \                     ??_ltoa_18:
   \   0001A7   700F         JNZ     ??_ltoa_15
    291                strcpy((char*)buf, "0");
   \   0001A9                ; Setup parameters for call to function strcpy
   \   0001A9   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   0001AB   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   0001AD   7434         MOV     A,#0x34
   \   0001AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B2   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001B5   12....       LCALL   ??strcpy?relay
    292            }
    293            else if ( radix == 16 )
    294            {
    295              num1 = l & 0x0000FFFF;
    296              num2 = l >> 16;
    297          
    298              if (num2) _itoa(num2, tmp2, 16);
    299              if (num1) _itoa(num1, tmp1, 16);
    300          
    301              if (num2)
    302              {
    303                strcpy((char*)buf,(char const*)tmp2);
    304                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    305                  strcat((char*)buf, "0");
    306              }
    307              strcat((char*)buf, (char const*)tmp1);
    308              if (!num2 && !num1)
    309                strcpy((char*)buf, "0");
    310            }
    311            else
    312              return NULL;
    313          
    314            return buf;
   \                     ??_ltoa_15:
   \   0001B8   7434         MOV     A,#0x34
   \   0001BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BD   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0001C0   7424         MOV     A,#0x24
   \   0001C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C5   02....       LJMP    ?Subroutine24 & 0xFFFF
   \                     ??_ltoa_0:
   \   0001C8   7410         MOV     A,#0x10
   \   0001CA   69           XRL     A,R1
   \   0001CB   6003         JZ      $+5
   \   0001CD   02....       LJMP    ??_ltoa_19 & 0xFFFF
   \   0001D0   7402         MOV     A,#0x2
   \   0001D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D5   78..         MOV     R0,#?V0 + 0
   \   0001D7   12....       LCALL   ?L_MOV_X
   \   0001DA   85..82       MOV     DPL,?XSP + 0
   \   0001DD   85..83       MOV     DPH,?XSP + 1
   \   0001E0   E5..         MOV     A,?V0 + 0
   \   0001E2   F0           MOVX    @DPTR,A
   \   0001E3   A3           INC     DPTR
   \   0001E4   E5..         MOV     A,?V0 + 1
   \   0001E6   F0           MOVX    @DPTR,A
   \   0001E7   7402         MOV     A,#0x2
   \   0001E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EC   78..         MOV     R0,#?V0 + 0
   \   0001EE   12....       LCALL   ?L_MOV_X
   \   0001F1   7410         MOV     A,#0x10
   \   0001F3   78..         MOV     R0,#?V0 + 0
   \   0001F5   12....       LCALL   ?UL_SHR
   \   0001F8   AE..         MOV     R6,?V0 + 0
   \   0001FA   AF..         MOV     R7,?V0 + 1
   \   0001FC   EE           MOV     A,R6
   \   0001FD   7001         JNZ     ??_ltoa_20
   \   0001FF   EF           MOV     A,R7
   \                     ??_ltoa_20:
   \   000200   6011         JZ      ??_ltoa_21
   \   000202                ; Setup parameters for call to function _itoa
   \   000202   7910         MOV     R1,#0x10
   \   000204   E9           MOV     A,R1
   \   000205   12....       LCALL   ?XSTACK_DISP0_8
   \   000208   AC82         MOV     R4,DPL
   \   00020A   AD83         MOV     R5,DPH
   \   00020C   EE           MOV     A,R6
   \   00020D   FA           MOV     R2,A
   \   00020E   EF           MOV     A,R7
   \   00020F   FB           MOV     R3,A
   \   000210   12....       LCALL   ??_itoa?relay
   \                     ??_ltoa_21:
   \   000213   85..82       MOV     DPL,?XSP + 0
   \   000216   85..83       MOV     DPH,?XSP + 1
   \   000219   E0           MOVX    A,@DPTR
   \   00021A   7002         JNZ     ??_ltoa_22
   \   00021C   A3           INC     DPTR
   \   00021D   E0           MOVX    A,@DPTR
   \                     ??_ltoa_22:
   \   00021E   600A         JZ      ??CrossCallReturnLabel_19
   \   000220                ; Setup parameters for call to function _itoa
   \   000220   7910         MOV     R1,#0x10
   \   000222   7406         MOV     A,#0x6
   \   000224   12....       LCALL   ?XSTACK_DISP0_8
   \   000227   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00022A   EE           MOV     A,R6
   \   00022B   7001         JNZ     ??_ltoa_23
   \   00022D   EF           MOV     A,R7
   \                     ??_ltoa_23:
   \   00022E   602C         JZ      ??_ltoa_24
   \   000230                ; Setup parameters for call to function strcpy
   \   000230   7410         MOV     A,#0x10
   \   000232   12....       LCALL   ?XSTACK_DISP0_8
   \   000235   AC82         MOV     R4,DPL
   \   000237   AD83         MOV     R5,DPH
   \   000239   7434         MOV     A,#0x34
   \   00023B   12....       LCALL   ?XSTACK_DISP0_8
   \   00023E   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000241   800C         SJMP    ??CrossCallReturnLabel_7
   \                     ??_ltoa_25:
   \   000243                ; Setup parameters for call to function strcat
   \   000243   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   000245   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   000247   7434         MOV     A,#0x34
   \   000249   12....       LCALL   ?XSTACK_DISP0_8
   \   00024C   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00024F   85....       MOV     ?V0 + 2,?V0 + 0
   \   000252                ; Setup parameters for call to function strlen
   \   000252   7406         MOV     A,#0x6
   \   000254   12....       LCALL   ?XSTACK_DISP0_8
   \   000257   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00025A   40E7         JC      ??_ltoa_25
   \                     ??_ltoa_24:
   \   00025C                ; Setup parameters for call to function strcat
   \   00025C   7406         MOV     A,#0x6
   \   00025E   12....       LCALL   ?XSTACK_DISP0_8
   \   000261   AC82         MOV     R4,DPL
   \   000263   AD83         MOV     R5,DPH
   \   000265   7434         MOV     A,#0x34
   \   000267   12....       LCALL   ?XSTACK_DISP0_8
   \   00026A   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00026D   12....       LCALL   ??strcat?relay
   \   000270   02....       LJMP    ??_ltoa_16 & 0xFFFF
   \                     ??_ltoa_19:
   \   000273   7A00         MOV     R2,#0x0
   \   000275   7B00         MOV     R3,#0x0
   \   000277   02....       LJMP    ??CrossCallReturnLabel_21 & 0xFFFF
    315          #endif
    316          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00000D   12....       LCALL   ??_itoa?relay
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000003   E5..         MOV     A,?V0 + 6
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000003   12....       LCALL   ??strcpy?relay
   \   000006   75..00       MOV     ?V0 + 0,#0x0
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000003   05..         INC     ?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000003   12....       LCALL   ??strcat?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   8A..         MOV     ?V0 + 4,R2
   \   000009   8B..         MOV     ?V0 + 5,R3
   \   00000B   7404         MOV     A,#0x4
   \   00000D   C3           CLR     C
   \   00000E   95..         SUBB    A,?V0 + 4
   \   000010   F8           MOV     R0,A
   \   000011   E4           CLR     A
   \   000012   95..         SUBB    A,?V0 + 5
   \   000014   F9           MOV     R1,A
   \   000015   C3           CLR     C
   \   000016   E5..         MOV     A,?V0 + 2
   \   000018   98           SUBB    A,R0
   \   000019   E4           CLR     A
   \   00001A   99           SUBB    A,R1
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \                     ??Subroutine8_0:
   \   000004   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    317          #endif // !defined(ZBIT) && !defined(ZBIT2)
    318          
    319          /*********************************************************************
    320           * @fn          osal_AddrEqual
    321           *
    322           * @brief       Compares two address_t structures.
    323           *
    324           * @param       a1 - first Address
    325           * @param       a2 - second endpoint
    326           *
    327           * @return      true - addresses are equal, false - not equal
    328           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    329          byte osal_AddrEqual( zAddrType_t *a1, zAddrType_t *a2 )
   \                     osal_AddrEqual:
    330          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    331            if ( a1->addrMode != a2->addrMode )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FE           MOV     R6,A
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   6004         JZ      ??osal_AddrEqual_0
    332              return ( false );
   \                     ??osal_AddrEqual_1:
   \   000023   7900         MOV     R1,#0x0
   \   000025   803D         SJMP    ??osal_AddrEqual_2
    333          
    334            else if (a1->addrMode == AddrNotPresent )
   \                     ??osal_AddrEqual_0:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   7004         JNZ     ??osal_AddrEqual_3
    335              return ( true );
   \                     ??osal_AddrEqual_4:
   \   000036   7901         MOV     R1,#0x1
   \   000038   802A         SJMP    ??osal_AddrEqual_2
    336          
    337            else if (a1->addrMode == Addr16Bit )
   \                     ??osal_AddrEqual_3:
   \   00003A   6402         XRL     A,#0x2
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   7012         JNZ     ??osal_AddrEqual_5
    338              return ( a1->addr.shortAddr == a2->addr.shortAddr );
   \   000042   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000045   8C82         MOV     DPL,R4
   \   000047   8D83         MOV     DPH,R5
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   68           XRL     A,R0
   \   00004B   7003         JNZ     ??osal_AddrEqual_6
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   69           XRL     A,R1
   \                     ??osal_AddrEqual_6:
   \   000050   70D1         JNZ     ??osal_AddrEqual_1
   \   000052   80E2         SJMP    ??osal_AddrEqual_4
    339          
    340            else if ( a1->addrMode == Addr64Bit )
   \                     ??osal_AddrEqual_5:
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   6403         XRL     A,#0x3
   \   00005F   70C2         JNZ     ??osal_AddrEqual_1
    341              return ( osal_ExtAddrEqual( a1->addr.extAddr, a2->addr.extAddr ) );
   \   000061                ; Setup parameters for call to function osal_ExtAddrEqual
   \   000061   12....       LCALL   ??osal_ExtAddrEqual?relay
   \                     ??osal_AddrEqual_2:
   \   000064   02....       LJMP    ?Subroutine23 & 0xFFFF
    342          
    343            else
    344              return ( false );
    345          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    346          
    347          /*********************************************************************
    348           * @fn      osal_ExtAddrEqual()
    349           *
    350           * @brief   Verify that the extended addresses are equal.
    351           *
    352           * @param   extAddr1 - extended address
    353           * @param   extAddr2 - extended address
    354           *
    355           * @return  TRUE - If addresses are same
    356           *          FALSE  - If not same
    357           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          byte osal_ExtAddrEqual( byte *extAddr1, byte *extAddr2 )
   \                     osal_ExtAddrEqual:
    359          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    360            byte i;
    361          
    362            for ( i = Z_EXTADDR_LEN; i ; i-- )
   \   000005   75..08       MOV     ?V0 + 0,#0x8
    363            {
    364              if ( *extAddr1++ != *extAddr2++ )
   \                     ??osal_ExtAddrEqual_0:
   \   000008   EA           MOV     A,R2
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   F9           MOV     R1,A
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \   000010   A3           INC     DPTR
   \   000011   AA82         MOV     R2,DPL
   \   000013   AB83         MOV     R3,DPH
   \   000015   EC           MOV     A,R4
   \   000016   FE           MOV     R6,A
   \   000017   ED           MOV     A,R5
   \   000018   FF           MOV     R7,A
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   8882         MOV     DPL,R0
   \   000024   8983         MOV     DPH,R1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   68           XRL     A,R0
   \   00002E   6004         JZ      ??osal_ExtAddrEqual_1
    365                return ( false );
   \   000030   7900         MOV     R1,#0x0
   \   000032   8008         SJMP    ??osal_ExtAddrEqual_2
    366            }
   \                     ??osal_ExtAddrEqual_1:
   \   000034   15..         DEC     ?V0 + 0
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   70CE         JNZ     ??osal_ExtAddrEqual_0
    367          
    368            return ( true );
   \   00003A   7901         MOV     R1,#0x1
   \                     ??osal_ExtAddrEqual_2:
   \   00003C   80..         SJMP    ?Subroutine21
    369          }
    370          
    371          /*********************************************************************
    372           * @fn        osal_rand
    373           *
    374           * @brief    Random number generator
    375           *
    376           * @param   none
    377           *
    378           * @return  uint16 - new random number
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          uint16 osal_rand( void )
   \                     osal_rand:
    381          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    382            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL   ??Onboard_rand?relay
   \   000007   02....       LJMP    ?Subroutine19 & 0xFFFF
    383          }
    384          
    385          /*********************************************************************
    386           * API FUNCTIONS
    387           *********************************************************************/
    388          
    389          /*********************************************************************
    390           * @fn      osal_msg_allocate
    391           *
    392           * @brief
    393           *
    394           *    This function is called by a task to allocate a message buffer
    395           *    into which the task will encode the particular message it wishes
    396           *    to send.  This common buffer scheme is used to strictly limit the
    397           *    creation of message buffers within the system due to RAM size
    398           *    limitations on the microprocessor.   Note that all message buffers
    399           *    are a fixed size (at least initially).  The parameter len is kept
    400           *    in case a message pool with varying fixed message sizes is later
    401           *    created (for example, a pool of message buffers of size LARGE,
    402           *    MEDIUM and SMALL could be maintained and allocated based on request
    403           *    from the tasks).
    404           *
    405           *
    406           * @param   byte len  - wanted buffer length
    407           *
    408           *
    409           * @return  pointer to allocated buffer or NULL if allocation failed.
    410           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    411          byte * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    412          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    413            osal_msg_hdr_t *hdr;
    414          
    415            if ( len == 0 )
   \   000009   EE           MOV     A,R6
   \   00000A   7001         JNZ     ??osal_msg_allocate_0
   \   00000C   EF           MOV     A,R7
   \                     ??osal_msg_allocate_0:
   \   00000D   7006         JNZ     ??osal_msg_allocate_1
    416              return ( NULL );
   \                     ??osal_msg_allocate_2:
   \   00000F   7A00         MOV     R2,#0x0
   \   000011   7B00         MOV     R3,#0x0
   \   000013   803E         SJMP    ??osal_msg_allocate_3
    417          
    418            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \                     ??osal_msg_allocate_1:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7405         MOV     A,#0x5
   \   000017   2E           ADD     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??osal_mem_alloc?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   8B..         MOV     ?V0 + 1,R3
   \   000023   A8..         MOV     R0,?V0 + 0
   \   000025   A9..         MOV     R1,?V0 + 1
    419            if ( hdr )
   \   000027   E8           MOV     A,R0
   \   000028   7001         JNZ     ??osal_msg_allocate_4
   \   00002A   E9           MOV     A,R1
   \                     ??osal_msg_allocate_4:
   \   00002B   60E2         JZ      ??osal_msg_allocate_2
    420            {
    421              hdr->next = NULL;
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   E4           CLR     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   F0           MOVX    @DPTR,A
    422              hdr->len = len;
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   EE           MOV     A,R6
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   EF           MOV     A,R7
   \   00003F   F0           MOVX    @DPTR,A
    423              hdr->dest_id = TASK_NO_TASK;
   \   000040   74FF         MOV     A,#-0x1
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   F0           MOVX    @DPTR,A
    424          
    425          #if defined( OSAL_TOTAL_MEM )
    426              osal_msg_cnt++;
    427          #endif
    428              return ( (byte *) (hdr + 1) );
   \   00004B   E8           MOV     A,R0
   \   00004C   2405         ADD     A,#0x5
   \   00004E   FA           MOV     R2,A
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   FB           MOV     R3,A
   \                     ??osal_msg_allocate_3:
   \   000053                REQUIRE ?Subroutine21
   \   000053                ; // Fall through to label ?Subroutine21
    429            }
    430            else
    431              return ( NULL );
    432          }
    433          
    434          /*********************************************************************
    435           * @fn      osal_msg_deallocate
    436           *
    437           * @brief
    438           *
    439           *    This function is used to deallocate a message buffer. This function
    440           *    is called by a task (or processing element) after it has finished
    441           *    processing a received message.
    442           *
    443           *
    444           * @param   byte *msg_ptr - pointer to new message buffer
    445           *
    446           * @return  ZSUCCESS, INVALID_MSG_POINTER
    447           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    448          byte osal_msg_deallocate( byte *msg_ptr )
   \                     osal_msg_deallocate:
    449          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    450            byte *x;
    451          
    452            if ( msg_ptr == NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??osal_msg_deallocate_0
   \   000007   EB           MOV     A,R3
   \                     ??osal_msg_deallocate_0:
   \   000008   7004         JNZ     ??osal_msg_deallocate_1
    453              return ( INVALID_MSG_POINTER );
   \   00000A   7903         MOV     R1,#0x3
   \   00000C   8018         SJMP    ??osal_msg_deallocate_2
    454          
    455            // don't deallocate queued buffer
    456            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_1:
   \   00000E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000011   64FF         XRL     A,#0xff
   \   000013   6004         JZ      ??osal_msg_deallocate_3
    457              return ( MSG_BUFFER_NOT_AVAIL );
   \   000015   7902         MOV     R1,#0x2
   \   000017   800D         SJMP    ??osal_msg_deallocate_2
    458          
    459            x = (byte *)((byte *)msg_ptr - sizeof( osal_msg_hdr_t ));
    460          
    461            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_3:
   \   000019                ; Setup parameters for call to function osal_mem_free
   \   000019   EA           MOV     A,R2
   \   00001A   24FB         ADD     A,#-0x5
   \   00001C   FA           MOV     R2,A
   \   00001D   EB           MOV     A,R3
   \   00001E   34FF         ADDC    A,#-0x1
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_mem_free?relay
    462          
    463          #if defined( OSAL_TOTAL_MEM )
    464            if ( osal_msg_cnt )
    465              osal_msg_cnt--;
    466          #endif
    467          
    468            return ( ZSUCCESS );
   \   000024   7900         MOV     R1,#0x0
   \                     ??osal_msg_deallocate_2:
   \   000026                REQUIRE ?Subroutine19
   \   000026                ; // Fall through to label ?Subroutine19
    469          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EA           MOV     A,R2
   \   000001   24FF         ADD     A,#-0x1
   \                     ??Subroutine13_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \                     ??Subroutine13_1:
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET
    470          
    471          #if defined( OSAL_TOTAL_MEM )
    472          /*********************************************************************
    473           * @fn      osal_num_msgs
    474           *
    475           * @brief
    476           *
    477           *    This function returns the number of allocated messages
    478           *
    479           * @param   void
    480           *
    481           * @return  UINT16 - number of msgs out
    482           */
    483          UINT16 osal_num_msgs( void )
    484          {
    485            return ( osal_msg_cnt );
    486          }
    487          #endif
    488          
    489          /*********************************************************************
    490           * @fn      osal_msg_send
    491           *
    492           * @brief
    493           *
    494           *    This function is called by a task to send a command message to
    495           *    another task or processing element.  The sending_task field must
    496           *    refer to a valid task, since the task ID will be used
    497           *    for the response message.  This function will also set a message
    498           *    ready event in the destination tasks event list.
    499           *
    500           *
    501           * @param   byte destination task - Send msg to?  Task ID
    502           * @param   byte *msg_ptr - pointer to new message buffer
    503           * @param   byte len - length of data in message
    504           *
    505           * @return  ZSUCCESS, INVALID_SENDING_TASK, INVALID_DESTINATION_TASK,
    506           *          INVALID_MSG_POINTER, INVALID_LEN
    507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    508          byte osal_msg_send( byte destination_task, byte *msg_ptr )
   \                     osal_msg_send:
    509          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    510            if ( msg_ptr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   7001         JNZ     ??osal_msg_send_0
   \   00000A   EB           MOV     A,R3
   \                     ??osal_msg_send_0:
   \   00000B   7004         JNZ     ??osal_msg_send_1
    511              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_send_2:
   \   00000D   7903         MOV     R1,#0x3
   \   00000F   8041         SJMP    ??osal_msg_send_3
    512          
    513            if ( destination_task >= tasksCnt )
   \                     ??osal_msg_send_1:
   \   000011   90....       MOV     DPTR,#tasksCnt
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FC           MOV     R4,A
   \   000016   E9           MOV     A,R1
   \   000017   C3           CLR     C
   \   000018   9C           SUBB    A,R4
   \   000019   4007         JC      ??osal_msg_send_4
    514            {
    515              osal_msg_deallocate( msg_ptr );
   \   00001B                ; Setup parameters for call to function osal_msg_deallocate
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay
    516              return ( INVALID_TASK );
   \   00001E   7901         MOV     R1,#0x1
   \   000020   8030         SJMP    ??osal_msg_send_3
    517            }
    518          
    519            // Check the message header
    520            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    521                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_send_4:
   \   000022   EA           MOV     A,R2
   \   000023   24FB         ADD     A,#-0x5
   \   000025   12....       LCALL   ??Subroutine13_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000028   7002         JNZ     ??osal_msg_send_5
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \                     ??osal_msg_send_5:
   \   00002C   7007         JNZ     ??osal_msg_send_6
   \   00002E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000031   64FF         XRL     A,#0xff
   \   000033   6005         JZ      ??osal_msg_send_7
    522            {
    523              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_send_6:
   \   000035                ; Setup parameters for call to function osal_msg_deallocate
   \   000035   12....       LCALL   ??osal_msg_deallocate?relay
   \   000038   80D3         SJMP    ??osal_msg_send_2
    524              return ( INVALID_MSG_POINTER );
    525            }
    526          
    527            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_send_7:
   \   00003A   EE           MOV     A,R6
   \   00003B   F0           MOVX    @DPTR,A
    528          
    529            // queue message
    530            osal_msg_enqueue( &osal_qHead, msg_ptr );
   \   00003C                ; Setup parameters for call to function osal_msg_enqueue
   \   00003C   EA           MOV     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   EB           MOV     A,R3
   \   00003F   FD           MOV     R5,A
   \   000040   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   000042   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   000044   12....       LCALL   ??osal_msg_enqueue?relay
    531          
    532            // Signal the task that a message is waiting
    533            osal_set_event( destination_task, SYS_EVENT_MSG );
   \   000047                ; Setup parameters for call to function osal_set_event
   \   000047   7A00         MOV     R2,#0x0
   \   000049   7B80         MOV     R3,#-0x80
   \   00004B   EE           MOV     A,R6
   \   00004C   F9           MOV     R1,A
   \   00004D   12....       LCALL   ??osal_set_event?relay
    534          
    535            return ( ZSUCCESS );
   \   000050   7900         MOV     R1,#0x0
   \                     ??osal_msg_send_3:
   \   000052                REQUIRE ?Subroutine23
   \   000052                ; // Fall through to label ?Subroutine23
    536          }
    537          
    538          /*********************************************************************
    539           * @fn      osal_msg_receive
    540           *
    541           * @brief
    542           *
    543           *    This function is called by a task to retrieve a received command
    544           *    message. The calling task must deallocate the message buffer after
    545           *    processing the message using the osal_msg_deallocate() call.
    546           *
    547           * @param   byte task_id - receiving tasks ID
    548           *
    549           * @return  *byte - message information or NULL if no message
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          byte *osal_msg_receive( byte task_id )
   \                     osal_msg_receive:
    552          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    553            osal_msg_hdr_t *listHdr;
    554            osal_msg_hdr_t *prevHdr=0;
   \   000005   75..00       MOV     ?V0 + 2,#0x0
   \   000008   75..00       MOV     ?V0 + 3,#0x0
    555            halIntState_t   intState;
    556          
    557            // Hold off interrupts
    558            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000B   A2AF         MOV     C,0xa8.7
   \   00000D   E4           CLR     A
   \   00000E   92E0         MOV     0xE0 /* A   */.0,C
   \   000010   FE           MOV     R6,A
   \   000011   C2AF         CLR     0xa8.7
    559          
    560            // Point to the top of the queue
    561            listHdr = osal_qHead;
   \   000013   90....       MOV     DPTR,#osal_qHead
   \   000016   8020         SJMP    ??osal_msg_receive_0
    562          
    563            // Look through the queue for a message that belongs to the asking task
    564            while ( listHdr != NULL )
    565            {
    566              if ( (listHdr - 1)->dest_id == task_id )
   \                     ??osal_msg_receive_1:
   \   000018   E5..         MOV     A,?V0 + 0
   \   00001A   24FF         ADD     A,#-0x1
   \   00001C   F582         MOV     DPL,A
   \   00001E   E5..         MOV     A,?V0 + 1
   \   000020   12....       LCALL   ??Subroutine13_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000023   69           XRL     A,R1
   \   000024   602C         JZ      ??osal_msg_receive_2
    567              {
    568                break;
    569              }
    570              prevHdr = listHdr;
   \   000026   85....       MOV     ?V0 + 2,?V0 + 0
   \   000029   85....       MOV     ?V0 + 3,?V0 + 1
    571              listHdr = OSAL_MSG_NEXT( listHdr );
   \   00002C   E5..         MOV     A,?V0 + 0
   \   00002E   24FB         ADD     A,#-0x5
   \   000030   F582         MOV     DPL,A
   \   000032   E5..         MOV     A,?V0 + 1
   \   000034   34FF         ADDC    A,#-0x1
   \   000036   F583         MOV     DPH,A
   \                     ??osal_msg_receive_0:
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V0 + 1,A
    572            }
   \   00003F   E5..         MOV     A,?V0 + 0
   \   000041   7002         JNZ     ??osal_msg_receive_3
   \   000043   E5..         MOV     A,?V0 + 1
   \                     ??osal_msg_receive_3:
   \   000045   70D1         JNZ     ??osal_msg_receive_1
    573          
    574            // Did we find a message?
    575            if ( listHdr == NULL )
    576            {
    577              // Release interrupts
    578              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000047   EE           MOV     A,R6
   \   000048   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004A   92AF         MOV     0xa8.7,C
    579              return NULL;
   \   00004C   7A00         MOV     R2,#0x0
   \   00004E   7B00         MOV     R3,#0x0
   \   000050   801E         SJMP    ??osal_msg_receive_4
    580            }
    581          
    582            // Take out of the link list
    583            osal_msg_extract( &osal_qHead, listHdr, prevHdr );
   \                     ??osal_msg_receive_2:
   \   000052                ; Setup parameters for call to function osal_msg_extract
   \   000052   78..         MOV     R0,#?V0 + 2
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   AC..         MOV     R4,?V0 + 0
   \   000059   AD..         MOV     R5,?V0 + 1
   \   00005B   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   00005D   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   00005F   12....       LCALL   ??osal_msg_extract?relay
   \   000062   7402         MOV     A,#0x2
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
    584          
    585            // Release interrupts
    586            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000067   EE           MOV     A,R6
   \   000068   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006A   92AF         MOV     0xa8.7,C
    587          
    588            return ( (byte*) listHdr );
   \   00006C   AA..         MOV     R2,?V0 + 0
   \   00006E   AB..         MOV     R3,?V0 + 1
   \                     ??osal_msg_receive_4:
   \   000070   7F04         MOV     R7,#0x4
   \   000072   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000075                REQUIRE _A_IEN0
    589          }
    590          
    591          /*********************************************************************
    592           * @fn      osal_msg_enqueue
    593           *
    594           * @brief
    595           *
    596           *    This function enqueues an OSAL message into an OSAL queue.
    597           *
    598           * @param   osal_msg_q_t *q_ptr - OSAL queue
    599           * @param   void *msg_ptr  - OSAL message
    600           *
    601           * @return  none
    602           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    603          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    604          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    605            void *list;
    606            halIntState_t intState;
    607          
    608            // Hold off interrupts
    609            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    610          
    611            // If first message in queue
    612            if ( *q_ptr == NULL )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7002         JNZ     ??osal_msg_enqueue_0
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_0:
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   7005         JNZ     ??CrossCallReturnLabel_53
    613            {
    614              *q_ptr = msg_ptr;
   \   00001C   8018         SJMP    ??CrossCallReturnLabel_54
    615            }
    616            else
    617            {
    618              // Find end of queue
    619              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_1:
   \   00001E   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000021   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000024   E8           MOV     A,R0
   \   000025   24FB         ADD     A,#-0x5
   \   000027   F582         MOV     DPL,A
   \   000029   E9           MOV     A,R1
   \   00002A   12....       LCALL   ??Subroutine13_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00002D   7002         JNZ     ??osal_msg_enqueue_2
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_2:
   \   000031   70EB         JNZ     ??osal_msg_enqueue_1
    620          
    621              // Add message to end of queue
    622              OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000033   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000036                REQUIRE ?Subroutine22
   \   000036                REQUIRE _A_IEN0
   \   000036                ; // Fall through to label ?Subroutine22
    623            }
    624          
    625            // Re-enable interrupts
    626            HAL_EXIT_CRITICAL_SECTION(intState);
    627          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   EC           MOV     A,R4
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   ED           MOV     A,R5
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EE           MOV     A,R6
   \   000006   A2E0         MOV     C,0xE0 /* A   */.0
   \   000008   92AF         MOV     0xa8.7,C
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E8           MOV     A,R0
   \   000001   24FB         ADD     A,#-0x5
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006                REQUIRE ?Subroutine26
   \   000006                ; // Fall through to label ?Subroutine26

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
    628          
    629          /*********************************************************************
    630           * @fn      osal_msg_dequeue
    631           *
    632           * @brief
    633           *
    634           *    This function dequeues an OSAL message from an OSAL queue.
    635           *
    636           * @param   osal_msg_q_t *q_ptr - OSAL queue
    637           *
    638           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    639           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    640          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    641          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
    642            void *msg_ptr;
    643            halIntState_t intState;
    644          
    645            // Hold off interrupts
    646            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   92E0         MOV     0xE0 /* A   */.0,C
   \   00000E   F5..         MOV     ?V0 + 0,A
   \   000010   C2AF         CLR     0xa8.7
    647          
    648            if ( *q_ptr == NULL )
   \   000012   8882         MOV     DPL,R0
   \   000014   8983         MOV     DPH,R1
   \   000016   E0           MOVX    A,@DPTR
   \   000017   7002         JNZ     ??osal_msg_dequeue_0
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \                     ??osal_msg_dequeue_0:
   \   00001B   700C         JNZ     ??osal_msg_dequeue_1
    649            {
    650              HAL_EXIT_CRITICAL_SECTION(intState);
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   92AF         MOV     0xa8.7,C
    651              return NULL;
   \   000023   7A00         MOV     R2,#0x0
   \   000025   7B00         MOV     R3,#0x0
   \   000027   802E         SJMP    ??CrossCallReturnLabel_47
    652            }
    653          
    654            // Dequeue message
    655            msg_ptr = *q_ptr;
   \                     ??osal_msg_dequeue_1:
   \   000029   12....       LCALL   ?Subroutine8 & 0xFFFF
    656            *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \                     ??CrossCallReturnLabel_23:
   \   00002C   EA           MOV     A,R2
   \   00002D   24FB         ADD     A,#-0x5
   \   00002F   FC           MOV     R4,A
   \   000030   EB           MOV     A,R3
   \   000031   34FF         ADDC    A,#-0x1
   \   000033   FD           MOV     R5,A
   \   000034   8C82         MOV     DPL,R4
   \   000036   8D83         MOV     DPH,R5
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FE           MOV     R6,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FF           MOV     R7,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   EE           MOV     A,R6
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   EF           MOV     A,R7
   \   000045   F0           MOVX    @DPTR,A
    657            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000046   8C82         MOV     DPL,R4
   \   000048   8D83         MOV     DPH,R5
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
    658            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00004E   EA           MOV     A,R2
   \   00004F   24FF         ADD     A,#-0x1
   \   000051   F582         MOV     DPL,A
   \   000053   EB           MOV     A,R3
   \   000054   12....       LCALL   ?Subroutine15 & 0xFFFF
    659          
    660            // Re-enable interrupts
    661            HAL_EXIT_CRITICAL_SECTION(intState);
    662          
    663            return msg_ptr;
   \                     ??CrossCallReturnLabel_47:
   \   000057   02....       LJMP    ?Subroutine21 & 0xFFFF
   \   00005A                REQUIRE _A_IEN0
    664          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   74FF         MOV     A,#-0x1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   E5..         MOV     A,?V0 + 0
   \   000009                REQUIRE ?Subroutine25
   \   000009                ; // Fall through to label ?Subroutine25

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A2E0         MOV     C,0xE0 /* A   */.0
   \   000002   92AF         MOV     0xa8.7,C
   \   000004   22           RET
    665          
    666          /*********************************************************************
    667           * @fn      osal_msg_push
    668           *
    669           * @brief
    670           *
    671           *    This function pushes an OSAL message to the head of an OSAL
    672           *    queue.
    673           *
    674           * @param   osal_msg_q_t *q_ptr - OSAL queue
    675           * @param   void *msg_ptr  - OSAL message
    676           *
    677           * @return  none
    678           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    679          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
    680          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    681            halIntState_t intState;
    682          
    683            // Hold off interrupts
    684            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    685          
    686            if ( *q_ptr == NULL )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7002         JNZ     ??osal_msg_push_0
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \                     ??osal_msg_push_0:
   \   000016   7007         JNZ     ??osal_msg_push_1
    687            {
    688              *q_ptr = msg_ptr;
   \                     ??osal_msg_push_2:
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   02....       LJMP    ?Subroutine22 & 0xFFFF
    689            }
    690            else
    691            {
    692              // Push message to head of queue
    693              OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \                     ??osal_msg_push_1:
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000026   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000029   E8           MOV     A,R0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E9           MOV     A,R1
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   80E8         SJMP    ??osal_msg_push_2
   \   000030                REQUIRE _A_IEN0
    694              *q_ptr = msg_ptr;
    695            }
    696          
    697            // Re-enable interrupts
    698            HAL_EXIT_CRITICAL_SECTION(intState);
    699          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EC           MOV     A,R4
   \   000001   24FB         ADD     A,#-0x5
   \   000003   F582         MOV     DPL,A
   \   000005   ED           MOV     A,R5
   \   000006   80..         SJMP    ?Subroutine26
    700          
    701          /*********************************************************************
    702           * @fn      osal_msg_extract
    703           *
    704           * @brief
    705           *
    706           *    This function extracts and removes an OSAL message from the
    707           *    middle of an OSAL queue.
    708           *
    709           * @param   osal_msg_q_t *q_ptr - OSAL queue
    710           * @param   void *msg_ptr  - OSAL message to be extracted
    711           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
    712           *
    713           * @return  none
    714           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    715          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
    716          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine3 & 0xFFFF
    717            halIntState_t intState;
    718          
    719            // Hold off interrupts
    720            HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_11:
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   92E0         MOV     0xE0 /* A   */.0,C
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   C2AF         CLR     0xa8.7
    721          
    722            if ( msg_ptr == *q_ptr )
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FE           MOV     R6,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FF           MOV     R7,A
   \   00001F   EC           MOV     A,R4
   \   000020   6E           XRL     A,R6
   \   000021   7002         JNZ     ??osal_msg_extract_0
   \   000023   ED           MOV     A,R5
   \   000024   6F           XRL     A,R7
   \                     ??osal_msg_extract_0:
   \   000025   7010         JNZ     ??osal_msg_extract_1
    723            {
    724              // remove from first
    725              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000027   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00002A   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00002D   8A82         MOV     DPL,R2
   \   00002F   8B83         MOV     DPH,R3
   \   000031   E8           MOV     A,R0
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   E9           MOV     A,R1
   \   000035   800D         SJMP    ??osal_msg_extract_2
    726            }
    727            else
    728            {
    729              // remove from middle
    730              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000037   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00003A   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00003D   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000040   EA           MOV     A,R2
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   EB           MOV     A,R3
   \                     ??osal_msg_extract_2:
   \   000044   F0           MOVX    @DPTR,A
    731            }
    732            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000045   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
    733            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00004C   EC           MOV     A,R4
   \   00004D   24FF         ADD     A,#-0x1
   \   00004F   F582         MOV     DPL,A
   \   000051   ED           MOV     A,R5
   \   000052   12....       LCALL   ?Subroutine15 & 0xFFFF
    734          
    735            // Re-enable interrupts
    736            HAL_EXIT_CRITICAL_SECTION(intState);
    737          }
   \                     ??CrossCallReturnLabel_48:
   \   000055   02....       LJMP    ?Subroutine23 & 0xFFFF
   \   000058                REQUIRE _A_IEN0
    738          
    739          /*********************************************************************
    740           * @fn      osal_msg_enqueue_max
    741           *
    742           * @brief
    743           *
    744           *    This function enqueues an OSAL message into an OSAL queue if
    745           *    the length of the queue is less than max.
    746           *
    747           * @param   osal_msg_q_t *q_ptr - OSAL queue
    748           * @param   void *msg_ptr  - OSAL message
    749           * @param   byte max - maximum length of queue
    750           *
    751           * @return  TRUE if message was enqueued, FALSE otherwise
    752           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    753          byte osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, byte max )
   \                     osal_msg_enqueue_max:
    754          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    755            void *list;
    756            byte ret = FALSE;
   \   000007   75..00       MOV     ?V0 + 0,#0x0
    757            halIntState_t intState;
    758          
    759            // Hold off interrupts
    760            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FF           MOV     R7,A
   \   000010   C2AF         CLR     0xa8.7
    761          
    762            // If first message in queue
    763            if ( *q_ptr == NULL )
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   E0           MOVX    A,@DPTR
   \   000017   7002         JNZ     ??osal_msg_enqueue_max_0
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_0:
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   7005         JNZ     ??CrossCallReturnLabel_56
    764            {
    765              *q_ptr = msg_ptr;
   \   000021   801F         SJMP    ??CrossCallReturnLabel_57
    766              ret = TRUE;
    767            }
    768            else
    769            {
    770              // Find end of queue or max
    771              list = *q_ptr;
    772              max--;
    773              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
    774              {
    775                list = OSAL_MSG_NEXT( list );
   \                     ??osal_msg_enqueue_max_1:
   \   000023   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000026   12....       LCALL   ?Subroutine3 & 0xFFFF
    776                max--;
   \                     ??CrossCallReturnLabel_13:
   \   000029   1E           DEC     R6
    777              }
   \   00002A   E8           MOV     A,R0
   \   00002B   24FB         ADD     A,#-0x5
   \   00002D   F582         MOV     DPL,A
   \   00002F   E9           MOV     A,R1
   \   000030   12....       LCALL   ??Subroutine13_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000033   7002         JNZ     ??osal_msg_enqueue_max_2
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_2:
   \   000037   6003         JZ      ??osal_msg_enqueue_max_3
   \   000039   EE           MOV     A,R6
   \   00003A   70E7         JNZ     ??osal_msg_enqueue_max_1
    778          
    779              // Add message to end of queue if max not reached
    780              if ( max != 0 )
   \                     ??osal_msg_enqueue_max_3:
   \   00003C   EE           MOV     A,R6
   \   00003D   600B         JZ      ??osal_msg_enqueue_max_4
    781              {
    782                OSAL_MSG_NEXT( list ) = msg_ptr;
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000042   EC           MOV     A,R4
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   ED           MOV     A,R5
   \   000046   F0           MOVX    @DPTR,A
    783                ret = TRUE;
   \   000047   75..01       MOV     ?V0 + 0,#0x1
    784              }
    785            }
    786          
    787            // Re-enable interrupts
    788            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_4:
   \   00004A   EF           MOV     A,R7
   \   00004B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004D   92AF         MOV     0xa8.7,C
    789          
    790            return ret;
   \   00004F   A9..         MOV     R1,?V0 + 0
   \   000051   02....       LJMP    ?Subroutine21 & 0xFFFF
   \   000054                REQUIRE _A_IEN0
    791          }
    792          
    793          /*********************************************************************
    794           * @fn      osal_set_event
    795           *
    796           * @brief
    797           *
    798           *    This function is called to set the event flags for a task.  The
    799           *    event passed in is OR'd into the task's event variable.
    800           *
    801           * @param   byte task_id - receiving tasks ID
    802           * @param   byte event_flag - what event to set
    803           *
    804           * @return  ZSUCCESS, INVALID_TASK
    805           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    806          byte osal_set_event( byte task_id, UINT16 event_flag )
   \                     osal_set_event:
    807          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    808            if ( task_id < tasksCnt )
   \   000004   90....       MOV     DPTR,#tasksCnt
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FC           MOV     R4,A
   \   000009   E9           MOV     A,R1
   \   00000A   C3           CLR     C
   \   00000B   9C           SUBB    A,R4
   \   00000C   501F         JNC     ??osal_set_event_0
    809            {
    810            halIntState_t   intState;
    811              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   00000E   A2AF         MOV     C,0xa8.7
   \   000010   E4           CLR     A
   \   000011   92E0         MOV     0xE0 /* A   */.0,C
   \   000013   FD           MOV     R5,A
   \   000014   C2AF         CLR     0xa8.7
    812              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   000016   E9           MOV     A,R1
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   F8           MOV     R0,A
   \   00001A   E4           CLR     A
   \   00001B   33           RLC     A
   \   00001C   F9           MOV     R1,A
   \   00001D   90....       MOV     DPTR,#tasksEvents
   \   000020   E0           MOVX    A,@DPTR
   \   000021   28           ADD     A,R0
   \   000022   FC           MOV     R4,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   39           ADDC    A,R1
   \   000026   12....       LCALL   ?Subroutine4 & 0xFFFF
    813              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
    814            }
    815             else
    816              return ( INVALID_TASK );
    817          
    818            return ( ZSUCCESS );
   \                     ??CrossCallReturnLabel_45:
   \   000029   7900         MOV     R1,#0x0
   \   00002B   8002         SJMP    ??osal_set_event_1
   \                     ??osal_set_event_0:
   \   00002D   7901         MOV     R1,#0x1
   \                     ??osal_set_event_1:
   \   00002F   02....       LJMP    ?Subroutine19 & 0xFFFF
   \   000032                REQUIRE _A_IEN0
    819          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   8C82         MOV     DPL,R4
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   4A           ORL     A,R2
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   4B           ORL     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   ED           MOV     A,R5
   \   00000C   02....       LJMP    ?Subroutine25 & 0xFFFF
    820          
    821          /*********************************************************************
    822           * @fn      osal_isr_register
    823           *
    824           * @brief
    825           *
    826           *   This function is called to register a service routine with an
    827           *   interrupt. When the interrupt occurs, this service routine is called.
    828           *
    829           * @param   byte interrupt_id - Interrupt number
    830           * @param   void (*isr_ptr)( byte* ) - function pointer to ISR
    831           *
    832           * @return  ZSUCCESS, INVALID_INTERRUPT_ID, or INVALID_ISR_PTR
    833           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    834          byte osal_isr_register( byte interrupt_id, void (*isr_ptr)( byte* ) )
   \                     osal_isr_register:
    835          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    836            return ( ZSUCCESS );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    837          }
    838          
    839          /*********************************************************************
    840           * @fn      osal_int_enable
    841           *
    842           * @brief
    843           *
    844           *   This function is called to enable an interrupt. Once enabled,
    845           *   occurrence of the interrupt causes the service routine associated
    846           *   with that interrupt to be called.
    847           *
    848           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
    849           *   If a single interrupt is passed in, then interrupts still have
    850           *   to be enabled with another call to INTS_ALL.
    851           *
    852           * @param   byte interrupt_id - Interrupt number
    853           *
    854           * @return  ZSUCCESS or INVALID_INTERRUPT_ID
    855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    856          byte osal_int_enable( byte interrupt_id )
   \                     osal_int_enable:
    857          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    858          
    859            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_enable_0
    860            {
    861              HAL_ENABLE_INTERRUPTS();
   \   000005   D2AF         SETB    0xa8.7
    862            }
    863            else
    864              return ( INVALID_INTERRUPT_ID );
    865          
    866            return ( ZSUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_enable_1
   \                     ??osal_int_enable_0:
   \   00000B   7909         MOV     R1,#0x9
   \                     ??osal_int_enable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    867          }
    868          
    869          /*********************************************************************
    870           * @fn      osal_int_disable
    871           *
    872           * @brief
    873           *
    874           *   This function is called to disable an interrupt. When a disabled
    875           *   interrupt occurs, the service routine associated with that
    876           *   interrupt is not called.
    877           *
    878           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
    879           *   If a single interrupt is passed in, then just that interrupt is disabled.
    880           *
    881           * @param   byte interrupt_id - Interrupt number
    882           *
    883           * @return  ZSUCCESS or INVALID_INTERRUPT_ID
    884           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    885          byte osal_int_disable( byte interrupt_id )
   \                     osal_int_disable:
    886          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    887          
    888            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_disable_0
    889            {
    890              HAL_DISABLE_INTERRUPTS();
   \   000005   C2AF         CLR     0xa8.7
    891            }
    892            else
    893              return ( INVALID_INTERRUPT_ID );
    894          
    895            return ( ZSUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_disable_1
   \                     ??osal_int_disable_0:
   \   00000B   7909         MOV     R1,#0x9
   \                     ??osal_int_disable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    896          }
    897          
    898          /*********************************************************************
    899           * @fn      osal_init_system
    900           *
    901           * @brief
    902           *
    903           *   This function initializes the "task" system by creating the
    904           *   tasks defined in the task table (OSAL_Tasks.h).
    905           *
    906           * @param   void
    907           *
    908           * @return  ZSUCCESS
    909           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    910          byte osal_init_system( void )
   \                     osal_init_system:
    911          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    912            // Initialize the Memory Allocation System
    913            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL   ??osal_mem_init?relay
    914          
    915            // Initialize the message queue
    916            osal_qHead = NULL;
   \   000007   90....       MOV     DPTR,#osal_qHead
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
    917          
    918          #if defined( OSAL_TOTAL_MEM )
    919            osal_msg_cnt = 0;
    920          #endif
    921          
    922            // Initialize the timers
    923            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL   ??osalTimerInit?relay
    924          
    925            // Initialize the Power Management System
    926            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL   ??osal_pwrmgr_init?relay
    927          
    928            // Initialize the system tasks.
    929            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL   ??osalInitTasks?relay
    930          
    931            // Setup efficient search for the first free block of heap.
    932            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL   ??osal_mem_kick?relay
    933          
    934            return ( ZSUCCESS );
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   02....       LJMP    ?Subroutine19 & 0xFFFF
    935          }
    936          
    937          /*********************************************************************
    938           * @fn      osal_start_system
    939           *
    940           * @brief
    941           *
    942           *   This function is the main loop function of the task system.  It
    943           *   will look through all task events and call the task_event_processor()
    944           *   function for the task with the event.  If there are no events (for
    945           *   all tasks), this function puts the processor into Sleep.
    946           *   This Function doesn't return.
    947           *
    948           * @param   void
    949           *
    950           * @return  none
    951           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    952          void osal_start_system( void )
   \                     osal_start_system:
    953          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8055         SJMP    ??osal_start_system_0
    954          #if !defined ( ZBIT )
    955            for(;;)  // Forever Loop
    956          #endif
    957            {
    958              uint8 idx = 0;
    959          
    960              Hal_ProcessPoll();  // This replaces MT_SerialPoll() and osal_check_timer().
    961          
    962              do {
    963                if (tasksEvents[idx])  // Task is highest priority that is ready.
    964                {
    965                  break;
    966                }
    967              } while (++idx < tasksCnt);
    968          
    969              if (idx < tasksCnt)
    970              {
    971                uint16 events;
    972                halIntState_t intState;
    973          
    974                HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??osal_start_system_1:
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   92E0         MOV     0xE0 /* A   */.0,C
   \   00000C   FD           MOV     R5,A
   \   00000D   C2AF         CLR     0xa8.7
    975                events = tasksEvents[idx];
   \   00000F   E5..         MOV     A,?V0 + 0
   \   000011   C3           CLR     C
   \   000012   33           RLC     A
   \   000013   FE           MOV     R6,A
   \   000014   E4           CLR     A
   \   000015   33           RLC     A
   \   000016   FF           MOV     R7,A
   \   000017   90....       MOV     DPTR,#tasksEvents
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   2E           ADD     A,R6
   \   00001C   F8           MOV     R0,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   3F           ADDC    A,R7
   \   000020   F9           MOV     R1,A
   \   000021   12....       LCALL   ?Subroutine8 & 0xFFFF
    976                tasksEvents[idx] = 0;  // Clear the Events for this task.
   \                     ??CrossCallReturnLabel_25:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
    977                HAL_EXIT_CRITICAL_SECTION(intState);
   \   00002C   ED           MOV     A,R5
   \   00002D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002F   92AF         MOV     0xa8.7,C
    978          
    979                events = (tasksArr[idx])( idx, events );
   \   000031                ; Setup parameters for indirect call
   \   000031   A9..         MOV     R1,?V0 + 0
   \   000033   EE           MOV     A,R6
   \   000034   24..         ADD     A,#(tasksArr & 0xff)
   \   000036   F582         MOV     DPL,A
   \   000038   EF           MOV     A,R7
   \   000039   34..         ADDC    A,#((tasksArr >> 8) & 0xff)
   \   00003B   F583         MOV     DPH,A
   \   00003D   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000040   12....       LCALL   ?CALL_IND
    980          
    981                    HAL_ENTER_CRITICAL_SECTION(intState);
   \   000043   A2AF         MOV     C,0xa8.7
   \   000045   E4           CLR     A
   \   000046   92E0         MOV     0xE0 /* A   */.0,C
   \   000048   FD           MOV     R5,A
   \   000049   C2AF         CLR     0xa8.7
    982                tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   00004B   90....       MOV     DPTR,#tasksEvents
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   2E           ADD     A,R6
   \   000050   FC           MOV     R4,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   3F           ADDC    A,R7
   \   000054   12....       LCALL   ?Subroutine4 & 0xFFFF
    983                    HAL_EXIT_CRITICAL_SECTION(intState);
    984          #if defined( POWER_SAVING )
    985                    halWait(20);
   \                     ??CrossCallReturnLabel_46:
   \   000057                ; Setup parameters for call to function halWait
   \   000057   7914         MOV     R1,#0x14
   \   000059   12....       LCALL   ??halWait?relay
    986          #endif
    987                }
   \                     ??osal_start_system_0:
   \   00005C   75..00       MOV     ?V0 + 0,#0x0
   \   00005F                ; Setup parameters for call to function Hal_ProcessPoll
   \   00005F   12....       LCALL   ??Hal_ProcessPoll?relay
   \                     ??osal_start_system_2:
   \   000062   E5..         MOV     A,?V0 + 0
   \   000064   C3           CLR     C
   \   000065   33           RLC     A
   \   000066   F8           MOV     R0,A
   \   000067   E4           CLR     A
   \   000068   33           RLC     A
   \   000069   F9           MOV     R1,A
   \   00006A   90....       MOV     DPTR,#tasksEvents
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   28           ADD     A,R0
   \   00006F   FA           MOV     R2,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   39           ADDC    A,R1
   \   000073   8A82         MOV     DPL,R2
   \   000075   F583         MOV     DPH,A
   \   000077   E0           MOVX    A,@DPTR
   \   000078   7002         JNZ     ??osal_start_system_3
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \                     ??osal_start_system_3:
   \   00007C   700D         JNZ     ??osal_start_system_4
   \   00007E   05..         INC     ?V0 + 0
   \   000080   90....       MOV     DPTR,#tasksCnt
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   E5..         MOV     A,?V0 + 0
   \   000087   C3           CLR     C
   \   000088   9A           SUBB    A,R2
   \   000089   40D7         JC      ??osal_start_system_2
   \                     ??osal_start_system_4:
   \   00008B   90....       MOV     DPTR,#tasksCnt
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   FA           MOV     R2,A
   \   000090   E5..         MOV     A,?V0 + 0
   \   000092   C3           CLR     C
   \   000093   9A           SUBB    A,R2
   \   000094   5003         JNC     $+5
   \   000096   02....       LJMP    ??osal_start_system_1 & 0xFFFF
    988          #if defined( POWER_SAVING )
    989              else  // Complete pass through all task events with no activity?
    990              {
    991                  P2_0=0;
   \   000099   C2A0         CLR     0xa0.0
    992                 
    993                osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
   \   00009B                ; Setup parameters for call to function osal_pwrmgr_powerconserve
   \   00009B   12....       LCALL   ??osal_pwrmgr_powerconserve?relay
   \   00009E   80BC         SJMP    ??osal_start_system_0
   \   0000A0                REQUIRE _A_P2
   \   0000A0                REQUIRE _A_IEN0
    994              }
    995          #endif
    996             // P0.1=1;
    997              }
    998          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "0">>`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_2710>`:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_5f5e100>`:
   \   000000   00E1F505     DD 100000000

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_strlen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_strlen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_cpyExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_cpyExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_ltoa?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _ltoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_AddrEqual?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_AddrEqual

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_ExtAddrEqual?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_ExtAddrEqual

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_rand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_allocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_allocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_deallocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_deallocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_send

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_receive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_dequeue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_dequeue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_push?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_extract?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_extract

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue_max?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_max

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_set_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_isr_register?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isr_register

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_disable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_disable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_init_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_init_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_start_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_system

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     `?<Constant "">_1`:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     `?<Constant "">_2`:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "0">`:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for <Constant "0">>`
   \   000002                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_2710:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_2710>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_5f5e100:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_5f5e100>`
   \   000004                REQUIRE __INIT_XDATA_I
    999          
   1000          /*********************************************************************
   1001          *********************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     _ltoa                              2      0     54
       -> _itoa                         0      0    104
       -> _itoa                         0      0    104
       -> _itoa                         0      0    104
       -> strcpy                        0      0    104
       -> strcat                        0      0    104
       -> strlen                        0      0    104
       -> strcat                        0      0    104
       -> strcat                        0      0    104
       -> strlen                        0      0    104
       -> strcat                        0      0    104
       -> strcpy                        0      0    104
       -> _itoa                         0      0    104
       -> _itoa                         0      0    104
       -> strcpy                        0      0    104
       -> strcat                        0      0    104
       -> strlen                        0      0    104
       -> strcat                        0      0    104
     osal_AddrEqual                     0      0      9
       -> osal_ExtAddrEqual             0      0     18
     osal_ExtAddrEqual                  0      0     19
     osal_build_uint16                  0      0      9
     osal_build_uint32                  0      0     16
     osal_cpyExtAddr                    0      0     14
       -> osal_memcpy                   0      0     28
     osal_init_system                   2      0      0
       -> osal_mem_init                 4      0      0
       -> osalTimerInit                 4      0      0
       -> osal_pwrmgr_init              4      0      0
       -> osalInitTasks                 4      0      0
       -> osal_mem_kick                 4      0      0
     osal_int_disable                   0      0      0
     osal_int_enable                    0      0      0
     osal_isr_register                  0      0      0
     osal_memcpy                        1      0     25
     osal_memset                        0      0     12
       -> memset                        0      0     24
     osal_msg_allocate                  1      0     10
       -> osal_mem_alloc                0      0     20
     osal_msg_deallocate                2      0      9
       -> osal_mem_free                 4      0      0
     osal_msg_dequeue                   1      0     10
     osal_msg_enqueue                   0      0     18
     osal_msg_enqueue_max               0      0     10
     osal_msg_extract                   1      0     23
     osal_msg_push                      0      0      9
     osal_msg_receive                   0      0     14
       -> osal_msg_extract              0      0     28
     osal_msg_send                      1      0      9
       -> osal_msg_deallocate           0      0     18
       -> osal_msg_deallocate           0      0     18
       -> osal_msg_enqueue              0      0     18
       -> osal_set_event                0      0     18
     osal_rand                          2      0      0
       -> Onboard_rand                  4      0      0
     osal_set_event                     3      0      9
     osal_start_system                  1      0     10
       -> halWait                       0      0     20
       -> Hal_ProcessPoll               0      0     20
       -> osal_pwrmgr_powerconserve     0      0     20
     osal_strlen                        2      0      0
       -> strlen                        4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P2                             1
     _A_IEN0                           1
     osal_qHead                        2
     osal_strlen                      10
     ?Subroutine19                     7
     osal_memcpy                      69
     ?Subroutine20                     5
     osal_cpyExtAddr                  31
     osal_memset                      29
     ?Subroutine21                     5
     osal_build_uint16                21
     ?Subroutine23                     5
     osal_build_uint32               128
     ?Subroutine24                     5
     ?Subroutine9                     15
     ?Subroutine1                      6
     ?Subroutine16                    28
     _ltoa                           634
     ?Subroutine7                     17
     ?Subroutine6                      6
     ?Subroutine5                     10
     ?Subroutine2                      6
     ?Subroutine17                     7
     ?Subroutine0                     28
     ?Subroutine8                      8
     ?Subroutine18                     6
     ?Subroutine10                     9
     osal_AddrEqual                  103
     ?Subroutine3                      6
     osal_ExtAddrEqual                62
     osal_rand                        10
     osal_msg_allocate                83
     osal_msg_deallocate              38
     ?Subroutine13                    12
     osal_msg_send                    82
     osal_msg_receive                117
     osal_msg_enqueue                 54
     ?Subroutine22                     6
     ?Subroutine11                    13
     ?Subroutine14                     6
     ?Subroutine26                     5
     osal_msg_dequeue                 90
     ?Subroutine15                     9
     ?Subroutine25                     5
     osal_msg_push                    48
     ?Subroutine12                     8
     osal_msg_extract                 88
     osal_msg_enqueue_max             84
     osal_set_event                   50
     ?Subroutine4                     15
     osal_isr_register                 5
     osal_int_enable                  16
     osal_int_disable                 16
     osal_init_system                 31
     osal_start_system               160
     ?<Initializer for <Constant "0">>
                                       2
     ?<Initializer for __Constant_2710>
                                       4
     ?<Initializer for __Constant_5f5e100>
                                       4
     ??osal_strlen?relay               6
     ??osal_memcpy?relay               6
     ??osal_cpyExtAddr?relay           6
     ??osal_memset?relay               6
     ??osal_build_uint16?relay         6
     ??osal_build_uint32?relay         6
     ??_ltoa?relay                     6
     ??osal_AddrEqual?relay            6
     ??osal_ExtAddrEqual?relay         6
     ??osal_rand?relay                 6
     ??osal_msg_allocate?relay         6
     ??osal_msg_deallocate?relay       6
     ??osal_msg_send?relay             6
     ??osal_msg_receive?relay          6
     ??osal_msg_enqueue?relay          6
     ??osal_msg_dequeue?relay          6
     ??osal_msg_push?relay             6
     ??osal_msg_extract?relay          6
     ??osal_msg_enqueue_max?relay      6
     ??osal_set_event?relay            6
     ??osal_isr_register?relay         6
     ??osal_int_enable?relay           6
     ??osal_int_disable?relay          6
     ??osal_init_system?relay          6
     ??osal_start_system?relay         6
     ?<Constant "">                   10
     ?<Constant "">_1                 10
     ?<Constant "">_2                 10
     ?<Constant "0">                   2
     __Constant_2710                   4
     __Constant_5f5e100                4

 
 2 317 bytes in segment BANKED_CODE
   150 bytes in segment BANK_RELAYS
     2 bytes in segment SFR_AN
    10 bytes in segment XDATA_I
    10 bytes in segment XDATA_ID
    32 bytes in segment XDATA_Z
 
 2 469 bytes of CODE  memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 2 bytes shared)
    34 bytes of XDATA memory (+ 8 bytes shared)

Errors: none
Warnings: none
