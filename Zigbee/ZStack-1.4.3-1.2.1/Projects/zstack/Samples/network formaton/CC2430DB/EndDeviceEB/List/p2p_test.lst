###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    20/Oct/2014  18:58:35 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\8-22\0最新有用\修改中2013.8.12Texas             #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\Source\p2p_test.c                         #
#    Command line       =  -f "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wEndev #
#                          .cfg" (-DCPU32MHZ -DFORCE_MAC_NEAR                 #
#                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS    #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfi #
#                          g.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800   #
#                          -DZDAPP_CONFIG_PAN_ID=0x1234                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=30            #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=10000       #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\8-22\0最新有用\修改中20 #
#                          13.8.12Texas Instruments                           #
#                          longmenshan\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\network formaton\Source\p2p_test.c" -D        #
#                          CC2430EB -D NWK_AUTO_POLL -D REFLECTOR -D          #
#                          ZTOOL_P1 -D MT_TASK -D MT_ZDO -D                   #
#                          xLCD_SUPPORTED=DEBUG -D POWER_SAVING -lC           #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\List\" -lA           #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\List\"               #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\Obj\" -e             #
#                          --require_prototypes -z9 --no_code_motion --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network formaton\CC2430DB\" -I    #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\SOURCE\" -I                   #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I     #
#                          "C:\8-22\0最新有用\修改中2013.8.12Texas            #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MT\"   #
#                          -I "C:\8-22\0最新有用\修改中2013.8.12Texas         #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\IN #
#                          CLUDE\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas #
#                           Instruments longmenshan\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\network                          #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\TA #
#                          RGET\CC2430EB\" -I "C:\8-22\0最新有用\修改中2013.8 #
#                          .12Texas Instruments longmenshan\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\network                  #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\M #
#                          CU\CCSOC\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\I #
#                          NCLUDE\" -I "C:\8-22\0最新有用\修改中2013.8.12Texa #
#                          s Instruments longmenshan\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          AF\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas    #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          NWK\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SEC\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SYS\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          ZDO\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas   #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\F #
#                          8W\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas    #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\" #
#                           -I "C:\8-22\0最新有用\修改中2013.8.12Texas        #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SADDR\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SDATA\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\IN #
#                          CLUDE\" -I "C:\8-22\0最新有用\修改中2013.8.12Texas #
#                           Instruments longmenshan\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\network                          #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\HI #
#                          GH_LEVEL\" -I "C:\8-22\0最新有用\修改中2013.8.12Te #
#                          xas Instruments longmenshan\ZStack-1.4.3-1.2.1\Pro #
#                          jects\zstack\Samples\network                       #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\" -I "C:\8-22\0最新有用\修改中2013.8 #
#                          .12Texas Instruments longmenshan\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\network                  #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\SINGLE_CHIP\" -I "D:\XP的D\Program   #
#                          file\IAR\8051\INC\" -I "D:\XP的D\Program           #
#                          file\IAR\8051\INC\CLIB\"                           #
#    List file          =  C:\8-22\0最新有用\修改中2013.8.12Texas             #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\List\p2p_test.lst    #
#    Object file        =  C:\8-22\0最新有用\修改中2013.8.12Texas             #
#                          Instruments longmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\network                           #
#                          formaton\CC2430DB\EndDeviceEB\Obj\p2p_test.r51     #
#                                                                             #
#                                                                             #
###############################################################################

C:\8-22\0最新有用\修改中2013.8.12Texas Instruments longmenshan\ZStack-1.4.3-1.2.1\Projects\zstack\Samples\network formaton\Source\p2p_test.c
      1          //本版本在已有的功能上添加了水位计和土壤湿度传感器的终端节点自适应周期调整定时休眠机制 2013.7.15
      2          //且添加了不同水位计数据类型的获取情形（2013.7.17）
      3          //且添加了水位计临时断电的情形（2013.7.17）
      4          //将水位计默认类型改为3，接近实际应用，将区间间隔改为变量，可作为设置报文参数（2013.7.23）
      5          //解决多次收到关联ack影响数据采集时间的bug(2013.7.24)
      6          //p1_1作为水位计的电源控制开关（2013.7.28）
      7          //修改NWK_INDIRECT_MSG_TIMEOUT = 30   和POLL_RATE=10000（2013.7.28） 
      8          //增加zigbee节点重启后的设置报文和水位计关闭门限（2013.7.31） 
      9          //添加 项目验收关闭水位计，平时不关闭水位计（2013.8.13）
     10          //稳定测试（100h），已不存在/*长时间可能不稳定，一段时间后普通节点等待重新关联*/问题（2013.8.25）
     11          //按项目实际需求精简代码（2013.9.4）
     12          //添加看门狗自动启动（2013.9.4） 最后修改于2013.10.8
     13          //原来的看门狗不对，已经改正，正常运行（2013.10.28）
     14          //修改服务器下行设置报文和关联报文ACK，由广播改为单播。（2013.11.10）
     15          //添加普通节点和PAN节点的重启设置命令（2014.1.15）
     16          //修改PAN收到关联报文后释放动态内存的位置（2014.4.3）
     17          //将设置报文PAN转发时改为广播，以便适合多终端节点（2014.7.3）
     18          /**************************************************************************************************
     19            Filename:       p2p_test.c
     20            Revised:        $Date: 2007-10-27 17:16:54 -0700 (Sat, 27 Oct 2007) $
     21            Revision:       $Revision: 15793 $
     22          
     23            Description:    Generic Application (no Profile).
     24          
     25          
     26            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     27          
     28            IMPORTANT: Your use of this Software is limited to those specific rights
     29            granted under the terms of a software license agreement between the user
     30            who downloaded the software, his/her employer (which must be your employer)
     31            and Texas Instruments Incorporated (the "License").  You may not use this
     32            Software unless you agree to abide by the terms of the License. The License
     33            limits your use, and you acknowledge, that the Software may not be modified,
     34            copied or distributed unless embedded on a Texas Instruments microcontroller
     35            or used solely and exclusively in conjunction with a Texas Instruments radio
     36            frequency transceiver, which is integrated into your product.  Other than for
     37            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     38            works of, modify, distribute, perform, display or sell this Software and/or
     39            its documentation for any purpose.
     40          
     41            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     42            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     43            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     44            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     45            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     46            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     47            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     48            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     49            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     50            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     51            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     52          
     53            Should you have any questions regarding your right to use this Software,
     54            contact Texas Instruments Incorporated at www.TI.com.
     55          **************************************************************************************************/
     56          
     57          /*********************************************************************
     58            This application isn't intended to do anything useful, it is
     59            intended to be a simple example of an application's structure.
     60          
     61            This application sends "Hello World" to another "Generic"
     62            application every 15 seconds.  The application will also
     63            receive "Hello World" packets.
     64          
     65            The "Hello World" messages are sent/received as MSG type message.
     66          
     67            This applications doesn't have a profile, so it handles everything
     68            directly - itself.
     69          
     70            Key control:
     71              SW1:
     72              SW2:  initiates end device binding
     73              SW3:
     74              SW4:  initiates a match description request
     75          *********************************************************************/
     76          
     77          /*********************************************************************
     78           * INCLUDES
     79           */
     80          
     81          #include "OSAL.h"
     82          #include "AF.h"
     83          #include "ZDApp.h"
     84          #include "ZDObject.h"
     85          #include "ZDProfile.h"
     86          
     87          #include "p2p_test.h"
     88          #include "DebugTrace.h"
     89          
     90          #include "SPIMgr.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCON
   \                     CLKCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     91          #include <string.h>
     92          
     93          #if !defined( WIN32 )
     94            #include "OnBoard.h"
     95          #endif
     96          
     97          /* HAL */
     98          #include "hal_lcd.h"
     99          #include "hal_led.h"
    100          #include "hal_key.h"
    101          #include "hal_uart.h"
    102          //#include "Hal_Sensor.h"  
    103          #include "Hal_defs.h"
    104          #include "hal_adc.h"
    105          
    106          /*********************************************************************
    107           * MACROS
    108           */
    109          //zyq add
    110          #define ADDFLAG16(a,Byte) ((uint16)(a|(0x0001<<(Byte-1))))
    111          #define TYPE_SENSOR 0x00
    112          #define TYPE_COMMAND 0x08
    113          #define TYPE_MAINTAIN 0x01
    114          #define TYPE_ACK 0x0f
    115          
    116          
    117          #define TYPE_REPORT 0x02
    118          #define TYPE_QUARY 0x09
    119          #define TYPE_ACK_UP 0x00
    120          
    121          //RelationMsg up or down link typecode
    122          #define RELATION_MSG_UP 0x01
    123          #define RELATION_MSG_DOWN 0x01
    124          //#define TYPE_CODE_SENSOR_ILLUMINATION 0X01
    125          //#define TYPE_CODE_SENSOR_TEMPERATURE 0X02
    126          #define TYPE_CODE_SENSOR_RAIN 0x01
    127          #define TYPE_CODE_SENSOR_SOIL_HUMIDITY 0X02
    128          #define TYPE_CODE_SENSOR_WATER_GAGE 0x03
    129          #define TYPE_CODE_SENSOR_ACCELEROMETER 0x04
    130          #define TYPE_CODE_SENSOR_PORE_PRESSURE 0x05
    131          #define TYPE_CODE_SENSOR_READ_VCC 0X07
    132          
    133          //define sensor's ID
    134          #define RAIN_ID 0x01
    135          #define SOIL_ID 0x02
    136          #define WATER_GAGE_ID 0x03
    137          #define EARTHQUAKE_ID 0x04
    138          #define PORE_ID 0x05
    139          
    140          //define that zigbee have the sensor or not
    141          #define RAIN_FLAG 0x00
    142          #define SOIL_FLAG 0x00
    143          #define WATER_GAGE_FLAG 0x01
    144          #define EARTHQUAKE_FLAG 0x00
    145          #define PORE_FLAG 0x00
    146          #define MAX_ID 8
    147          
    148          #define COMMAND_TYPE_RAIN 1    //雨量K值
    149          #define COMMAND_TYPE_SOIL_HUMIDITY 2  //土壤湿度K值
    150          #define COMMAND_TYPE_WATER_GAGE 3   //水位K值
    151          #define COMMAND_TYPE_VIBRATIO 4   //振动K值
    152          #define COMMAND_TYPE_PORE_PRESS 5  //孔压K值
    153          #define COMMAND_TYPE_RAIN_KVALUE 6   //雨量N值
    154          #define COMMAND_TYPE_WATER_HIGHTYPE 7  //水位空高类型
    155          #define COMMAND_TYPE_HELLO 8//Hello频率
    156          #define COMMAND_TYPE_WATER_T 9 //水位计自适应采集周期增加间隔T取值
    157          #define COMMAND_TYPE_WATER_EDGE_A 10 //水位计自适应边界取值A
    158          #define COMMAND_TYPE_WATER_EDGE_B 11 //水位计自适应边界取值B
    159          #define COMMAND_TYPE_WATER_EDGE_C 12 //水位计自适应边界取值C
    160          #define COMMAND_TYPE_ZIGBEE_RESTART 13 //zigbee重启的设置
    161          #define COMMAND_TYPE_ACCEPTANCE 14     //项目验收
    162          #define COMMAND_TYPE_ZIGBEE_RESTART_COMMAND 0x11     //zigbee重启命令
    163          
    164          //全部未用到
    165          /*
    166          #define TYPE_CODE_COMMAND_MODIFY_K 0x00
    167          #define TYPE_CODE_COMMAND_MODIFY_N 0x01
    168          #define TYPE_CODE_COMMAND_REQUIRE 0x02
    169          #define TYPE_CODE_COMMAND_SENSOR_STOP_EVT 0x03
    170          #define TYPE_CODE_MAINTAIN_RELATION 0x01
    171          #define TYPE_CODE_MAINTAIN_RESET_TIME 0x06
    172          */
    173          
    174          //define wate gage information type
    175          #define Station_Num 0x01
    176          #define Water_Func_Code 0x03
    177          #define First_Addr0 0x0000
    178          #define First_Addr1 0x0001
    179          #define First_Addr2 0x0002
    180          #define First_Addr3 0x0003
    181          #define Water_num 0x0002
    182          #define Default_Water_Gage First_Addr3
    183          
    184          //define soil type for select formula(未使用)  
    185          /*
    186          #define  Clay_Soil  0x00
    187          #define  Loam_Soil  0x01
    188          #define  Sand_Soil  0x02
    189          */
    190          
    191          #define MAIN_VERSION 0x00
    192          #define SUB_VERSION 0x01
    193          
    194          #define FREQ 0x00
    195          #define REQUIRE 0x01
    196          
    197          #define ACK_YES 0x01
    198          #define ACK_NO 0x00
    199          
    200          
    201          #define DEBUG 1
    202          
    203          //static uint16 SerialNumber;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          static uint8 RES;
   \                     RES:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    205          static uint8 ARM_ID;
   \                     ARM_ID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          static uint8 Zigbee_ID;
   \                     Zigbee_ID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          typedef struct
    208          {
    209            uint8 type : 4;
    210            uint8 SubVersion : 1;
    211            uint8 MainVersion : 2;
    212            uint8 AckRequire : 1;
    213            uint8 TypeCode;
    214            uint8 sn[2];    //serial number
    215          } AppHead_t;
    216          
    217          typedef struct
    218          {
    219            uint8 ARM_id :4;
    220            uint8 r : 4;
    221            uint8 sensor_type:4;
    222            uint8 Zigbee_id :4;
    223          } NodeId_t;
    224          
    225          typedef struct
    226          {
    227            uint8 time[4]; 
    228            NodeId_t NodeId;  
    229          } NodeIdAndTime_t;
    230          
    231          typedef struct
    232          {
    233            AppHead_t AppHead;
    234            NodeIdAndTime_t NodeIdAndTime;
    235            uint8 count[2];
    236          } RainMsg_t;
    237          
    238          typedef struct
    239          {
    240            AppHead_t AppHead;
    241            NodeIdAndTime_t NodeIdAndTime;
    242            uint8 AdcVcc[2];
    243            uint8 AdcValue[2];
    244           // float SoilValue;
    245          } Soil_Humidity_t;
    246          
    247          typedef struct
    248          {
    249            AppHead_t AppHead;
    250            NodeIdAndTime_t NodeIdAndTime;
    251            uint8 AdcVcc[2];
    252            uint8 AdcValue[2];
    253           // float Accelevalue;
    254          } Accelerometer_t;
    255          
    256          typedef struct
    257          {
    258            AppHead_t AppHead;
    259            NodeIdAndTime_t NodeIdAndTime;
    260            uint8 AdcVcc[2];
    261          } Vccvalue_t;
    262          
    263          typedef struct
    264          {
    265            AppHead_t AppHead;
    266            NodeIdAndTime_t NodeIdAndTime;
    267          } ResetTimeMsg_t;
    268          
    269          typedef struct
    270          {
    271            AppHead_t AppHead;
    272            uint8 Num[2];
    273            NodeId_t NodeId[MAX_ID];
    274          } RelationMsg_t;  
    275          
    276          typedef struct
    277          {
    278            AppHead_t AppHead;
    279            NodeId_t NodeId;
    280          } AppHeadNodeId_t;
    281          
    282          typedef struct
    283          {
    284            uint8 head[2];
    285            uint8 len;
    286          } UartHeadMsg_t;
    287          
    288          //water gage information
    289          typedef struct
    290          {
    291            AppHead_t AppHead;
    292            NodeIdAndTime_t NodeIdAndTime;
    293            // uint8 water_gage_type[2];
    294            uint8 water_gage_value[2];  
    295          }Water_Gage_t;
    296          
    297          typedef struct
    298          {
    299             uint8 station_number;
    300             uint8 func_code;
    301             uint8 first_addr[2];
    302             uint8 read_num[2];
    303             uint8 crc[2];
    304          }Water_Send_Infor_t;
    305          
    306          typedef struct
    307          {
    308             uint8 station_number;
    309             uint8 func_code;
    310             uint8 read_byte_num;
    311             uint8 data[8];
    312             uint8 crc[8];
    313          }Water_read_Infor_t;
    314          
    315           struct RelationMap_t 
    316          {
    317            uint16 addr16;
    318            uint8 Zigbee_id;
    319            struct RelationMap_t *next;
    320          } ;
    321          
    322          typedef struct
    323          {
    324             AppHead_t AppHead;
    325             NodeId_t Src_NodeId;
    326          } AckUP_t;
    327          
    328          //自己编写
    329          
    330          
    331          //保存最近三次数据
    332          typedef struct
    333          { 
    334            uint16 data[3];
    335            uint32 time[3];
    336          }Watergage_data_and_time;
    337          
    338          
    339          typedef struct
    340          { 
    341            float data[3];
    342            uint32 time[3];
    343          }Soilhumidity_data_and_time;
    344          
    345          
    346          typedef struct
    347          {
    348            AppHead_t AppHead;
    349            NodeId_t NodeId;
    350            uint8 command_type;
    351            uint16 water_gage_type;      //COMMAND_TYPE_WATER_HIGHTYPE
    352            uint16 water_gage_freq;      //COMMAND_TYPE_WATER_GAGE
    353            uint16 water_gage_T;         //COMMAND_TYPE_WATER_T
    354            uint8  water_gage_A;         //COMMAND_TYPE_WATER_EDGE_A
    355            uint8  water_gage_B;         //COMMAND_TYPE_WATER_EDGE_B  
    356            uint8  water_gage_C;         //COMMAND_TYPE_WATER_EDGE_C  
    357          }Zigbee_Restart_Command_t;
    358          
    359          //上次预测值和本次数据实际值的差值

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    360          static uint16 Water_gage_err;
   \                     Water_gage_err:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    361          //static float Soil_humidity_err;
    362          
    363          //传感器自己的序列号

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    364          static uint16 Water_gage_SerialNumber;
   \                     Water_gage_SerialNumber:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    365          //static uint16 Soil_humidity_SerialNumber;
    366          
    367          //自适应休眠周期的调整间隔（专利中的T）

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    368          uint16 Water_gage_time ;   
   \                     Water_gage_time:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    369          //uint16 Soil_humidity_time ; 
    370          
    371          //将时间改为静态的

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    372          static uint32 now;
   \                     now:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    373          
    374          //传感器的预测值

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    375          static uint16 Water_gage_forValue;
   \                     Water_gage_forValue:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    376          //static float Soil_humidity_forValue;
    377          
    378          //定义一个具体的data_and_time变量

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    379          Watergage_data_and_time  Water_Gage_data_and_time;
   \                     Water_Gage_data_and_time:
   \   000000                DS 18
   \   000012                REQUIRE __INIT_XDATA_Z
    380          //Soilhumidity_data_and_time  Soil_humidity_data_and_time;
    381          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    382          static uint8 no_charge_flag; 
   \                     no_charge_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    383          static uint8 water_gage_on;
   \                     water_gage_on:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    384          uint16 CheckWaterGageChargeTimeFreq;
   \                     CheckWaterGageChargeTimeFreq:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    385          
    386          //区间边界值(水位计起始地址为0003，水位值，mm)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    387          static uint8 Water_gage_err_a  ;
   \                     Water_gage_err_a:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    388          static uint8 Water_gage_err_b  ;
   \                     Water_gage_err_b:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    389          static uint8 Water_gage_err_c  ;
   \                     Water_gage_err_c:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    390          
    391          /*
    392          #define Soil_humidity_err_a  0.1  //0.1V
    393          #define Soil_humidity_err_b  0.5  //0.5V
    394          #define Soil_humidity_err_c  1.0  //1.0V
    395          */
    396          
    397          //水位计量程
    398          #define Water_gage_data_span 30000
    399          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    400          static uint8 relation_done ;
   \                     relation_done:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    401          
    402          //项目验收  （非验收不关闭水位计，减少继电器拨片损耗）

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    403          static uint8 acceptance;
   \                     acceptance:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    404          /*********************************************************************
    405           * CONSTANTS
    406           */
    407          #define CLKSPD  ( CLKCON & 0x01 )
    408          #define DATA P1_1
    409          #define SCK P1_0
    410          
    411          // This list should be filled with Application specific Cluster IDs.
    412          /*********************************************************************
    413           * TYPEDEFS
    414           */
    415          
    416          /*********************************************************************
    417           * GLOBAL VARIABLES
    418           */
    419          
    420          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    421          const cId_t p2p_test_ClusterList[p2p_test_MAX_CLUSTERS] =
   \                     p2p_test_ClusterList:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for p2p_test_ClusterList>`
   \   000006                REQUIRE __INIT_XDATA_I
    422          {
    423            p2p_test_CLUSTERID,
    424            p2p_test_108ID,
    425            p2p_test_RelationMsg,
    426            //fire_extinguisher_clusterId
    427          };
    428          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    429          const SimpleDescriptionFormat_t p2p_test_SimpleDesc =
   \                     p2p_test_SimpleDesc:
   \   000000                DS 12
   \   00000C                REQUIRE `?<Initializer for p2p_test_SimpleDesc>`
   \   00000C                REQUIRE __INIT_XDATA_I
    430          {
    431            p2p_test_ENDPOINT,              //  int Endpoint;
    432            p2p_test_PROFID,                //  uint16 AppProfId[2];
    433            p2p_test_DEVICEID,              //  uint16 AppDeviceId[2];
    434            p2p_test_DEVICE_VERSION,        //  int   AppDevVer:4;
    435            p2p_test_FLAGS,                 //  int   AppFlags:4;
    436            p2p_test_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    437            (cId_t *)p2p_test_ClusterList,  //  byte *pAppInClusterList;
    438            p2p_test_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    439            (cId_t *)p2p_test_ClusterList   //  byte *pAppInClusterList;
    440          };
    441          
    442          // This is the Endpoint/Interface description.  It is defined here, but
    443          // filled-in in p2p_test_Init().  Another way to go would be to fill
    444          // in the structure here and make it a "const" (in code space).  The
    445          // way it's defined in this sample app it is define in RAM.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    446          endPointDesc_t p2p_test_epDesc;
   \                     p2p_test_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    447          
    448          /*********************************************************************
    449           * EXTERNAL VARIABLES
    450           */
    451          
    452          /*********************************************************************
    453           * EXTERNAL FUNCTIONS
    454           */
    455          
    456          /*********************************************************************
    457           * LOCAL VARIABLES
    458           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    459          byte p2p_test_TaskID;   // Task ID for internal task/event processing
   \                     p2p_test_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    460                                    // This variable will be received when
    461                                    // p2p_test_Init() is called.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    462          devStates_t p2p_test_NwkState;
   \                     p2p_test_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    463          
    464          
    465          byte p2p_test_TransID;  // This is the unique message ID (counter)
    466          
    467          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    468          byte p2p_test_TransID;  // This is the unique message ID (counter)
   \                     p2p_test_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    469          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    470          afAddrType_t p2p_test_DstAddr;
   \                     p2p_test_DstAddr:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    471          afAddrType_t p2p_test_EnddeviceAddr;//add by yd 终端节点的短地址
   \                     p2p_test_EnddeviceAddr:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    472            //uint8 p2p_msg[6];//the collect message

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    473           uint16 shortaddr;
   \                     shortaddr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    474           uint16 fatheraddr;
   \                     fatheraddr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    475           
    476          //zyq add
    477          /*
    478          static uint8 SendRainCountFreq; //wait SendRainCountFreq send to PAN
    479          static uint16 SendRainTimeFreq; //every SendRainTimeFreq minute send rain msg
    480          static uint32 SendRainRemainTime;//unit second
    481          static uint8 RainCountNum;
    482          
    483          static uint16 SendSoilHumidityTimeFreq;
    484          static uint32 SendSoilHumidityRemainTime;
    485          
    486          static uint16 SendAccelerometerTimeFreq;
    487          static uint32 SendAccelerometerRemainTime;
    488          
    489           
    490          static uint16 SendVccValueTimeFreq;
    491          static uint32 SendVccValueRemainTime;
    492          */
    493           

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    494          static uint16 SendWaterGageTimeFreq;
   \                     SendWaterGageTimeFreq:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    495          static uint16 SendWaterGageRemainTime;
   \                     SendWaterGageRemainTime:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    496          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    497          static uint16 WaterGageUnit;
   \                     WaterGageUnit:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    498          //static uint8 SOIL_TYPE ;
    499          
    500          //static uint8 SoilHumidityFlag ;
    501          //static uint8 RainFlag ;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    502          static uint8 WaterGageFlag;
   \                     WaterGageFlag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    503          static struct RelationMap_t *Head_Map=NULL;
   \                     Head_Map:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    504          static struct RelationMap_t *Tail_Map=NULL;
   \                     Tail_Map:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    505          static uint16 FlagMap;
   \                     FlagMap:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    506          
    507          
    508          
    509          
    510          /*********************************************************************
    511           * LOCAL FUNCTIONS
    512           */
    513          void p2p_test_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    514          //void p2p_test_HandleKeys( byte shift, byte keys );
    515          void p2p_test_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    516          //void p2p_test_SendTheMessage( void );
    517          
    518          //zyq add
    519          void p2p_test_recv_108clusterId(uint8 *pkt, uint8 length);
    520          void p2p_test_recv_RelationMsgclusterId(uint8 *pkt,uint8 length,uint16 srcaddr);
    521          
    522          void p2p_test_RecvFromUart(uint8 *Msg);
    523          void p2p_test_SendToUart(uint8 *Data, uint8 DataLength);
    524          
    525          void fill_AppHead(AppHead_t *AppHead, uint8 AckRequire, uint8 MainVersion, uint8 SubVersion, uint8 type, uint8 TypeCode);
    526          void fill_AppHead_sn(AppHead_t *AppHead, uint8 AckRequire, uint8 MainVersion, uint8 SubVersion, uint8 type, uint8 TypeCode,uint16 SerialNumber);
    527          void fill_NodeId_time(NodeIdAndTime_t *NodeIdAndTime,uint8 ARM_Id,uint8 Zigbee_id,uint8 sensor_type);
    528          void SendMsg(uint8 *msg, uint8 MsgSize, afAddrType_t Dst, uint8 options,uint16 cID);
    529          
    530          //void p2p_test_SendResetRelativeTime( void );//未用到
    531          void p2p_test_SendRelationPkt( void );
    532          
    533          
    534          void p2p_test_interrupt_rain(uint16 count);
    535          void p2p_test_SendRainTimeFreqAndRequire( uint8 FreqOrRequire );
    536          void p2p_test_SendSoilHumidityTimeFreqAndRequire( uint8 FreqOrRequire );
    537          void p2p_test_SendAccelerometerTimeFreqAndRequire(uint8 FreqOrRequire);
    538          
    539          void p2p_test_Send_VCC_VALUE(uint8 FreqOrRequire);
    540          void p2p_test_Send_Water_Gage(uint8 FreqOrRequire,uint16 watergagetype);
    541          void crc_water_gage(Water_Send_Infor_t * temp);
    542          //unsigned short Read_SHT_TEMP_digital_sensor(void);
    543          //unsigned short Read_SHT_HUMI_digital_sensor(void);
    544          
    545          void p2p_test_StartDataSensorTimer(void);
    546          extern uint8 halWait(unsigned char wait);
    547          void insert_RelationMap(struct RelationMap_t *map,uint16 addr,uint8 zigbee_id);
    548          uint8 search_RelationMap(uint16 addr);
    549          
    550          //void READ_TEST( afIncomingMSGPacket_t *MSGpkt );
    551          
    552          //自己编写
    553          
    554          //函数声明
    555          uint16 Water_gage_forecastValue(Watergage_data_and_time);
    556          float Soil_humidity_forecastValue(Soilhumidity_data_and_time);
    557          void HalUARTWrite_uint16(uint16);
    558          void start_Water_gage_timer(void);
    559          void start_Soil_humidity_timer(void);
    560          float Soil_humidity_DtoA(uint16,uint16);
    561          void check_water_gage_charge(void);
    562          #if defined(RTR_NWK)
    563          void print_AssociatedDevList(void);
    564          #endif
    565          
    566          #if defined(RTR_NWK)
    567          void print_AssociatedDevList()
    568          {
    569            uint8 one_end =0xAB;
    570            for(uint8 x=0;x<NWK_MAX_DEVICES;x++)
    571            {
    572              if(AssociatedDevList[x].shortAddr !=0xFFFF)
    573              {
    574              HalUARTWrite_uint16(AssociatedDevList[x].shortAddr);
    575              HalUARTWrite_uint16(AssociatedDevList[x].addrIdx);
    576              HalUARTWrite(0,(uint8*)&(AssociatedDevList[x].nodeRelation), sizeof(uint8));
    577              HalUARTWrite(0,(uint8*)&(AssociatedDevList[x].devStatus), sizeof(uint8));
    578              HalUARTWrite(0,(uint8*)&(AssociatedDevList[x].assocCnt), sizeof(uint8));
    579              HalUARTWrite(0,(uint8*)&(AssociatedDevList[x].linkInfo.txCost), sizeof(uint8));
    580              HalUARTWrite(0,(uint8*)&(AssociatedDevList[x].linkInfo.rxCost), sizeof(uint8));
    581              HalUARTWrite(0,(uint8*)&(AssociatedDevList[x].linkInfo.inKeySeqNum), sizeof(uint8));
    582              HalUARTWrite(0,(uint8*)&(one_end), sizeof(uint8));
    583              }
    584              else
    585              {
    586                return;
    587              }
    588            }
    589          }
    590          #endif
    591          
    592          //检查水位计是否有电，防止水位计偶然断电后自动恢复

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          void check_water_gage_charge()
   \                     check_water_gage_charge:
    594          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    595            if(no_charge_flag ==1)      //表示水位计没电
   \   000009   90....       MOV     DPTR,#no_charge_flag
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7010         JNZ     ??check_water_gage_charge_0
    596            {
    597              osal_start_timerEx(p2p_test_TaskID,
    598                                    p2p_test_SEND_WATER_GAGE_MSG_EVT, 
    599                                    (SendWaterGageTimeFreq -60 )* 1000);
   \   000011                ; Setup parameters for call to function osal_start_timerEx
   \   000011   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   000014   E0           MOVX    A,@DPTR
   \   000015   24C4         ADD     A,#-0x3c
   \   000017   FC           MOV     R4,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   34FF         ADDC    A,#-0x1
   \   00001C   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001F   8003         SJMP    ??check_water_gage_charge_1
    600              osal_start_timerEx(p2p_test_TaskID,
    601                                    p2p_test_CHECK_WATER_GAGE_CHARGE_MSG_EVT, 
    602                                    CheckWaterGageChargeTimeFreq * 1000);
    603            }
    604            else if (no_charge_flag==0)    //表示水位计仍在正常工作
   \                     ??check_water_gage_charge_0:
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7003         JNZ     ??CrossCallReturnLabel_9
    605            {
    606              osal_start_timerEx(p2p_test_TaskID,
    607                                    p2p_test_CHECK_WATER_GAGE_CHARGE_MSG_EVT, 
    608                                    CheckWaterGageChargeTimeFreq * 1000);
   \                     ??check_water_gage_charge_1:
   \   000024                ; Setup parameters for call to function osal_start_timerEx
   \   000024   12....       LCALL   ?Subroutine2 & 0xFFFF
    609            }
    610          
    611          #if DEBUG  
    612              uint8 x =255;
   \                     ??CrossCallReturnLabel_9:
   \   000027   74FF         MOV     A,#-0x1
   \   000029   12....       LCALL   ?Subroutine27 & 0xFFFF
    613              HalUARTWrite(0,&x, sizeof(x));
    614          #endif
    615          } 
   \                     ??CrossCallReturnLabel_74:
   \   00002C   7401         MOV     A,#0x1
   \   00002E   02....       LJMP    ?Subroutine52 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine52_0:
   \   000003   D083         POP     DPH
   \   000005   D082         POP     DPL
   \   000007   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine27_0:
   \   000006   F0           MOVX    @DPTR,A
   \   000007                ; Setup parameters for call to function HalUARTWrite
   \   000007                ; Setup parameters for call to function HalUARTWrite
   \   000007                ; Setup parameters for call to function HalUARTWrite
   \   000007                ; Setup parameters for call to function HalUARTWrite
   \   000007   7C01         MOV     R4,#0x1
   \   000009   7D00         MOV     R5,#0x0
   \   00000B   AA82         MOV     R2,DPL
   \   00000D   AB83         MOV     R3,DPH
   \   00000F   7900         MOV     R1,#0x0
   \   000011   12....       LCALL   ??HalUARTWrite?relay
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   FD           MOV     R5,A
   \   000001   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??Subroutine20_0:
   \   000004   7A80         MOV     R2,#-0x80
   \                     ??Subroutine20_1:
   \   000006   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   7B00         MOV     R3,#0x0
   \                     ??Subroutine46_0:
   \   000002   90....       MOV     DPTR,#p2p_test_TaskID
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   12....       LCALL   ??osal_start_timerEx?relay
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV     DPTR,#CheckWaterGageChargeTimeFreq
   \   000003   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000006   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B01         MOV     R3,#0x1
   \   00000D   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   EC           MOV     A,R4
   \   000001   75F0E8       MOV     B,#-0x18
   \   000004   A4           MUL     AB
   \   000005   CC           XCH     A,R4
   \   000006   AAF0         MOV     R2,B
   \   000008   75F003       MOV     B,#0x3
   \   00000B   A4           MUL     AB
   \   00000C   2A           ADD     A,R2
   \   00000D   FA           MOV     R2,A
   \   00000E   75F0E8       MOV     B,#-0x18
   \   000011   ED           MOV     A,R5
   \   000012   A4           MUL     AB
   \   000013   2A           ADD     A,R2
   \   000014   FD           MOV     R5,A
   \   000015   22           RET
    616          
    617          
    618          //正确顺序输出16位数据到串口

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    619          void HalUARTWrite_uint16(uint16 data)
   \                     HalUARTWrite_uint16:
    620          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    621            typedef struct{
    622              uint8 x[2];
    623            }x;
    624             x xdata;       
    625            xdata.x[0] = (data>>8)&0x00FF;
   \   000009   EB           MOV     A,R3
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   F0           MOVX    @DPTR,A
    626            xdata.x[1] = data & 0x00FF;
   \   000011   7401         MOV     A,#0x1
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   EA           MOV     A,R2
   \   000017   F0           MOVX    @DPTR,A
    627            HalUARTWrite(0,(uint8*)&xdata, sizeof(xdata));
   \   000018                ; Setup parameters for call to function HalUARTWrite
   \   000018   7C02         MOV     R4,#0x2
   \   00001A   7D00         MOV     R5,#0x0
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AA82         MOV     R2,DPL
   \   000024   AB83         MOV     R3,DPH
   \   000026   7900         MOV     R1,#0x0
   \   000028   12....       LCALL   ??HalUARTWrite?relay
    628          }
   \   00002B   7402         MOV     A,#0x2
   \   00002D   02....       LJMP    ?Subroutine52 & 0xFFFF
    629          
    630          //预测水位计下一数据值

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    631          uint16 Water_gage_forecastValue(Watergage_data_and_time sdat)
   \                     Water_gage_forecastValue:
    632            {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 36
   \   000005   74DC         MOV     A,#-0x24
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    633               double x1,x2,x3;
    634               double y1,y2,y3;
    635               double b,k;
    636               
    637               if( (sdat.time[2]>sdat.time[1])&&(sdat.time[1]>sdat.time[0]) )
   \   00000A   743E         MOV     A,#0x3e
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   C082         PUSH    DPL
   \   000011   C083         PUSH    DPH
   \   000013   7442         MOV     A,#0x42
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?L_MOV_X
   \   00001D   D083         POP     DPH
   \   00001F   D082         POP     DPL
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?UL_GT_X
   \   000026   4003         JC      $+5
   \   000028   02....       LJMP    ??Water_gage_forecastValue_0 & 0xFFFF
   \   00002B   743A         MOV     A,#0x3a
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   C082         PUSH    DPL
   \   000032   C083         PUSH    DPH
   \   000034   743E         MOV     A,#0x3e
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   78..         MOV     R0,#?V0 + 0
   \   00003B   12....       LCALL   ?L_MOV_X
   \   00003E   D083         POP     DPH
   \   000040   D082         POP     DPL
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?UL_GT_X
   \   000047   5076         JNC     ??Water_gage_forecastValue_0
    638               {
    639                 y1=sdat.data[0];
   \   000049   7434         MOV     A,#0x34
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000051   12....       LCALL   ?UL_TO_FLT
   \   000054   740C         MOV     A,#0xc
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?L_MOV_TO_X
    640                 x1=sdat.time[0];
   \   00005E   743A         MOV     A,#0x3a
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_X
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?UL_TO_FLT
   \   00006D   7404         MOV     A,#0x4
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?L_MOV_TO_X
    641                 y2=sdat.data[1];
   \   000077   7436         MOV     A,#0x36
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00007F   12....       LCALL   ?UL_TO_FLT
   \   000082   7410         MOV     A,#0x10
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   78..         MOV     R0,#?V0 + 0
   \   000089   12....       LCALL   ?L_MOV_TO_X
    642                 x2=sdat.time[1];
   \   00008C   743E         MOV     A,#0x3e
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   78..         MOV     R0,#?V0 + 0
   \   000093   12....       LCALL   ?L_MOV_X
   \   000096   78..         MOV     R0,#?V0 + 0
   \   000098   12....       LCALL   ?UL_TO_FLT
   \   00009B   7408         MOV     A,#0x8
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   78..         MOV     R0,#?V0 + 0
   \   0000A2   12....       LCALL   ?L_MOV_TO_X
    643                 y3=sdat.data[2];
   \   0000A5   7438         MOV     A,#0x38
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000AD   12....       LCALL   ?UL_TO_FLT
   \   0000B0   7414         MOV     A,#0x14
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?L_MOV_TO_X
    644                 x3=sdat.time[2];
   \   0000BA   7442         MOV     A,#0x42
   \   0000BC   02....       LJMP    ??Water_gage_forecastValue_1 & 0xFFFF
    645          
    646               
    647               }
    648               else if( (sdat.time[0]>sdat.time[2])&&(sdat.time[2]>sdat.time[1]) )
   \                     ??Water_gage_forecastValue_0:
   \   0000BF   7442         MOV     A,#0x42
   \   0000C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C4   C082         PUSH    DPL
   \   0000C6   C083         PUSH    DPH
   \   0000C8   743A         MOV     A,#0x3a
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   78..         MOV     R0,#?V0 + 0
   \   0000CF   12....       LCALL   ?L_MOV_X
   \   0000D2   D083         POP     DPH
   \   0000D4   D082         POP     DPL
   \   0000D6   78..         MOV     R0,#?V0 + 0
   \   0000D8   12....       LCALL   ?UL_GT_X
   \   0000DB   4003         JC      $+5
   \   0000DD   02....       LJMP    ??Water_gage_forecastValue_2 & 0xFFFF
   \   0000E0   743E         MOV     A,#0x3e
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   C082         PUSH    DPL
   \   0000E7   C083         PUSH    DPH
   \   0000E9   7442         MOV     A,#0x42
   \   0000EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EE   78..         MOV     R0,#?V0 + 0
   \   0000F0   12....       LCALL   ?L_MOV_X
   \   0000F3   D083         POP     DPH
   \   0000F5   D082         POP     DPL
   \   0000F7   78..         MOV     R0,#?V0 + 0
   \   0000F9   12....       LCALL   ?UL_GT_X
   \   0000FC   5075         JNC     ??Water_gage_forecastValue_2
    649               {
    650                 y1=sdat.data[1];
   \   0000FE   7436         MOV     A,#0x36
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000106   12....       LCALL   ?UL_TO_FLT
   \   000109   740C         MOV     A,#0xc
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   78..         MOV     R0,#?V0 + 0
   \   000110   12....       LCALL   ?L_MOV_TO_X
    651                 x1=sdat.time[1];
   \   000113   743E         MOV     A,#0x3e
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   78..         MOV     R0,#?V0 + 0
   \   00011A   12....       LCALL   ?L_MOV_X
   \   00011D   78..         MOV     R0,#?V0 + 0
   \   00011F   12....       LCALL   ?UL_TO_FLT
   \   000122   7404         MOV     A,#0x4
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   78..         MOV     R0,#?V0 + 0
   \   000129   12....       LCALL   ?L_MOV_TO_X
    652                 y2=sdat.data[2];
   \   00012C   7438         MOV     A,#0x38
   \   00012E   12....       LCALL   ?XSTACK_DISP0_8
   \   000131   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000134   12....       LCALL   ?UL_TO_FLT
   \   000137   7410         MOV     A,#0x10
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   78..         MOV     R0,#?V0 + 0
   \   00013E   12....       LCALL   ?L_MOV_TO_X
    653                 x2=sdat.time[2];
   \   000141   7442         MOV     A,#0x42
   \   000143   12....       LCALL   ?XSTACK_DISP0_8
   \   000146   78..         MOV     R0,#?V0 + 0
   \   000148   12....       LCALL   ?L_MOV_X
   \   00014B   78..         MOV     R0,#?V0 + 0
   \   00014D   12....       LCALL   ?UL_TO_FLT
   \   000150   7408         MOV     A,#0x8
   \   000152   12....       LCALL   ?XSTACK_DISP0_8
   \   000155   78..         MOV     R0,#?V0 + 0
   \   000157   12....       LCALL   ?L_MOV_TO_X
    654                 y3=sdat.data[0];
   \   00015A   7434         MOV     A,#0x34
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000162   12....       LCALL   ?UL_TO_FLT
   \   000165   7414         MOV     A,#0x14
   \   000167   12....       LCALL   ?XSTACK_DISP0_8
   \   00016A   78..         MOV     R0,#?V0 + 0
   \   00016C   12....       LCALL   ?L_MOV_TO_X
    655                 x3=sdat.time[0];
   \   00016F   743A         MOV     A,#0x3a
   \   000171   8073         SJMP    ??Water_gage_forecastValue_1
    656               }
    657               else
    658               {
    659                 y1=sdat.data[2];
   \                     ??Water_gage_forecastValue_2:
   \   000173   7438         MOV     A,#0x38
   \   000175   12....       LCALL   ?XSTACK_DISP0_8
   \   000178   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00017B   12....       LCALL   ?UL_TO_FLT
   \   00017E   740C         MOV     A,#0xc
   \   000180   12....       LCALL   ?XSTACK_DISP0_8
   \   000183   78..         MOV     R0,#?V0 + 0
   \   000185   12....       LCALL   ?L_MOV_TO_X
    660                 x1=sdat.time[2];
   \   000188   7442         MOV     A,#0x42
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   78..         MOV     R0,#?V0 + 0
   \   00018F   12....       LCALL   ?L_MOV_X
   \   000192   78..         MOV     R0,#?V0 + 0
   \   000194   12....       LCALL   ?UL_TO_FLT
   \   000197   7404         MOV     A,#0x4
   \   000199   12....       LCALL   ?XSTACK_DISP0_8
   \   00019C   78..         MOV     R0,#?V0 + 0
   \   00019E   12....       LCALL   ?L_MOV_TO_X
    661                 y2=sdat.data[0];
   \   0001A1   7434         MOV     A,#0x34
   \   0001A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A6   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0001A9   12....       LCALL   ?UL_TO_FLT
   \   0001AC   7410         MOV     A,#0x10
   \   0001AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B1   78..         MOV     R0,#?V0 + 0
   \   0001B3   12....       LCALL   ?L_MOV_TO_X
    662                 x2=sdat.time[0];
   \   0001B6   743A         MOV     A,#0x3a
   \   0001B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BB   78..         MOV     R0,#?V0 + 0
   \   0001BD   12....       LCALL   ?L_MOV_X
   \   0001C0   78..         MOV     R0,#?V0 + 0
   \   0001C2   12....       LCALL   ?UL_TO_FLT
   \   0001C5   7408         MOV     A,#0x8
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   78..         MOV     R0,#?V0 + 0
   \   0001CC   12....       LCALL   ?L_MOV_TO_X
    663                 y3=sdat.data[1];
   \   0001CF   7436         MOV     A,#0x36
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0001D7   12....       LCALL   ?UL_TO_FLT
   \   0001DA   7414         MOV     A,#0x14
   \   0001DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DF   78..         MOV     R0,#?V0 + 0
   \   0001E1   12....       LCALL   ?L_MOV_TO_X
    664                 x3=sdat.time[1];
   \   0001E4   743E         MOV     A,#0x3e
   \                     ??Water_gage_forecastValue_1:
   \   0001E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E9   78..         MOV     R0,#?V0 + 0
   \   0001EB   12....       LCALL   ?L_MOV_X
   \   0001EE   78..         MOV     R0,#?V0 + 0
   \   0001F0   12....       LCALL   ?UL_TO_FLT
   \   0001F3   85..82       MOV     DPL,?XSP + 0
   \   0001F6   85..83       MOV     DPH,?XSP + 1
   \   0001F9   78..         MOV     R0,#?V0 + 0
   \   0001FB   12....       LCALL   ?L_MOV_TO_X
    665               }
    666              
    667               k=( (3*(x1*y1+x2*y2+x3*y3)-(x1+x2+x3)*(y1+y2+y3))/(3*(x1*x1+x2*x2+x3*x3)-(x1+x2+x3)*(x1+x2+x3)) );
   \   0001FE   740C         MOV     A,#0xc
   \   000200   12....       LCALL   ?XSTACK_DISP0_8
   \   000203   78..         MOV     R0,#?V0 + 0
   \   000205   12....       LCALL   ?L_MOV_X
   \   000208   7410         MOV     A,#0x10
   \   00020A   12....       LCALL   ?XSTACK_DISP0_8
   \   00020D   78..         MOV     R0,#?V0 + 4
   \   00020F   12....       LCALL   ?L_MOV_X
   \   000212   78..         MOV     R0,#?V0 + 0
   \   000214   79..         MOV     R1,#?V0 + 4
   \   000216   12....       LCALL   ?FLT_ADD
   \   000219   7414         MOV     A,#0x14
   \   00021B   12....       LCALL   ?XSTACK_DISP0_8
   \   00021E   78..         MOV     R0,#?V0 + 4
   \   000220   12....       LCALL   ?L_MOV_X
   \   000223   78..         MOV     R0,#?V0 + 0
   \   000225   79..         MOV     R1,#?V0 + 4
   \   000227   12....       LCALL   ?FLT_ADD
   \   00022A   741C         MOV     A,#0x1c
   \   00022C   12....       LCALL   ?XSTACK_DISP0_8
   \   00022F   78..         MOV     R0,#?V0 + 0
   \   000231   12....       LCALL   ?L_MOV_TO_X
   \   000234   7404         MOV     A,#0x4
   \   000236   12....       LCALL   ?XSTACK_DISP0_8
   \   000239   78..         MOV     R0,#?V0 + 0
   \   00023B   12....       LCALL   ?L_MOV_X
   \   00023E   7408         MOV     A,#0x8
   \   000240   12....       LCALL   ?XSTACK_DISP0_8
   \   000243   78..         MOV     R0,#?V0 + 4
   \   000245   12....       LCALL   ?L_MOV_X
   \   000248   78..         MOV     R0,#?V0 + 0
   \   00024A   79..         MOV     R1,#?V0 + 4
   \   00024C   12....       LCALL   ?FLT_ADD
   \   00024F   85..82       MOV     DPL,?XSP + 0
   \   000252   85..83       MOV     DPH,?XSP + 1
   \   000255   78..         MOV     R0,#?V0 + 4
   \   000257   12....       LCALL   ?L_MOV_X
   \   00025A   78..         MOV     R0,#?V0 + 0
   \   00025C   79..         MOV     R1,#?V0 + 4
   \   00025E   12....       LCALL   ?FLT_ADD
   \   000261   7418         MOV     A,#0x18
   \   000263   12....       LCALL   ?XSTACK_DISP0_8
   \   000266   78..         MOV     R0,#?V0 + 0
   \   000268   12....       LCALL   ?L_MOV_TO_X
   \   00026B   7404         MOV     A,#0x4
   \   00026D   12....       LCALL   ?XSTACK_DISP0_8
   \   000270   78..         MOV     R0,#?V0 + 0
   \   000272   12....       LCALL   ?L_MOV_X
   \   000275   740C         MOV     A,#0xc
   \   000277   12....       LCALL   ?XSTACK_DISP0_8
   \   00027A   78..         MOV     R0,#?V0 + 4
   \   00027C   12....       LCALL   ?L_MOV_X
   \   00027F   78..         MOV     R0,#?V0 + 0
   \   000281   79..         MOV     R1,#?V0 + 4
   \   000283   12....       LCALL   ?FLT_MUL
   \   000286   C0..         PUSH    ?V0 + 0
   \   000288   C0..         PUSH    ?V0 + 1
   \   00028A   C0..         PUSH    ?V0 + 2
   \   00028C   C0..         PUSH    ?V0 + 3
   \   00028E   7408         MOV     A,#0x8
   \   000290   12....       LCALL   ?XSTACK_DISP0_8
   \   000293   78..         MOV     R0,#?V0 + 4
   \   000295   12....       LCALL   ?L_MOV_X
   \   000298   7410         MOV     A,#0x10
   \   00029A   12....       LCALL   ?XSTACK_DISP0_8
   \   00029D   78..         MOV     R0,#?V0 + 0
   \   00029F   12....       LCALL   ?L_MOV_X
   \   0002A2   78..         MOV     R0,#?V0 + 4
   \   0002A4   79..         MOV     R1,#?V0 + 0
   \   0002A6   12....       LCALL   ?FLT_MUL
   \   0002A9   D0..         POP     ?V0 + 3
   \   0002AB   D0..         POP     ?V0 + 2
   \   0002AD   D0..         POP     ?V0 + 1
   \   0002AF   D0..         POP     ?V0 + 0
   \   0002B1   78..         MOV     R0,#?V0 + 0
   \   0002B3   79..         MOV     R1,#?V0 + 4
   \   0002B5   12....       LCALL   ?FLT_ADD
   \   0002B8   C0..         PUSH    ?V0 + 0
   \   0002BA   C0..         PUSH    ?V0 + 1
   \   0002BC   C0..         PUSH    ?V0 + 2
   \   0002BE   C0..         PUSH    ?V0 + 3
   \   0002C0   85..82       MOV     DPL,?XSP + 0
   \   0002C3   85..83       MOV     DPH,?XSP + 1
   \   0002C6   78..         MOV     R0,#?V0 + 4
   \   0002C8   12....       LCALL   ?L_MOV_X
   \   0002CB   7414         MOV     A,#0x14
   \   0002CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D0   78..         MOV     R0,#?V0 + 0
   \   0002D2   12....       LCALL   ?L_MOV_X
   \   0002D5   78..         MOV     R0,#?V0 + 4
   \   0002D7   79..         MOV     R1,#?V0 + 0
   \   0002D9   12....       LCALL   ?FLT_MUL
   \   0002DC   D0..         POP     ?V0 + 3
   \   0002DE   D0..         POP     ?V0 + 2
   \   0002E0   D0..         POP     ?V0 + 1
   \   0002E2   D0..         POP     ?V0 + 0
   \   0002E4   78..         MOV     R0,#?V0 + 0
   \   0002E6   79..         MOV     R1,#?V0 + 4
   \   0002E8   12....       LCALL   ?FLT_ADD
   \   0002EB   90....       MOV     DPTR,#__Constant_40400000
   \   0002EE   78..         MOV     R0,#?V0 + 4
   \   0002F0   12....       LCALL   ?L_MOV_X
   \   0002F3   78..         MOV     R0,#?V0 + 0
   \   0002F5   79..         MOV     R1,#?V0 + 4
   \   0002F7   12....       LCALL   ?FLT_MUL
   \   0002FA   C0..         PUSH    ?V0 + 0
   \   0002FC   C0..         PUSH    ?V0 + 1
   \   0002FE   C0..         PUSH    ?V0 + 2
   \   000300   C0..         PUSH    ?V0 + 3
   \   000302   7418         MOV     A,#0x18
   \   000304   12....       LCALL   ?XSTACK_DISP0_8
   \   000307   78..         MOV     R0,#?V0 + 4
   \   000309   12....       LCALL   ?L_MOV_X
   \   00030C   741C         MOV     A,#0x1c
   \   00030E   12....       LCALL   ?XSTACK_DISP0_8
   \   000311   78..         MOV     R0,#?V0 + 0
   \   000313   12....       LCALL   ?L_MOV_X
   \   000316   78..         MOV     R0,#?V0 + 4
   \   000318   79..         MOV     R1,#?V0 + 0
   \   00031A   12....       LCALL   ?FLT_MUL
   \   00031D   D0..         POP     ?V0 + 3
   \   00031F   D0..         POP     ?V0 + 2
   \   000321   D0..         POP     ?V0 + 1
   \   000323   D0..         POP     ?V0 + 0
   \   000325   78..         MOV     R0,#?V0 + 0
   \   000327   79..         MOV     R1,#?V0 + 4
   \   000329   12....       LCALL   ?FLT_SUB
   \   00032C   C0..         PUSH    ?V0 + 0
   \   00032E   C0..         PUSH    ?V0 + 1
   \   000330   C0..         PUSH    ?V0 + 2
   \   000332   C0..         PUSH    ?V0 + 3
   \   000334   7404         MOV     A,#0x4
   \   000336   12....       LCALL   ?XSTACK_DISP0_8
   \   000339   78..         MOV     R0,#?V0 + 0
   \   00033B   12....       LCALL   ?L_MOV_X
   \   00033E   7404         MOV     A,#0x4
   \   000340   12....       LCALL   ?XSTACK_DISP0_8
   \   000343   78..         MOV     R0,#?V0 + 4
   \   000345   12....       LCALL   ?L_MOV_X
   \   000348   78..         MOV     R0,#?V0 + 0
   \   00034A   79..         MOV     R1,#?V0 + 4
   \   00034C   12....       LCALL   ?FLT_MUL
   \   00034F   C0..         PUSH    ?V0 + 0
   \   000351   C0..         PUSH    ?V0 + 1
   \   000353   C0..         PUSH    ?V0 + 2
   \   000355   C0..         PUSH    ?V0 + 3
   \   000357   7408         MOV     A,#0x8
   \   000359   12....       LCALL   ?XSTACK_DISP0_8
   \   00035C   78..         MOV     R0,#?V0 + 4
   \   00035E   12....       LCALL   ?L_MOV_X
   \   000361   7408         MOV     A,#0x8
   \   000363   12....       LCALL   ?XSTACK_DISP0_8
   \   000366   78..         MOV     R0,#?V0 + 0
   \   000368   12....       LCALL   ?L_MOV_X
   \   00036B   78..         MOV     R0,#?V0 + 4
   \   00036D   79..         MOV     R1,#?V0 + 0
   \   00036F   12....       LCALL   ?FLT_MUL
   \   000372   D0..         POP     ?V0 + 3
   \   000374   D0..         POP     ?V0 + 2
   \   000376   D0..         POP     ?V0 + 1
   \   000378   D0..         POP     ?V0 + 0
   \   00037A   78..         MOV     R0,#?V0 + 0
   \   00037C   79..         MOV     R1,#?V0 + 4
   \   00037E   12....       LCALL   ?FLT_ADD
   \   000381   C0..         PUSH    ?V0 + 0
   \   000383   C0..         PUSH    ?V0 + 1
   \   000385   C0..         PUSH    ?V0 + 2
   \   000387   C0..         PUSH    ?V0 + 3
   \   000389   85..82       MOV     DPL,?XSP + 0
   \   00038C   85..83       MOV     DPH,?XSP + 1
   \   00038F   78..         MOV     R0,#?V0 + 4
   \   000391   12....       LCALL   ?L_MOV_X
   \   000394   85..82       MOV     DPL,?XSP + 0
   \   000397   85..83       MOV     DPH,?XSP + 1
   \   00039A   78..         MOV     R0,#?V0 + 0
   \   00039C   12....       LCALL   ?L_MOV_X
   \   00039F   78..         MOV     R0,#?V0 + 4
   \   0003A1   79..         MOV     R1,#?V0 + 0
   \   0003A3   12....       LCALL   ?FLT_MUL
   \   0003A6   D0..         POP     ?V0 + 3
   \   0003A8   D0..         POP     ?V0 + 2
   \   0003AA   D0..         POP     ?V0 + 1
   \   0003AC   D0..         POP     ?V0 + 0
   \   0003AE   78..         MOV     R0,#?V0 + 0
   \   0003B0   79..         MOV     R1,#?V0 + 4
   \   0003B2   12....       LCALL   ?FLT_ADD
   \   0003B5   90....       MOV     DPTR,#__Constant_40400000
   \   0003B8   78..         MOV     R0,#?V0 + 4
   \   0003BA   12....       LCALL   ?L_MOV_X
   \   0003BD   78..         MOV     R0,#?V0 + 0
   \   0003BF   79..         MOV     R1,#?V0 + 4
   \   0003C1   12....       LCALL   ?FLT_MUL
   \   0003C4   C0..         PUSH    ?V0 + 0
   \   0003C6   C0..         PUSH    ?V0 + 1
   \   0003C8   C0..         PUSH    ?V0 + 2
   \   0003CA   C0..         PUSH    ?V0 + 3
   \   0003CC   7418         MOV     A,#0x18
   \   0003CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D1   78..         MOV     R0,#?V0 + 4
   \   0003D3   12....       LCALL   ?L_MOV_X
   \   0003D6   7418         MOV     A,#0x18
   \   0003D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DB   78..         MOV     R0,#?V0 + 0
   \   0003DD   12....       LCALL   ?L_MOV_X
   \   0003E0   78..         MOV     R0,#?V0 + 4
   \   0003E2   79..         MOV     R1,#?V0 + 0
   \   0003E4   12....       LCALL   ?FLT_MUL
   \   0003E7   D0..         POP     ?V0 + 3
   \   0003E9   D0..         POP     ?V0 + 2
   \   0003EB   D0..         POP     ?V0 + 1
   \   0003ED   D0..         POP     ?V0 + 0
   \   0003EF   78..         MOV     R0,#?V0 + 0
   \   0003F1   79..         MOV     R1,#?V0 + 4
   \   0003F3   12....       LCALL   ?FLT_SUB
   \   0003F6   D0..         POP     ?V0 + 7
   \   0003F8   D0..         POP     ?V0 + 6
   \   0003FA   D0..         POP     ?V0 + 5
   \   0003FC   D0..         POP     ?V0 + 4
   \   0003FE   78..         MOV     R0,#?V0 + 4
   \   000400   79..         MOV     R1,#?V0 + 0
   \   000402   12....       LCALL   ?FLT_DIV
   \   000405   7420         MOV     A,#0x20
   \   000407   12....       LCALL   ?XSTACK_DISP0_8
   \   00040A   78..         MOV     R0,#?V0 + 4
   \   00040C   12....       LCALL   ?L_MOV_TO_X
    668               b=( (y1+y2+y3) -k*(x1+x2+x3) )/3;
    669          
    670               uint16 y4 =k*(x3+SendWaterGageTimeFreq*1000)+b;
    671               
    672               return y4;
   \   00040F   7420         MOV     A,#0x20
   \   000411   12....       LCALL   ?XSTACK_DISP0_8
   \   000414   78..         MOV     R0,#?V0 + 0
   \   000416   12....       LCALL   ?L_MOV_X
   \   000419   C0..         PUSH    ?V0 + 0
   \   00041B   C0..         PUSH    ?V0 + 1
   \   00041D   C0..         PUSH    ?V0 + 2
   \   00041F   C0..         PUSH    ?V0 + 3
   \   000421   85..82       MOV     DPL,?XSP + 0
   \   000424   85..83       MOV     DPH,?XSP + 1
   \   000427   78..         MOV     R0,#?V0 + 4
   \   000429   12....       LCALL   ?L_MOV_X
   \   00042C   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   00042F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000432   E5..         MOV     A,?V0 + 0
   \   000434   75F0E8       MOV     B,#-0x18
   \   000437   A4           MUL     AB
   \   000438   C5..         XCH     A,?V0 + 0
   \   00043A   AAF0         MOV     R2,B
   \   00043C   75F003       MOV     B,#0x3
   \   00043F   A4           MUL     AB
   \   000440   2A           ADD     A,R2
   \   000441   FA           MOV     R2,A
   \   000442   75F0E8       MOV     B,#-0x18
   \   000445   E5..         MOV     A,?V0 + 1
   \   000447   A4           MUL     AB
   \   000448   2A           ADD     A,R2
   \   000449   F5..         MOV     ?V0 + 1,A
   \   00044B   75..00       MOV     ?V0 + 2,#0x0
   \   00044E   75..00       MOV     ?V0 + 3,#0x0
   \   000451   78..         MOV     R0,#?V0 + 0
   \   000453   12....       LCALL   ?UL_TO_FLT
   \   000456   78..         MOV     R0,#?V0 + 4
   \   000458   79..         MOV     R1,#?V0 + 0
   \   00045A   12....       LCALL   ?FLT_ADD
   \   00045D   D0..         POP     ?V0 + 3
   \   00045F   D0..         POP     ?V0 + 2
   \   000461   D0..         POP     ?V0 + 1
   \   000463   D0..         POP     ?V0 + 0
   \   000465   78..         MOV     R0,#?V0 + 0
   \   000467   79..         MOV     R1,#?V0 + 4
   \   000469   12....       LCALL   ?FLT_MUL
   \   00046C   C0..         PUSH    ?V0 + 0
   \   00046E   C0..         PUSH    ?V0 + 1
   \   000470   C0..         PUSH    ?V0 + 2
   \   000472   C0..         PUSH    ?V0 + 3
   \   000474   741C         MOV     A,#0x1c
   \   000476   12....       LCALL   ?XSTACK_DISP0_8
   \   000479   78..         MOV     R0,#?V0 + 0
   \   00047B   12....       LCALL   ?L_MOV_X
   \   00047E   C0..         PUSH    ?V0 + 0
   \   000480   C0..         PUSH    ?V0 + 1
   \   000482   C0..         PUSH    ?V0 + 2
   \   000484   C0..         PUSH    ?V0 + 3
   \   000486   7420         MOV     A,#0x20
   \   000488   12....       LCALL   ?XSTACK_DISP0_8
   \   00048B   78..         MOV     R0,#?V0 + 4
   \   00048D   12....       LCALL   ?L_MOV_X
   \   000490   7418         MOV     A,#0x18
   \   000492   12....       LCALL   ?XSTACK_DISP0_8
   \   000495   78..         MOV     R0,#?V0 + 0
   \   000497   12....       LCALL   ?L_MOV_X
   \   00049A   78..         MOV     R0,#?V0 + 4
   \   00049C   79..         MOV     R1,#?V0 + 0
   \   00049E   12....       LCALL   ?FLT_MUL
   \   0004A1   D0..         POP     ?V0 + 3
   \   0004A3   D0..         POP     ?V0 + 2
   \   0004A5   D0..         POP     ?V0 + 1
   \   0004A7   D0..         POP     ?V0 + 0
   \   0004A9   78..         MOV     R0,#?V0 + 0
   \   0004AB   79..         MOV     R1,#?V0 + 4
   \   0004AD   12....       LCALL   ?FLT_SUB
   \   0004B0   90....       MOV     DPTR,#__Constant_40400000
   \   0004B3   78..         MOV     R0,#?V0 + 4
   \   0004B5   12....       LCALL   ?L_MOV_X
   \   0004B8   78..         MOV     R0,#?V0 + 0
   \   0004BA   79..         MOV     R1,#?V0 + 4
   \   0004BC   12....       LCALL   ?FLT_DIV
   \   0004BF   D0..         POP     ?V0 + 7
   \   0004C1   D0..         POP     ?V0 + 6
   \   0004C3   D0..         POP     ?V0 + 5
   \   0004C5   D0..         POP     ?V0 + 4
   \   0004C7   78..         MOV     R0,#?V0 + 4
   \   0004C9   79..         MOV     R1,#?V0 + 0
   \   0004CB   12....       LCALL   ?FLT_ADD
   \   0004CE   78..         MOV     R0,#?V0 + 4
   \   0004D0   12....       LCALL   ?FLT_TO_L
   \   0004D3   AA..         MOV     R2,?V0 + 4
   \   0004D5   AB..         MOV     R3,?V0 + 5
   \   0004D7   7424         MOV     A,#0x24
   \   0004D9   02....       LJMP    ?Subroutine53 & 0xFFFF
    673            }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000003   75..00       MOV     ?V0 + 2,#0x0
   \   000006   75..00       MOV     ?V0 + 3,#0x0
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine53_0:
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    674          
    675          /*
    676          //预测土壤湿度传感器下一数据值
    677          float Soil_humidity_forecastValue(Soilhumidity_data_and_time sdat)
    678          {
    679               double x1,x2,x3;
    680               double y1,y2,y3;
    681               double b,k;
    682               
    683               if( (sdat.time[2]>sdat.time[1])&&(sdat.time[1]>sdat.time[0]) )
    684               {
    685                 y1=sdat.data[0];
    686                 x1=sdat.time[0];
    687                 y2=sdat.data[1];
    688                 x2=sdat.time[1];
    689                 y3=sdat.data[2];
    690                 x3=sdat.time[2];
    691          
    692               
    693               }
    694               else if( (sdat.time[0]>sdat.time[2])&&(sdat.time[2]>sdat.time[1]) )
    695               {
    696                 y1=sdat.data[1];
    697                 x1=sdat.time[1];
    698                 y2=sdat.data[2];
    699                 x2=sdat.time[2];
    700                 y3=sdat.data[0];
    701                 x3=sdat.time[0];
    702               }
    703               else
    704               {
    705                 y1=sdat.data[2];
    706                 x1=sdat.time[2];
    707                 y2=sdat.data[0];
    708                 x2=sdat.time[0];
    709                 y3=sdat.data[1];
    710                 x3=sdat.time[1];
    711               }
    712              
    713               k=( (3*(x1*y1+x2*y2+x3*y3)-(x1+x2+x3)*(y1+y2+y3))/(3*(x1*x1+x2*x2+x3*x3)-(x1+x2+x3)*(x1+x2+x3)) );
    714               b=( (y1+y2+y3) -k*(x1+x2+x3) )/3;
    715          
    716          
    717               float y4 =k*(x3+SendSoilHumidityTimeFreq*1000)+b;
    718               
    719               return y4;
    720          
    721          }
    722          */
    723          //启动水位定时器

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    724          void start_Water_gage_timer()
   \                     start_Water_gage_timer:
    725          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    726          
    727              if(!SendWaterGageRemainTime)
   \   000004   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7002         JNZ     ??start_Water_gage_timer_0
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \                     ??start_Water_gage_timer_0:
   \   00000C   701F         JNZ     ??CrossCallReturnLabel_84
    728               {
    729                 SendWaterGageRemainTime= (SendWaterGageTimeFreq >= 60) ? (SendWaterGageTimeFreq - 60) : 0;//补偿发送前的定时1min
   \   00000E   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   000011   C3           CLR     C
   \   000012   E0           MOVX    A,@DPTR
   \   000013   943C         SUBB    A,#0x3c
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   9400         SUBB    A,#0x0
   \   000019   4036         JC      ??start_Water_gage_timer_1
   \   00001B   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   24C4         ADD     A,#-0x3c
   \   000021   F8           MOV     R0,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   34FF         ADDC    A,#-0x1
   \   000026   F9           MOV     R1,A
   \   000027   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   00002A   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    730          
    731               }
    732               if(SendWaterGageRemainTime > 65)//osal_start_timerEx max time is 65.535s
   \                     ??CrossCallReturnLabel_84:
   \   00002D   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   000030   C3           CLR     C
   \   000031   E0           MOVX    A,@DPTR
   \   000032   9442         SUBB    A,#0x42
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   9400         SUBB    A,#0x0
   \   000038   4017         JC      ??start_Water_gage_timer_1
    733               {
    734                 SendWaterGageRemainTime-= 65;
   \   00003A   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   24BF         ADD     A,#-0x41
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   34FF         ADDC    A,#-0x1
   \   000045   F0           MOVX    @DPTR,A
    735                 osal_start_timerEx( p2p_test_TaskID,
    736                                    p2p_test_START_WATER_GAGE_TIME_MSG_EVT, //不发数据，再次启动一个定时器
    737                                    65000);
   \   000046                ; Setup parameters for call to function osal_start_timerEx
   \   000046   7CE8         MOV     R4,#-0x18
   \   000048   7DFD         MOV     R5,#-0x3
   \   00004A   7A10         MOV     R2,#0x10
   \   00004C   12....       LCALL   ??Subroutine20_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00004F   8011         SJMP    ??start_Water_gage_timer_2
    738               }
    739               else 
    740               {
    741                 osal_start_timerEx(p2p_test_TaskID,
    742                                    p2p_test_SEND_WATER_GAGE_MSG_EVT, 
    743                                    SendWaterGageRemainTime * 1000);
   \                     ??start_Water_gage_timer_1:
   \   000051                ; Setup parameters for call to function osal_start_timerEx
   \   000051   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FC           MOV     R4,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   12....       LCALL   ?Subroutine20 & 0xFFFF
    744                SendWaterGageRemainTime= 0;
   \                     ??CrossCallReturnLabel_55:
   \   00005B   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   00005E   E4           CLR     A
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   A3           INC     DPTR
   \   000061   F0           MOVX    @DPTR,A
    745               }
    746          
    747                 return;
   \                     ??start_Water_gage_timer_2:
   \   000062   02....       LJMP    ??Subroutine52_0 & 0xFFFF
    748          
    749            
    750          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   90....       MOV     DPTR,#Tail_Map
   \                     ??Subroutine31_0:
   \   000003   E8           MOV     A,R0
   \                     ??Subroutine31_1:
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   E9           MOV     A,R1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET
    751          /*
    752          //启动土壤湿度的定时器
    753          void start_Soil_humidity_timer()
    754          {
    755          
    756              if(!SendSoilHumidityRemainTime)
    757              {
    758                SendSoilHumidityRemainTime = SendSoilHumidityTimeFreq;
    759              }
    760          
    761              if(SendSoilHumidityRemainTime>65)//osal_start_timerEx max time is 65.535s
    762              {
    763                SendSoilHumidityRemainTime -= 65;
    764                osal_start_timerEx( p2p_test_TaskID,
    765                                 p2p_test_START_SOIL_HUMIDITY_TIME_MSG_EVT,
    766                                65000 );
    767              }
    768              else
    769              {
    770                 osal_start_timerEx( p2p_test_TaskID,
    771                                p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT,
    772                                SendSoilHumidityTimeFreq*1000 );
    773                 SendSoilHumidityRemainTime = 0;
    774              }
    775          
    776                return;      
    777          
    778            }
    779          
    780          //将土壤湿度采集后经处理获得的数字值变为实际的模拟值（考虑参考电压后），以便存储和预测
    781          float Soil_humidity_DtoA(uint16 data,uint16 vcc)
    782            {
    783              float x =( (1.25*data*vcc/8191)/8191);
    784              return x;
    785            }
    786          */
    787          
    788          /*********************************************************************
    789           * NETWORK LAYER CALLBACKS
    790           */
    791          
    792          /*********************************************************************
    793           * PUBLIC FUNCTIONS
    794           */
    795          
    796          /*********************************************************************
    797           * @fn      p2p_test_Init
    798           *
    799           * @brief   Initialization function for the Generic App Task.
    800           *          This is called during initialization and should contain
    801           *          any application specific initialization (ie. hardware
    802           *          initialization/setup, table initialization, power up
    803           *          notificaiton ... ).
    804           *
    805           * @param   task_id - the ID assigned by OSAL.  This ID should be
    806           *                    used to send messages and set timers.
    807           *
    808           * @return  none
    809           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    810          void p2p_test_Init( byte task_id )
   \                     p2p_test_Init:
    811          { 
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    812            p2p_test_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#p2p_test_TaskID
   \   000008   F0           MOVX    @DPTR,A
    813            p2p_test_NwkState = DEV_INIT;
   \   000009   7401         MOV     A,#0x1
   \   00000B   90....       MOV     DPTR,#p2p_test_NwkState
   \   00000E   F0           MOVX    @DPTR,A
    814            p2p_test_TransID = 0;
   \   00000F   E4           CLR     A
   \   000010   90....       MOV     DPTR,#p2p_test_TransID
   \   000013   F0           MOVX    @DPTR,A
    815          //zyq add
    816            /*
    817            SendRainCountFreq = 1;
    818            RainCountNum = 0;  
    819            SendRainTimeFreq = 1;//product unit= 1 minute test unit=1 second
    820            SendRainRemainTime = 0;
    821            SendSoilHumidityTimeFreq = 5;
    822            SendSoilHumidityRemainTime = 0;  
    823            SendAccelerometerTimeFreq=1;
    824            SendAccelerometerRemainTime=0;
    825            SendVccValueTimeFreq   = 1;
    826            SendVccValueRemainTime = 0;
    827            */
    828            SendWaterGageTimeFreq = 1*60;//单位 s
   \   000014   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   000017   743C         MOV     A,#0x3c
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   E4           CLR     A
   \   00001C   F0           MOVX    @DPTR,A
    829            SendWaterGageRemainTime=0;
   \   00001D   90....       MOV     DPTR,#SendWaterGageRemainTime
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   F0           MOVX    @DPTR,A
    830            
    831            //select watergage type;
    832            WaterGageUnit=Default_Water_Gage;
   \   000023   90....       MOV     DPTR,#WaterGageUnit
   \   000026   7403         MOV     A,#0x3
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   E4           CLR     A
   \   00002B   F0           MOVX    @DPTR,A
    833            //select soil type:0--Clay_Soil,1--Loam_Soil,2--Sand_Soil.init is Clay_Soil
    834            //SOIL_TYPE = 0;
    835          //  SerialNumber = 0;
    836            
    837          //自己编写
    838            //初始化
    839            Water_gage_SerialNumber = 0;
   \   00002C   90....       MOV     DPTR,#Water_gage_SerialNumber
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   A3           INC     DPTR
   \   000031   F0           MOVX    @DPTR,A
    840            Water_gage_time = 1*60;
   \   000032   90....       MOV     DPTR,#Water_gage_time
   \   000035   743C         MOV     A,#0x3c
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
    841            Water_gage_forValue=0;
   \   00003B   90....       MOV     DPTR,#Water_gage_forValue
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   F0           MOVX    @DPTR,A
    842          
    843            no_charge_flag = 0;
   \   000041   90....       MOV     DPTR,#no_charge_flag
   \   000044   F0           MOVX    @DPTR,A
    844            water_gage_on = 0;
   \   000045   90....       MOV     DPTR,#water_gage_on
   \   000048   F0           MOVX    @DPTR,A
    845            CheckWaterGageChargeTimeFreq =60; // 1min
   \   000049   90....       MOV     DPTR,#CheckWaterGageChargeTimeFreq
   \   00004C   743C         MOV     A,#0x3c
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   E4           CLR     A
   \   000051   F0           MOVX    @DPTR,A
    846            
    847            Water_gage_err_a = 10;  //10mm
   \   000052   740A         MOV     A,#0xa
   \   000054   90....       MOV     DPTR,#Water_gage_err_a
   \   000057   F0           MOVX    @DPTR,A
    848            Water_gage_err_b = 50;  //50mm
   \   000058   7432         MOV     A,#0x32
   \   00005A   90....       MOV     DPTR,#Water_gage_err_b
   \   00005D   F0           MOVX    @DPTR,A
    849            Water_gage_err_c = 100; //100mm
   \   00005E   7464         MOV     A,#0x64
   \   000060   90....       MOV     DPTR,#Water_gage_err_c
   \   000063   F0           MOVX    @DPTR,A
    850            
    851            /*
    852            Soil_humidity_SerialNumber = 0;
    853            Soil_humidity_time = 5*60;
    854            Soil_humidity_forValue=0;
    855            */
    856            relation_done =0;
   \   000064   E4           CLR     A
   \   000065   90....       MOV     DPTR,#relation_done
   \   000068   F0           MOVX    @DPTR,A
    857            acceptance = 1;
   \   000069   7401         MOV     A,#0x1
   \   00006B   90....       MOV     DPTR,#acceptance
   \   00006E   F0           MOVX    @DPTR,A
    858            
    859          //未用到 
    860            /*SoilHumidityFlag=0;
    861             RainFlag=0;*/
    862             WaterGageFlag=0;
   \   00006F   E4           CLR     A
   \   000070   90....       MOV     DPTR,#WaterGageFlag
   \   000073   F0           MOVX    @DPTR,A
    863             
    864             ARM_ID=0x00;
   \   000074   90....       MOV     DPTR,#ARM_ID
   \   000077   F0           MOVX    @DPTR,A
    865             Zigbee_ID=0x00;
   \   000078   90....       MOV     DPTR,#Zigbee_ID
   \   00007B   F0           MOVX    @DPTR,A
    866             RES=0x00;
   \   00007C   90....       MOV     DPTR,#RES
   \   00007F   F0           MOVX    @DPTR,A
    867             
    868             Head_Map=(struct RelationMap_t *)osal_msg_allocate(sizeof(struct RelationMap_t));//init relation map
   \   000080                ; Setup parameters for call to function osal_msg_allocate
   \   000080   7A05         MOV     R2,#0x5
   \   000082   FB           MOV     R3,A
   \   000083   12....       LCALL   ??osal_msg_allocate?relay
   \   000086   90....       MOV     DPTR,#Head_Map
   \   000089   EA           MOV     A,R2
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A3           INC     DPTR
   \   00008C   EB           MOV     A,R3
   \   00008D   12....       LCALL   ?Subroutine9 & 0xFFFF
    869             Head_Map->addr16=0x0000;
    870             Head_Map->Zigbee_id=Zigbee_ID;
   \                     ??CrossCallReturnLabel_30:
   \   000090   C0E0         PUSH    A
   \   000092   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000095   D0E0         POP     A
   \   000097   F0           MOVX    @DPTR,A
    871             Head_Map->next=NULL;
   \   000098   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00009B   A3           INC     DPTR
   \   00009C   E4           CLR     A
   \   00009D   F0           MOVX    @DPTR,A
   \   00009E   A3           INC     DPTR
   \   00009F   F0           MOVX    @DPTR,A
    872             Tail_Map=Head_Map;
   \   0000A0   90....       MOV     DPTR,#Head_Map
   \   0000A3   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000A6   12....       LCALL   ?Subroutine31 & 0xFFFF
    873             FlagMap=0x0000;
   \                     ??CrossCallReturnLabel_85:
   \   0000A9   90....       MOV     DPTR,#FlagMap
   \   0000AC   E4           CLR     A
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   F0           MOVX    @DPTR,A
    874          
    875             // NodeId = 17;
    876             //NodeId = 32;
    877             //NodeId = 51;
    878             //NodeId = 68 ;
    879             //NodeId = 85 ;
    880             // Device hardware initialization can be added here or in main() (Zmain.c).
    881             // If the hardware is application specific - add it here.
    882             // If the hardware is other parts of the device add it in main().
    883          
    884            p2p_test_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;//must't be modify in other
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   90....       MOV     DPTR,#(p2p_test_DstAddr + 2)
   \   0000B5   F0           MOVX    @DPTR,A
    885            p2p_test_DstAddr.endPoint = p2p_test_ENDPOINT;
   \   0000B6   740A         MOV     A,#0xa
   \   0000B8   90....       MOV     DPTR,#(p2p_test_DstAddr + 3)
   \   0000BB   F0           MOVX    @DPTR,A
    886            p2p_test_DstAddr.addr.shortAddr = 0x0000;
   \   0000BC   90....       MOV     DPTR,#p2p_test_DstAddr
   \   0000BF   E4           CLR     A
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   F0           MOVX    @DPTR,A
    887            
    888            p2p_test_EnddeviceAddr.addrMode = (afAddrMode_t)Addr16Bit;//must't be modify in other
   \   0000C3   7402         MOV     A,#0x2
   \   0000C5   90....       MOV     DPTR,#(p2p_test_EnddeviceAddr + 2)
   \   0000C8   F0           MOVX    @DPTR,A
    889            p2p_test_EnddeviceAddr.endPoint = p2p_test_ENDPOINT;
   \   0000C9   740A         MOV     A,#0xa
   \   0000CB   90....       MOV     DPTR,#(p2p_test_EnddeviceAddr + 3)
   \   0000CE   F0           MOVX    @DPTR,A
    890            p2p_test_EnddeviceAddr.addr.shortAddr = 0xFFFF;
   \   0000CF   90....       MOV     DPTR,#p2p_test_EnddeviceAddr
   \   0000D2   74FF         MOV     A,#-0x1
   \   0000D4   F0           MOVX    @DPTR,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   F0           MOVX    @DPTR,A
    891          
    892            // Fill out the endpoint description.
    893            p2p_test_epDesc.endPoint = p2p_test_ENDPOINT;
   \   0000D7   740A         MOV     A,#0xa
   \   0000D9   90....       MOV     DPTR,#p2p_test_epDesc
   \   0000DC   F0           MOVX    @DPTR,A
    894            p2p_test_epDesc.task_id = &p2p_test_TaskID;
   \   0000DD   90....       MOV     DPTR,#(p2p_test_epDesc + 1)
   \   0000E0   74..         MOV     A,#(p2p_test_TaskID & 0xff)
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   74..         MOV     A,#((p2p_test_TaskID >> 8) & 0xff)
   \   0000E6   F0           MOVX    @DPTR,A
    895            p2p_test_epDesc.simpleDesc
    896                      = (SimpleDescriptionFormat_t *)&p2p_test_SimpleDesc;
   \   0000E7   90....       MOV     DPTR,#(p2p_test_epDesc + 3)
   \   0000EA   74..         MOV     A,#(p2p_test_SimpleDesc & 0xff)
   \   0000EC   F0           MOVX    @DPTR,A
   \   0000ED   A3           INC     DPTR
   \   0000EE   74..         MOV     A,#((p2p_test_SimpleDesc >> 8) & 0xff)
   \   0000F0   F0           MOVX    @DPTR,A
    897            p2p_test_epDesc.latencyReq = noLatencyReqs;
   \   0000F1   E4           CLR     A
   \   0000F2   90....       MOV     DPTR,#(p2p_test_epDesc + 5)
   \   0000F5   F0           MOVX    @DPTR,A
    898          
    899            // Register the endpoint description with the AF
    900            afRegister( &p2p_test_epDesc );
   \   0000F6                ; Setup parameters for call to function afRegister
   \   0000F6   7A..         MOV     R2,#(p2p_test_epDesc & 0xff)
   \   0000F8   7B..         MOV     R3,#((p2p_test_epDesc >> 8) & 0xff)
   \   0000FA   12....       LCALL   ??afRegister?relay
    901            
    902            //P1_0 is the driver of uart1 
    903            P1SEL&=~(0x01);  //uart1 enable drive P1_0
   \   0000FD   53F4FE       ANL     0xf4,#0xfe
    904            P1DIR |=(0x01);   //P1_0 output
   \   000100   43FE01       ORL     0xfe,#0x1
    905            
    906            P2SEL&=~(0x01);  //uart1 enable drive P2_0
   \   000103   53F5FE       ANL     0xf5,#0xfe
    907            P2DIR |=(0x01);   //P2_0 output
   \   000106   43FF01       ORL     0xff,#0x1
    908            P2_0=0;
   \   000109   C2A0         CLR     0xa0.0
    909           
    910            P1SEL&=~(0x02);  // P1_1
   \   00010B   53F4FD       ANL     0xf4,#0xfd
    911            P1DIR |=(0x02);   //P1_1 output
   \   00010E   43FE02       ORL     0xfe,#0x2
    912            P1_1=0;
   \   000111   C291         CLR     0x90.1
    913            //P0SEL &=~ (0x30);
    914            //P0DIR &=~ (0x30);
    915            // Register for all key events - This app will handle all key events
    916            //RegisterForKeys( p2p_test_TaskID );
    917            /* 
    918            P2SEL &= ~(0x01);  //LED general-- test purpose
    919            P2DIR |= (0x01);   //LED output-- test purpose
    920            P2_0=1;            //LED brig.hten-- test purpose
    921            */ 
    922            
    923            //p1.3 -- general -- input -- pullup -- FallEdge
    924            OpenP1Interrupt(PIN_3, FUN_SELECT_GENERAL, DIRECTION_INPUT, INPUT_MODE_PULLUP, FALL_EDGE); 
   \   000113                ; Setup parameters for call to function OpenP1Interrupt
   \   000113   7D01         MOV     R5,#0x1
   \   000115   7C00         MOV     R4,#0x0
   \   000117   7B00         MOV     R3,#0x0
   \   000119   7A00         MOV     R2,#0x0
   \   00011B   7903         MOV     R1,#0x3
   \   00011D   12....       LCALL   ??OpenP1Interrupt?relay
    925            RegisterP1Interrupt(PIN_3, p2p_test_TaskID);
   \   000120                ; Setup parameters for call to function RegisterP1Interrupt
   \   000120   90....       MOV     DPTR,#p2p_test_TaskID
   \   000123   E0           MOVX    A,@DPTR
   \   000124   FA           MOV     R2,A
   \   000125   7903         MOV     R1,#0x3
   \   000127   12....       LCALL   ??RegisterP1Interrupt?relay
    926            StartP1Interrupt(PIN_3);   
   \   00012A                ; Setup parameters for call to function StartP1Interrupt
   \   00012A   7903         MOV     R1,#0x3
   \   00012C   12....       LCALL   ??StartP1Interrupt?relay
    927            SPIMgr_RegisterTaskID(p2p_test_TaskID);//for uart recv
   \   00012F                ; Setup parameters for call to function SPIMgr_RegisterTaskID
   \   00012F   90....       MOV     DPTR,#p2p_test_TaskID
   \   000132   E0           MOVX    A,@DPTR
   \   000133   F9           MOV     R1,A
   \   000134   12....       LCALL   ??SPIMgr_RegisterTaskID?relay
    928          
    929          
    930            // Update the display
    931            //#if defined ( LCD_SUPPORTED )
    932            //    HalLcdWriteString( "p2p_test", HAL_LCD_LINE_1 );
    933            //#endif
    934          
    935            ZDO_RegisterForZDOMsg( p2p_test_TaskID, End_Device_Bind_rsp );
   \   000137                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000137   7A20         MOV     R2,#0x20
   \   000139   7B80         MOV     R3,#-0x80
   \   00013B   90....       MOV     DPTR,#p2p_test_TaskID
   \   00013E   E0           MOVX    A,@DPTR
   \   00013F   F9           MOV     R1,A
   \   000140   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    936            ZDO_RegisterForZDOMsg( p2p_test_TaskID, Match_Desc_rsp );
   \   000143                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000143   7A06         MOV     R2,#0x6
   \   000145   7B80         MOV     R3,#-0x80
   \   000147   90....       MOV     DPTR,#p2p_test_TaskID
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   F9           MOV     R1,A
   \   00014C   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    937          }
   \   00014F   80..         SJMP    ??Subroutine52_0
   \   000151                REQUIRE _A_P1
   \   000151                REQUIRE _A_P2
   \   000151                REQUIRE P1SEL
   \   000151                REQUIRE P2SEL
   \   000151                REQUIRE P1DIR
   \   000151                REQUIRE P2DIR

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine16_0:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F8           MOV     R0,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   90....       MOV     DPTR,#Zigbee_ID
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   90....       MOV     DPTR,#Head_Map
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F583         MOV     DPH,A
   \   000009   8882         MOV     DPL,R0
   \   00000B   22           RET
    938          
    939          /*********************************************************************
    940           * @fn      p2p_test_ProcessEvent
    941           *
    942           * @brief   Generic Application Task event processor.  This function
    943           *          is called to process all events for the task.  Events
    944           *          include timers, messages and any other user defined events.
    945           *
    946           * @param   task_id  - The OSAL assigned task ID.
    947           * @param   events - events to process.  This is a bit map and can
    948           *                   contain more than one event.
    949           *
    950           * @return  none
    951           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    952          UINT16 p2p_test_ProcessEvent( byte task_id, UINT16 events )
   \                     p2p_test_ProcessEvent:
    953          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    954            afIncomingMSGPacket_t *MSGpkt;
    955            afDataConfirm_t *afDataConfirm;
    956          
    957          #if DEBUG
    958            uint8 x1 = 17;
   \   00000E   7401         MOV     A,#0x1
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7411         MOV     A,#0x11
   \   000015   F0           MOVX    @DPTR,A
    959            uint8 x2 = 34;
   \   000016   7402         MOV     A,#0x2
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   7422         MOV     A,#0x22
   \   00001D   F0           MOVX    @DPTR,A
    960            uint8 x3 = 51;
   \   00001E   7403         MOV     A,#0x3
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   7433         MOV     A,#0x33
   \   000025   F0           MOVX    @DPTR,A
    961            uint8 x4 = 68;
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7444         MOV     A,#0x44
   \   00002D   F0           MOVX    @DPTR,A
    962            uint8 x5 = 85;
   \   00002E   7405         MOV     A,#0x5
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   7455         MOV     A,#0x55
   \   000035   F0           MOVX    @DPTR,A
    963            uint8 x6 = 102;
   \   000036   7406         MOV     A,#0x6
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   7466         MOV     A,#0x66
   \   00003D   F0           MOVX    @DPTR,A
    964            uint8 x7 = 119;
   \   00003E   7407         MOV     A,#0x7
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   7477         MOV     A,#0x77
   \   000045   F0           MOVX    @DPTR,A
    965            uint8 x8 = 136;
   \   000046   7408         MOV     A,#0x8
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   7488         MOV     A,#-0x78
   \   00004D   F0           MOVX    @DPTR,A
    966            uint8 x9 = 153;
   \   00004E   7409         MOV     A,#0x9
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   7499         MOV     A,#-0x67
   \   000055   F0           MOVX    @DPTR,A
    967            uint8 x10 = 170;
   \   000056   740A         MOV     A,#0xa
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   74AA         MOV     A,#-0x56
   \   00005D   F0           MOVX    @DPTR,A
    968            
    969          #endif
    970            
    971            // Data Confirmation message fields
    972            byte sentEP;
    973            ZStatus_t sentStatus;
    974            byte sentTransID;       // This should match the value sent
    975            
    976            if ( events & SYS_EVENT_MSG )
   \   00005E   7480         MOV     A,#-0x80
   \   000060   5F           ANL     A,R7
   \   000061   F9           MOV     R1,A
   \   000062   E4           CLR     A
   \   000063   7001         JNZ     ??p2p_test_ProcessEvent_0
   \   000065   E9           MOV     A,R1
   \                     ??p2p_test_ProcessEvent_0:
   \   000066   7003         JNZ     $+5
   \   000068   02....       LJMP    ??p2p_test_ProcessEvent_1 & 0xFFFF
    977            {
    978              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( p2p_test_TaskID );
   \   00006B                ; Setup parameters for call to function osal_msg_receive
   \   00006B   801E         SJMP    ??p2p_test_ProcessEvent_2
    979              while ( MSGpkt )
    980              {
    981                switch ( MSGpkt->hdr.event )
    982                {
    983                  case ZDO_CB_MSG:
    984                    p2p_test_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
    985                    break;
    986          
    987                  case KEY_CHANGE:
    988                    // p2p_test_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    989                    break;
    990                  case CMD_SERIAL_MSG: 
    991                    {
    992          #if DEBUG 
    993                    uint8 x3 = 0xEE;
    994                    HalUARTWrite(0,&x3, sizeof(x3));
    995          #endif  
    996                    p2p_test_RecvFromUart( ((mtOSALSerialData_t *)MSGpkt)->msg ); 
    997                    }
    998                    break;
    999                  case P1_0_INTERRUPT:
   1000                    
   1001                    break;
   1002                  case P1_1_INTERRUPT:
   1003                    
   1004                    break;
   1005                  case P1_2_INTERRUPT:
   1006          
   1007                    break;
   1008                  case P1_3_INTERRUPT:
   1009                    //HalUARTWrite(0,te,3);
   1010                   // p2p_test_interrupt_rain(  ( (rain_t *)MSGpkt )->count  );          
   1011                    break;
   1012                  case P1_4_INTERRUPT:
   1013                    
   1014                    break;
   1015                  case P1_5_INTERRUPT:
   1016                    
   1017                    break;
   1018                  case P1_6_INTERRUPT:
   1019                    
   1020                    break;
   1021                  case P1_7_INTERRUPT:
   1022                    
   1023                    break;          
   1024                  case AF_DATA_CONFIRM_CMD:
   1025                    // This message is received as a confirmation of a data packet sent.
   1026                    // The status is of ZStatus_t type [defined in ZComDef.h]
   1027                    // The message fields are defined in AF.h
   1028                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
   1029                    sentEP = afDataConfirm->endpoint;
   1030                    sentStatus = afDataConfirm->hdr.status;
   1031                    sentTransID = afDataConfirm->transID;
   1032                    (void)sentEP;
   1033                    (void)sentTransID;
   1034          
   1035                    // Action taken when confirmation is received.
   1036                    if ( sentStatus != ZSuccess )
   1037                    {
   1038                      // The data wasn't delivered -- Do something
   1039                    }
   1040                    break;
   1041          
   1042                  case AF_INCOMING_MSG_CMD:
   1043                    p2p_test_MessageMSGCB( MSGpkt );
   1044                    //READ_TEST( MSGpkt );//DONG
   1045                      
   1046           //         HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
   1047            //        MicroWait( 62500 );
   1048            //        MicroWait( 62500 );
   1049             //       HalLedSet( HAL_LED_1, HAL_LED_MODE_OFF );
   1050                    break;
   1051          
   1052                  case ZDO_STATE_CHANGE:
   1053                    p2p_test_NwkState = (devStates_t)(MSGpkt->hdr.status);
   1054          
   1055                  //网络层组网成功
   1056                    if(p2p_test_NwkState ==DEV_END_DEVICE)
   1057                    {  
   1058                    osal_start_timerEx( p2p_test_TaskID,
   1059                                      p2p_test_SEND_MAINTAIN_MSG_EVT,
   1060                                      1000 );           
   1061          #if DEBUG          
   1062                    HalUARTWrite(0,&x1, sizeof(x1));
   1063          #endif
   1064                    }
   1065                    //网络层组网失败（如pan断电）
   1066                    else if(p2p_test_NwkState ==DEV_INIT)
   1067                    {
   1068                      osal_stop_timerEx(p2p_test_TaskID, 
   1069                                        p2p_test_SEND_WATER_GAGE_MSG_EVT);
   1070                      osal_stop_timerEx(p2p_test_TaskID, 
   1071                                        p2p_test_CHECK_WATER_GAGE_CHARGE_MSG_EVT);
   1072                      //p2p_test_Init(p2p_test_TaskID);//不加此句，之前的数据仍保存
   1073                    
   1074          #if DEBUG          
   1075                    HalUARTWrite(0,&x2, sizeof(x2));
   1076          #endif    
   1077                   //start watchdog mode, default time interval 1s
   1078                    SystemReset();
   1079          
   1080                    }      
   1081                    //pan开启
   1082                    else if(p2p_test_NwkState ==DEV_ZB_COORD)
   1083                    {
   1084                         osal_start_timerEx( p2p_test_TaskID,
   1085                                      p2p_test_SEND_MAINTAIN_MSG_EVT,
   1086                                      1000 );    
   1087          #if DEBUG          
   1088                    HalUARTWrite(0,&x3, sizeof(x3));
   1089          #endif               
   1090                    }
   1091          
   1092          #if DEBUG  
   1093                    else if(p2p_test_NwkState ==DEV_HOLD)   
   1094                      HalUARTWrite(0,&x4, sizeof(x4)); 
   1095                    else if(p2p_test_NwkState ==DEV_NWK_DISC)   
   1096                      HalUARTWrite(0,&x5, sizeof(x5));   
   1097                    else if(p2p_test_NwkState ==DEV_NWK_JOINING)   
   1098                      HalUARTWrite(0,&x6, sizeof(x6));
   1099                    else if(p2p_test_NwkState ==DEV_NWK_REJOIN)   
   1100                      HalUARTWrite(0,&x7, sizeof(x7)); 
   1101                    else if(p2p_test_NwkState ==DEV_END_DEVICE_UNAUTH)   
   1102                      HalUARTWrite(0,&x8, sizeof(x8));   
   1103                    else if(p2p_test_NwkState ==DEV_COORD_STARTING)   
   1104                      HalUARTWrite(0,&x9, sizeof(x9));      
   1105                    else if(p2p_test_NwkState ==DEV_NWK_ORPHAN)   
   \                     ??p2p_test_ProcessEvent_3:
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   640A         XRL     A,#0xa
   \   000070   7012         JNZ     ??p2p_test_ProcessEvent_4
   1106                      HalUARTWrite(0,&x10, sizeof(x10));           
   \   000072                ; Setup parameters for call to function HalUARTWrite
   \   000072   7C01         MOV     R4,#0x1
   \   000074   7D00         MOV     R5,#0x0
   \   000076   740A         MOV     A,#0xa
   \                     ??p2p_test_ProcessEvent_5:
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   AA82         MOV     R2,DPL
   \   00007D   AB83         MOV     R3,DPH
   \   00007F   7900         MOV     R1,#0x0
   \   000081   12....       LCALL   ??HalUARTWrite?relay
   1107          #endif 
   1108                    break;
   1109          
   1110                  default:
   1111                    break;
   1112                }
   1113          
   1114                // Release the memory
   1115                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??p2p_test_ProcessEvent_4:
   \   000084                ; Setup parameters for call to function osal_msg_deallocate
   \   000084   AA..         MOV     R2,?V0 + 0
   \   000086   AB..         MOV     R3,?V0 + 1
   \   000088   12....       LCALL   ??osal_msg_deallocate?relay
   1116          
   1117                // Next
   1118                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( p2p_test_TaskID );
   \   00008B                ; Setup parameters for call to function osal_msg_receive
   \                     ??p2p_test_ProcessEvent_2:
   \   00008B   90....       MOV     DPTR,#p2p_test_TaskID
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   F9           MOV     R1,A
   \   000090   12....       LCALL   ??osal_msg_receive?relay
   \   000093   8A..         MOV     ?V0 + 0,R2
   \   000095   8B..         MOV     ?V0 + 1,R3
   \   000097   E5..         MOV     A,?V0 + 0
   \   000099   7002         JNZ     ??p2p_test_ProcessEvent_6
   \   00009B   E5..         MOV     A,?V0 + 1
   \                     ??p2p_test_ProcessEvent_6:
   \   00009D   7003         JNZ     $+5
   \   00009F   02....       LJMP    ??p2p_test_ProcessEvent_7 & 0xFFFF
   \   0000A2   85..82       MOV     DPL,?V0 + 0
   \   0000A5   85..83       MOV     DPH,?V0 + 1
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for p2p_test_ProcessEvent>_0`:
   \   0000AC   00           DB        0
   \   0000AD   04           DB        4
   \   0000AE   01           DB        1
   \   0000AF   ....         DW        ??p2p_test_ProcessEvent_8
   \   0000B1   1A           DB        26
   \   0000B2   ....         DW        ??p2p_test_ProcessEvent_9
   \   0000B4   D1           DB        209
   \   0000B5   ....         DW        ??p2p_test_ProcessEvent_10
   \   0000B7   D3           DB        211
   \   0000B8   ....         DW        ??p2p_test_ProcessEvent_11
   \   0000BA   ....         DW        ??p2p_test_ProcessEvent_4
   \                     ??p2p_test_ProcessEvent_11:
   \   0000BC                ; Setup parameters for call to function p2p_test_ProcessZDOMsgs
   \   0000BC   AA..         MOV     R2,?V0 + 0
   \   0000BE   AB..         MOV     R3,?V0 + 1
   \   0000C0   12....       LCALL   ??p2p_test_ProcessZDOMsgs?relay
   \   0000C3   80BF         SJMP    ??p2p_test_ProcessEvent_4
   \                     ??p2p_test_ProcessEvent_8:
   \   0000C5   74EE         MOV     A,#-0x12
   \   0000C7   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0000CA                ; Setup parameters for call to function p2p_test_RecvFromUart
   \   0000CA   85..82       MOV     DPL,?V0 + 0
   \   0000CD   85..83       MOV     DPH,?V0 + 1
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   0000D5   12....       LCALL   ??p2p_test_RecvFromUart?relay
   \   0000D8   80AA         SJMP    ??p2p_test_ProcessEvent_4
   \                     ??p2p_test_ProcessEvent_9:
   \   0000DA                ; Setup parameters for call to function p2p_test_MessageMSGCB
   \   0000DA   AA..         MOV     R2,?V0 + 0
   \   0000DC   AB..         MOV     R3,?V0 + 1
   \   0000DE   12....       LCALL   ??p2p_test_MessageMSGCB?relay
   \   0000E1   80A1         SJMP    ??p2p_test_ProcessEvent_4
   \                     ??p2p_test_ProcessEvent_10:
   \   0000E3   85..82       MOV     DPL,?V0 + 0
   \   0000E6   85..83       MOV     DPH,?V0 + 1
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   90....       MOV     DPTR,#p2p_test_NwkState
   \   0000EE   F0           MOVX    @DPTR,A
   \   0000EF   6406         XRL     A,#0x6
   \   0000F1   7007         JNZ     ??p2p_test_ProcessEvent_12
   \   0000F3                ; Setup parameters for call to function osal_start_timerEx
   \   0000F3   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   0000F6   EC           MOV     A,R4
   \   0000F7   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_12:
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   6401         XRL     A,#0x1
   \   0000FD   7029         JNZ     ??p2p_test_ProcessEvent_13
   \   0000FF                ; Setup parameters for call to function osal_stop_timerEx
   \   0000FF   7A80         MOV     R2,#-0x80
   \   000101   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000104                ; Setup parameters for call to function osal_stop_timerEx
   \   000104   7A00         MOV     R2,#0x0
   \   000106   7B01         MOV     R3,#0x1
   \   000108   12....       LCALL   ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   00010B                ; Setup parameters for call to function HalUARTWrite
   \   00010B   7C01         MOV     R4,#0x1
   \   00010D   7D00         MOV     R5,#0x0
   \   00010F   7402         MOV     A,#0x2
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   AA82         MOV     R2,DPL
   \   000116   AB83         MOV     R3,DPH
   \   000118   7900         MOV     R1,#0x0
   \   00011A   12....       LCALL   ??HalUARTWrite?relay
   \   00011D   C2AF         CLR     0xa8.7
   \   00011F   75C9AB       MOV     0xc9,#-0x55
   \   000122   75C95B       MOV     0xc9,#0x5b
   \                     ??p2p_test_ProcessEvent_14:
   \   000125   00           NOP
   \   000126   80FD         SJMP    ??p2p_test_ProcessEvent_14
   \                     ??p2p_test_ProcessEvent_13:
   \   000128   E0           MOVX    A,@DPTR
   \   000129   6409         XRL     A,#0x9
   \   00012B   7008         JNZ     ??p2p_test_ProcessEvent_15
   \   00012D                ; Setup parameters for call to function osal_start_timerEx
   \   00012D   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000130   7403         MOV     A,#0x3
   \   000132   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_15:
   \   000135   E0           MOVX    A,@DPTR
   \   000136   7009         JNZ     ??p2p_test_ProcessEvent_16
   \   000138                ; Setup parameters for call to function HalUARTWrite
   \   000138   7C01         MOV     R4,#0x1
   \   00013A   7D00         MOV     R5,#0x0
   \   00013C   7404         MOV     A,#0x4
   \   00013E   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_16:
   \   000141   6402         XRL     A,#0x2
   \   000143   7009         JNZ     ??p2p_test_ProcessEvent_17
   \   000145                ; Setup parameters for call to function HalUARTWrite
   \   000145   7C01         MOV     R4,#0x1
   \   000147   7D00         MOV     R5,#0x0
   \   000149   7405         MOV     A,#0x5
   \   00014B   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_17:
   \   00014E   E0           MOVX    A,@DPTR
   \   00014F   6403         XRL     A,#0x3
   \   000151   7009         JNZ     ??p2p_test_ProcessEvent_18
   \   000153                ; Setup parameters for call to function HalUARTWrite
   \   000153   7C01         MOV     R4,#0x1
   \   000155   7D00         MOV     R5,#0x0
   \   000157   7406         MOV     A,#0x6
   \   000159   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_18:
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   6404         XRL     A,#0x4
   \   00015F   7009         JNZ     ??p2p_test_ProcessEvent_19
   \   000161                ; Setup parameters for call to function HalUARTWrite
   \   000161   7C01         MOV     R4,#0x1
   \   000163   7D00         MOV     R5,#0x0
   \   000165   7407         MOV     A,#0x7
   \   000167   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_19:
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   6405         XRL     A,#0x5
   \   00016D   7009         JNZ     ??p2p_test_ProcessEvent_20
   \   00016F                ; Setup parameters for call to function HalUARTWrite
   \   00016F   7C01         MOV     R4,#0x1
   \   000171   7D00         MOV     R5,#0x0
   \   000173   7408         MOV     A,#0x8
   \   000175   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   \                     ??p2p_test_ProcessEvent_20:
   \   000178   E0           MOVX    A,@DPTR
   \   000179   6408         XRL     A,#0x8
   \   00017B   6003         JZ      $+5
   \   00017D   02....       LJMP    ??p2p_test_ProcessEvent_3 & 0xFFFF
   \   000180                ; Setup parameters for call to function HalUARTWrite
   \   000180   7C01         MOV     R4,#0x1
   \   000182   7D00         MOV     R5,#0x0
   \   000184   7409         MOV     A,#0x9
   \   000186   02....       LJMP    ??p2p_test_ProcessEvent_5 & 0xFFFF
   1119              }
   1120          
   1121              // return unprocessed events
   1122              return (events ^ SYS_EVENT_MSG);
   \                     ??p2p_test_ProcessEvent_7:
   \   000189   EE           MOV     A,R6
   \   00018A   FA           MOV     R2,A
   \   00018B   7480         MOV     A,#-0x80
   \                     ??p2p_test_ProcessEvent_21:
   \   00018D   6F           XRL     A,R7
   \                     ??p2p_test_ProcessEvent_22:
   \   00018E   FB           MOV     R3,A
   \   00018F   8045         SJMP    ??p2p_test_ProcessEvent_23
   1123            }
   1124            
   1125            if ( events & p2p_test_SEND_MAINTAIN_MSG_EVT)
   \                     ??p2p_test_ProcessEvent_1:
   \   000191   EE           MOV     A,R6
   \   000192   A2E0         MOV     C,0xE0 /* A   */.0
   \   000194   500A         JNC     ??p2p_test_ProcessEvent_24
   1126            {
   1127              p2p_test_SendRelationPkt();
   \   000196                ; Setup parameters for call to function p2p_test_SendRelationPkt
   \   000196   12....       LCALL   ??p2p_test_SendRelationPkt?relay
   1128              //p2p_test_SendResetRelativeTime();
   1129              // return unprocessed events
   1130              return (events ^ p2p_test_SEND_MAINTAIN_MSG_EVT);    
   \   000199   7401         MOV     A,#0x1
   \                     ??p2p_test_ProcessEvent_25:
   \   00019B   6E           XRL     A,R6
   \   00019C   FA           MOV     R2,A
   \   00019D   EF           MOV     A,R7
   \   00019E   80EE         SJMP    ??p2p_test_ProcessEvent_22
   1131            }
   1132          
   1133           /* if ( events & p2p_test_SEND_RAIN_FREQ_MSG_EVT)
   1134            {
   1135              p2p_test_SendRainTimeFreqAndRequire( FREQ );
   1136              // return unprocessed events
   1137              return (events ^ p2p_test_SEND_RAIN_FREQ_MSG_EVT);    
   1138            }
   1139            
   1140            if ( events & p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT )
   1141            {
   1142              p2p_test_SendSoilHumidityTimeFreqAndRequire( FREQ );
   1143              // return unprocessed events
   1144              return (events ^ p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT);
   1145            }  
   1146            
   1147          
   1148            
   1149            if ( events & p2p_test_SEND_VCC_VALUE_FREQ_MSG_EVT )
   1150            {
   1151              p2p_test_Send_VCC_VALUE( FREQ );
   1152              // return unprocessed events
   1153              return (events ^ p2p_test_SEND_VCC_VALUE_FREQ_MSG_EVT);
   1154            }  
   1155           */ 
   1156            if( events & p2p_test_SEND_WATER_GAGE_MSG_EVT )
   \                     ??p2p_test_ProcessEvent_24:
   \   0001A0   5480         ANL     A,#0x80
   \   0001A2   600F         JZ      ??p2p_test_ProcessEvent_26
   1157            {
   1158              p2p_test_Send_Water_Gage(FREQ,WaterGageUnit);
   \   0001A4                ; Setup parameters for call to function p2p_test_Send_Water_Gage
   \   0001A4   90....       MOV     DPTR,#WaterGageUnit
   \   0001A7   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   0001AA   7900         MOV     R1,#0x0
   \   0001AC   12....       LCALL   ??p2p_test_Send_Water_Gage?relay
   1159              return (events ^ p2p_test_SEND_WATER_GAGE_MSG_EVT);
   \   0001AF   7480         MOV     A,#-0x80
   \   0001B1   80E8         SJMP    ??p2p_test_ProcessEvent_25
   1160            }
   1161            
   1162           /* if ( events &  p2p_test_SEND_ACCELEROMETER_FREQ_MSG_EVT )
   1163            {
   1164              p2p_test_SendAccelerometerTimeFreqAndRequire( FREQ );
   1165              // return unprocessed events
   1166              return (events ^ p2p_test_SEND_ACCELEROMETER_FREQ_MSG_EVT);
   1167            } */
   1168            
   1169             //自己编写
   1170            //适合SendWaterGageTimeFreq大于65s的情况
   1171            if (events & p2p_test_START_WATER_GAGE_TIME_MSG_EVT)
   \                     ??p2p_test_ProcessEvent_26:
   \   0001B3   EE           MOV     A,R6
   \   0001B4   5410         ANL     A,#0x10
   \   0001B6   6007         JZ      ??p2p_test_ProcessEvent_27
   1172            {
   1173              start_Water_gage_timer();
   \   0001B8                ; Setup parameters for call to function start_Water_gage_timer
   \   0001B8   12....       LCALL   ??start_Water_gage_timer?relay
   1174             return (events ^ p2p_test_START_WATER_GAGE_TIME_MSG_EVT);
   \   0001BB   7410         MOV     A,#0x10
   \   0001BD   80DC         SJMP    ??p2p_test_ProcessEvent_25
   1175            }
   1176            
   1177           /* if (events &  p2p_test_START_SOIL_HUMIDITY_TIME_MSG_EVT)
   1178            {
   1179              start_Soil_humidity_timer();
   1180             return (events ^  p2p_test_START_SOIL_HUMIDITY_TIME_MSG_EVT);
   1181            }
   1182          */
   1183            if (events &  p2p_test_CHECK_WATER_GAGE_CHARGE_MSG_EVT)
   \                     ??p2p_test_ProcessEvent_27:
   \   0001BF   7401         MOV     A,#0x1
   \   0001C1   5F           ANL     A,R7
   \   0001C2   F9           MOV     R1,A
   \   0001C3   E4           CLR     A
   \   0001C4   7001         JNZ     ??p2p_test_ProcessEvent_28
   \   0001C6   E9           MOV     A,R1
   \                     ??p2p_test_ProcessEvent_28:
   \   0001C7   6009         JZ      ??p2p_test_ProcessEvent_29
   1184            {
   1185              check_water_gage_charge();
   \   0001C9                ; Setup parameters for call to function check_water_gage_charge
   \   0001C9   12....       LCALL   ??check_water_gage_charge?relay
   1186             return (events ^  p2p_test_CHECK_WATER_GAGE_CHARGE_MSG_EVT);
   \   0001CC   EE           MOV     A,R6
   \   0001CD   FA           MOV     R2,A
   \   0001CE   7401         MOV     A,#0x1
   \   0001D0   80BB         SJMP    ??p2p_test_ProcessEvent_21
   1187            }  
   1188            
   1189           
   1190             
   1191            // Discard unknown events
   1192            return 0;
   \                     ??p2p_test_ProcessEvent_29:
   \   0001D2   7A00         MOV     R2,#0x0
   \   0001D4   7B00         MOV     R3,#0x0
   \                     ??p2p_test_ProcessEvent_23:
   \   0001D6   740B         MOV     A,#0xb
   \   0001D8                REQUIRE ?Subroutine59
   \   0001D8                REQUIRE _A_IEN0
   \   0001D8                REQUIRE WDCTL
   \   0001D8                ; // Fall through to label ?Subroutine59
   1193          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine59_0:
   \   000003   7F04         MOV     R7,#0x4
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   7CE8         MOV     R4,#-0x18
   \   000002   7D03         MOV     R5,#0x3
   \   000004   7A01         MOV     R2,#0x1
   \   000006   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000009                ; Setup parameters for call to function HalUARTWrite
   \   000009                ; Setup parameters for call to function HalUARTWrite
   \   000009   02....       LJMP    ??Subroutine55_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \   000001                ; Setup parameters for call to function HalUARTWrite
   \                     ??Subroutine55_0:
   \   000001   7C01         MOV     R4,#0x1
   \   000003   7D00         MOV     R5,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   7B00         MOV     R3,#0x0
   \                     ??Subroutine45_0:
   \   000002   90....       MOV     DPTR,#p2p_test_TaskID
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   12....       LCALL   ??osal_stop_timerEx?relay
   \   00000A   22           RET
   1194          
   1195          /*********************************************************************
   1196           * Event Generation Functions
   1197           */
   1198          /*********************************************************************
   1199           * @fn      p2p_test_ProcessZDOMsgs()
   1200           *
   1201           * @brief   Process response messages
   1202           *
   1203           * @param   none
   1204           *
   1205           * @return  none
   1206           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1207          void p2p_test_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
   \                     p2p_test_ProcessZDOMsgs:
   1208          { 
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1209            switch ( inMsg->clusterID )
   \   000005   EA           MOV     A,R2
   \   000006   240C         ADD     A,#0xc
   \   000008   F582         MOV     DPL,A
   \   00000A   EB           MOV     A,R3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F583         MOV     DPH,A
   \   00000F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000012   78..         MOV     R0,#?V0 + 0
   \   000014   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for p2p_test_ProcessZDOMsgs>_0`:
   \   000017   0000         DW        0
   \   000019   0200         DW        2
   \   00001B   0680         DW        32774
   \   00001D   ....         DW        ??p2p_test_ProcessZDOMsgs_0
   \   00001F   2080         DW        32800
   \   000021   ....         DW        ??p2p_test_ProcessZDOMsgs_1
   \   000023   ....         DW        ??p2p_test_ProcessZDOMsgs_2
   1210            {
   1211              case End_Device_Bind_rsp:
   1212                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
   \                     ??p2p_test_ProcessZDOMsgs_1:
   \   000025   EA           MOV     A,R2
   \   000026   2411         ADD     A,#0x11
   \   000028   F582         MOV     DPL,A
   \   00002A   EB           MOV     A,R3
   \   00002B   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   00002E   F8           MOV     R0,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F583         MOV     DPH,A
   \   000033   8882         MOV     DPL,R0
   \   000035   E0           MOVX    A,@DPTR
   \   000036   7009         JNZ     ??p2p_test_ProcessZDOMsgs_3
   1213                {
   1214                  // Light LED
   1215                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000038                ; Setup parameters for call to function HalLedSet
   \   000038   7A01         MOV     R2,#0x1
   \                     ??p2p_test_ProcessZDOMsgs_4:
   \   00003A   7908         MOV     R1,#0x8
   \   00003C   12....       LCALL   ??HalLedSet?relay
   \   00003F   8051         SJMP    ??p2p_test_ProcessZDOMsgs_2
   1216                }
   1217          #if defined(BLINK_LEDS)
   1218                else
   1219                {
   1220                  // Flash LED to show failure
   1221                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??p2p_test_ProcessZDOMsgs_3:
   \   000041                ; Setup parameters for call to function HalLedSet
   \   000041   7A04         MOV     R2,#0x4
   \   000043   80F5         SJMP    ??p2p_test_ProcessZDOMsgs_4
   1222                }
   1223          #endif
   1224                break;
   1225          
   1226              case Match_Desc_rsp:
   1227                {
   1228                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   \                     ??p2p_test_ProcessZDOMsgs_0:
   \   000045                ; Setup parameters for call to function ZDO_ParseEPListRsp
   \   000045   12....       LCALL   ??ZDO_ParseEPListRsp?relay
   \   000048   8A..         MOV     ?V0 + 0,R2
   \   00004A   8B..         MOV     ?V0 + 1,R3
   \   00004C   AE..         MOV     R6,?V0 + 0
   \   00004E   AF..         MOV     R7,?V0 + 1
   1229                  if ( pRsp )
   \   000050   EE           MOV     A,R6
   \   000051   7001         JNZ     ??p2p_test_ProcessZDOMsgs_5
   \   000053   EF           MOV     A,R7
   \                     ??p2p_test_ProcessZDOMsgs_5:
   \   000054   603C         JZ      ??p2p_test_ProcessZDOMsgs_2
   1230                  {
   1231                    if ( pRsp->status == ZSuccess && pRsp->cnt )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   702E         JNZ     ??p2p_test_ProcessZDOMsgs_6
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6028         JZ      ??p2p_test_ProcessZDOMsgs_6
   1232                    {
   1233                      p2p_test_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000063   7402         MOV     A,#0x2
   \   000065   90....       MOV     DPTR,#(p2p_test_DstAddr + 2)
   \   000068   F0           MOVX    @DPTR,A
   1234                      p2p_test_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   A3           INC     DPTR
   \   00006E   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000071   90....       MOV     DPTR,#p2p_test_DstAddr
   \   000074   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   1235                      // Take the first endpoint, Can be changed to search through endpoints
   1236                      p2p_test_DstAddr.endPoint = pRsp->epList[0];
   \                     ??CrossCallReturnLabel_86:
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   90....       MOV     DPTR,#(p2p_test_DstAddr + 3)
   \   000083   F0           MOVX    @DPTR,A
   1237          
   1238                      // Light LED
   1239                      HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000084                ; Setup parameters for call to function HalLedSet
   \   000084   7A01         MOV     R2,#0x1
   \   000086   7908         MOV     R1,#0x8
   \   000088   12....       LCALL   ??HalLedSet?relay
   1240                    }
   1241                    osal_mem_free( pRsp );
   \                     ??p2p_test_ProcessZDOMsgs_6:
   \   00008B                ; Setup parameters for call to function osal_mem_free
   \   00008B   EE           MOV     A,R6
   \   00008C   FA           MOV     R2,A
   \   00008D   EF           MOV     A,R7
   \   00008E   FB           MOV     R3,A
   \   00008F   12....       LCALL   ??osal_mem_free?relay
   1242                  }
   1243                }
   1244                break;
   1245            }
   1246          }
   \                     ??p2p_test_ProcessZDOMsgs_2:
   \   000092   02....       LJMP    ?Subroutine60 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 3
   \                     ??Subroutine35_0:
   \   000004   3400         ADDC    A,#0x0
   \   000006   F583         MOV     DPH,A
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1247          
   1248          
   1249          
   1250          /*********************************************************************
   1251           * LOCAL FUNCTIONS
   1252           */
   1253          
   1254          /*********************************************************************
   1255           * @fn      p2p_test_MessageMSGCB
   1256           *
   1257           * @brief   Data message processor callback.  This function processes
   1258           *          any incoming data - probably from other devices.  So, based
   1259           *          on cluster ID, perform the intended action.
   1260           *
   1261           * @param   none
   1262           *
   1263           * @return  none
   1264           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1265          void p2p_test_MessageMSGCB( afIncomingMSGPacket_t *pkt )
   \                     p2p_test_MessageMSGCB:
   1266          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1267            uint16 temp_shortaddr;
   1268            switch ( pkt->clusterId )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F5..         MOV     ?V0 + 0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   702A         JNZ     ??p2p_test_MessageMSGCB_0
   \   000014   E5..         MOV     A,?V0 + 0
   \   000016   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for p2p_test_MessageMSGCB>_0`:
   \   000019   00           DB        0
   \   00001A   02           DB        2
   \   00001B   02           DB        2
   \   00001C   ....         DW        ??p2p_test_MessageMSGCB_1
   \   00001E   04           DB        4
   \   00001F   ....         DW        ??p2p_test_MessageMSGCB_2
   \   000021   ....         DW        ??p2p_test_MessageMSGCB_0
   1269            {
   1270              case p2p_test_CLUSTERID:
   1271                // "the" message
   1272                //p2p_test_SendToUart((uint8*)pkt->cmd.Data, pkt->cmd.DataLength);
   1273                //HalUARTWrite( 0, (uint8*)pkt->cmd.Data, pkt->cmd.DataLength );
   1274                break;
   1275              case p2p_test_108ID:
   1276                p2p_test_recv_108clusterId(pkt->cmd.Data, pkt->cmd.DataLength);
   \                     ??p2p_test_MessageMSGCB_1:
   \   000023                ; Setup parameters for call to function p2p_test_recv_108clusterId
   \   000023   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000026   12....       LCALL   ??p2p_test_recv_108clusterId?relay
   \   000029   8013         SJMP    ??p2p_test_MessageMSGCB_0
   1277                //SendRainCountFreq=(pkt->cmd.Data)[0];
   1278                break;
   1279              case p2p_test_RelationMsg:
   1280                temp_shortaddr=pkt->srcAddr.addr.shortAddr;
   1281                //printf short_addr
   1282               // p2p_test_SendToUart((uint8 *)&temp_shortaddr,sizeof(temp_shortaddr));
   1283               // HalUARTWrite(0,(uint8 *)&temp_shortaddr,sizeof(temp_shortaddr));
   1284                p2p_test_recv_RelationMsgclusterId(pkt->cmd.Data,pkt->cmd.DataLength,temp_shortaddr);
   \                     ??p2p_test_MessageMSGCB_2:
   \   00002B                ; Setup parameters for call to function p2p_test_recv_RelationMsgclusterId
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000038   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00003B   12....       LCALL   ??p2p_test_recv_RelationMsgclusterId?relay
   1285                break;
   1286              
   1287            }
   1288          }
   \                     ??p2p_test_MessageMSGCB_0:
   \   00003E   02....       LJMP    ?Subroutine60 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   EA           MOV     A,R2
   \   000001   2413         ADD     A,#0x13
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   EA           MOV     A,R2
   \   00000D   2415         ADD     A,#0x15
   \   00000F   F582         MOV     DPL,A
   \   000011   EB           MOV     A,R3
   \   000012   3400         ADDC    A,#0x0
   \   000014   F583         MOV     DPH,A
   \   000016                REQUIRE ?Subroutine54
   \   000016                ; // Fall through to label ?Subroutine54
   1289          
   1290          
   1291          /*********************************************************************
   1292           * @fn      p2p_test_SendTheMessage
   1293           *
   1294           * @brief   Send "the" message.
   1295           *
   1296           * @param   none
   1297           *
   1298           * @return  none
   1299           */
   1300          /*
   1301          void p2p_test_SendTheMessage( void )
   1302          {
   1303             //char p2p_msg[] = "Hello World ";
   1304             if ( AF_DataRequest( &p2p_test_DstAddr, &p2p_test_epDesc,
   1305                                 p2p_test_CLUSTERID,
   1306                                 6,
   1307                                 (byte *)&p2p_msg,
   1308                                 &p2p_test_TransID,
   1309                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   1310          
   1311            {
   1312              // Successfully requested to be sent.  
   1313          //    HalUARTWrite( 0,  (uint8 *)p2p_msg, (byte)osal_strlen( p2p_msg ) + 1);
   1314          
   1315            } 
   1316            
   1317            else
   1318            {
   1319              // Error occurred in request to send.
   1320            }
   1321          }
   1322          */
   1323          
   1324          /*********************************************************************
   1325           * @fn      p2p_test_recv_108clusterId
   1326           *
   1327           * @brief   
   1328           *
   1329           * @param   none
   1330           *
   1331           * @return  none
   1332           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1333          void p2p_test_recv_108clusterId(uint8 *pkt, uint8 length)
   \                     p2p_test_recv_108clusterId:
   1334          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   1335            AppHead_t *AppHead = (AppHead_t *)pkt;
   1336            //AppHead->AckRequire;
   1337            if(AppHead->type == TYPE_SENSOR ||(AppHead->type == TYPE_ACK && AppHead->TypeCode==TYPE_ACK_UP) )
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   540F         ANL     A,#0xf
   \   000015   600E         JZ      ??p2p_test_recv_108clusterId_0
   \   000017   E0           MOVX    A,@DPTR
   \   000018   540F         ANL     A,#0xf
   \   00001A   640F         XRL     A,#0xf
   \   00001C   700D         JNZ     ??p2p_test_recv_108clusterId_1
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6003         JZ      $+5
   \   000022   02....       LJMP    ??p2p_test_recv_108clusterId_2 & 0xFFFF
   1338            {
   1339              //if(AppHead->TypeCode == TYPE_CODE_SENSOR_RAIN)//may be is not need,TYPE_SENSOR all to UART 
   1340              //{
   1341                p2p_test_SendToUart(pkt, length);
   \                     ??p2p_test_recv_108clusterId_0:
   \   000025                ; Setup parameters for call to function p2p_test_SendToUart
   \   000025   12....       LCALL   ??p2p_test_SendToUart?relay
   1342                return;
   \   000028   02....       LJMP    ??p2p_test_recv_108clusterId_2 & 0xFFFF
   1343              //}
   1344            }
   1345            else if(AppHead->type == TYPE_COMMAND)
   \                     ??p2p_test_recv_108clusterId_1:
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   540F         ANL     A,#0xf
   \   00002E   6408         XRL     A,#0x8
   \   000030   6003         JZ      $+5
   \   000032   02....       LJMP    ??p2p_test_recv_108clusterId_2 & 0xFFFF
   1346            {
   1347              uint8 temp_arm_id,temp_zigbee_id;
   1348              temp_arm_id=(pkt[4]&0x0f);
   1349              temp_zigbee_id=(pkt[5]&0xf0)>>4;
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   C4           SWAP    A
   \   00003C   540F         ANL     A,#0xf
   \   00003E   FC           MOV     R4,A
   1350              uint16 SerialNumber =BUILD_UINT16(AppHead->sn[1],AppHead->sn[0]);
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000049   12....       LCALL   ?Subroutine23 & 0xFFFF
   1351              //uint16 SerialNumber =BUILD_UINT16(pkt[3],pkt[2]);
   1352              
   1353              if(ARM_ID==temp_arm_id && Zigbee_ID==temp_zigbee_id)
   \                     ??CrossCallReturnLabel_64:
   \   00004C   90....       MOV     DPTR,#ARM_ID
   \   00004F   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   540F         ANL     A,#0xf
   \   000057   6A           XRL     A,R2
   \   000058   6003         JZ      $+5
   \   00005A   02....       LJMP    ??p2p_test_recv_108clusterId_2 & 0xFFFF
   \   00005D   90....       MOV     DPTR,#Zigbee_ID
   \   000060   E0           MOVX    A,@DPTR
   \   000061   6C           XRL     A,R4
   \   000062   6003         JZ      $+5
   \   000064   02....       LJMP    ??p2p_test_recv_108clusterId_2 & 0xFFFF
   1354              {
   1355              //  if(AppHead->TypeCode == TYPE_CODE_COMMAND_MODIFY_K)
   1356            //    {
   1357                  uint8 sensor_type = pkt[6];
   \   000067   85..82       MOV     DPL,?V0 + 2
   \   00006A   8B83         MOV     DPH,R3
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   F0           MOVX    @DPTR,A
   1358                  uint16 freq = BUILD_UINT16(pkt[7], 0x00);
   \   00007A   85..82       MOV     DPL,?V0 + 2
   \   00007D   8B83         MOV     DPH,R3
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   FE           MOV     R6,A
   1359                  AppHeadNodeId_t *AppHeadNodeId=(AppHeadNodeId_t *)osal_msg_allocate(sizeof(AppHeadNodeId_t));
   \   000088                ; Setup parameters for call to function osal_msg_allocate
   \   000088   7A06         MOV     R2,#0x6
   \   00008A   7B00         MOV     R3,#0x0
   \   00008C   12....       LCALL   ??osal_msg_allocate?relay
   \   00008F   8A..         MOV     ?V0 + 6,R2
   \   000091   8B..         MOV     ?V0 + 7,R3
   1360                  //fill_AppHead((AppHead_t *)&AppHeadNodeId->AppHead,ACK_NO, MAIN_VERSION, SUB_VERSION,TYPE_ACK,TYPE_ACK_UP);
   1361                  fill_AppHead_sn((AppHead_t *)&AppHeadNodeId->AppHead,ACK_NO, MAIN_VERSION, SUB_VERSION,TYPE_ACK,TYPE_ACK_UP, SerialNumber);
   \   000093                ; Setup parameters for call to function fill_AppHead_sn
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   75..00       MOV     ?V0 + 0,#0x0
   \   00009B   78..         MOV     R0,#?V0 + 0
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A0   75..0F       MOV     ?V0 + 0,#0xf
   \   0000A3   78..         MOV     R0,#?V0 + 0
   \   0000A5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A8   7D01         MOV     R5,#0x1
   \   0000AA   7C00         MOV     R4,#0x0
   \   0000AC   7900         MOV     R1,#0x0
   \   0000AE   12....       LCALL   ??fill_AppHead_sn?relay
   \   0000B1   7404         MOV     A,#0x4
   \   0000B3   12....       LCALL   ?DEALLOC_XSTACK8
   1362          
   1363                  AppHeadNodeId->NodeId.r=RES;
   \   0000B6   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   0000B9   C0E0         PUSH    A
   \   0000BB   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000BE   D0E0         POP     A
   \   0000C0   12....       LCALL   ?Subroutine39 & 0xFFFF
   1364                  AppHeadNodeId->NodeId.ARM_id=ARM_ID;
   \                     ??CrossCallReturnLabel_119:
   \   0000C3   C0E0         PUSH    A
   \   0000C5   74F0         MOV     A,#-0x10
   \   0000C7   5A           ANL     A,R2
   \   0000C8   FA           MOV     R2,A
   \   0000C9   D0E0         POP     A
   \   0000CB   4A           ORL     A,R2
   \   0000CC   8882         MOV     DPL,R0
   \   0000CE   8983         MOV     DPH,R1
   \   0000D0   F0           MOVX    @DPTR,A
   1365                  AppHeadNodeId->NodeId.Zigbee_id=Zigbee_ID;//
   \   0000D1   E5..         MOV     A,?V0 + 6
   \   0000D3   2405         ADD     A,#0x5
   \   0000D5   08           INC     R0
   \   0000D6   E5..         MOV     A,?V0 + 7
   \   0000D8   3400         ADDC    A,#0x0
   \   0000DA   F9           MOV     R1,A
   \   0000DB   90....       MOV     DPTR,#Zigbee_ID
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   C4           SWAP    A
   \   0000E0   54F0         ANL     A,#0xf0
   \   0000E2   C0E0         PUSH    A
   \   0000E4   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000E7   D0E0         POP     A
   \   0000E9   4A           ORL     A,R2
   \   0000EA   F0           MOVX    @DPTR,A
   1366                //  uint16 freq=(uint16)pkt[7]
   1367                  
   1368                  switch (sensor_type)
   \   0000EB   85..82       MOV     DPL,?XSP + 0
   \   0000EE   85..83       MOV     DPH,?XSP + 1
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for p2p_test_recv_108clusterId>_0`:
   \   0000F5   00           DB        0
   \   0000F6   09           DB        9
   \   0000F7   03           DB        3
   \   0000F8   ....         DW        ??p2p_test_recv_108clusterId_3
   \   0000FA   07           DB        7
   \   0000FB   ....         DW        ??p2p_test_recv_108clusterId_4
   \   0000FD   09           DB        9
   \   0000FE   ....         DW        ??p2p_test_recv_108clusterId_5
   \   000100   0A           DB        10
   \   000101   ....         DW        ??p2p_test_recv_108clusterId_6
   \   000103   0B           DB        11
   \   000104   ....         DW        ??p2p_test_recv_108clusterId_7
   \   000106   0C           DB        12
   \   000107   ....         DW        ??p2p_test_recv_108clusterId_8
   \   000109   0D           DB        13
   \   00010A   ....         DW        ??p2p_test_recv_108clusterId_9
   \   00010C   0E           DB        14
   \   00010D   ....         DW        ??p2p_test_recv_108clusterId_10
   \   00010F   11           DB        17
   \   000110   ....         DW        ??p2p_test_recv_108clusterId_11
   \   000112   ....         DW        ??CrossCallReturnLabel_13
   1369                  {
   1370                 /*   
   1371                 case COMMAND_TYPE_RAIN:               //雨量K值
   1372                    if( (freq & 0x0080) == 0 )          //或者右移7位
   1373                      SendRainTimeFreq = freq;
   1374                    else
   1375                    {
   1376                      freq = freq &0x007F;
   1377                      SendRainTimeFreq = freq*60 ;
   1378                    }
   1379                    //SendRainTimeFreq = freq;
   1380                    osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_RAIN_FREQ_MSG_EVT);
   1381                    SendRainRemainTime = 0;//send at once
   1382                    p2p_test_SendRainTimeFreqAndRequire(FREQ);   
   1383                    AppHeadNodeId->NodeId.sensor_type= RAIN_ID ;
   1384                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1385                    break;
   1386                    
   1387                  case COMMAND_TYPE_RAIN_KVALUE:         //雨量N值
   1388                    SendRainCountFreq = freq;
   1389                    RainCountNum = 0;//reset  
   1390                    AppHeadNodeId->NodeId.sensor_type= RAIN_ID ;
   1391                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1392                    break;
   1393                    
   1394                  case COMMAND_TYPE_SOIL_HUMIDITY:       //土壤湿度K值
   1395          
   1396                    SendSoilHumidityTimeFreq = freq*60;
   1397                    osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT);
   1398                    SendSoilHumidityRemainTime = 0;//send at once
   1399                    p2p_test_SendSoilHumidityTimeFreqAndRequire(FREQ); 
   1400                    AppHeadNodeId->NodeId.sensor_type= SOIL_ID ;
   1401                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1402                    break;
   1403                    
   1404                  case COMMAND_TYPE_VIBRATIO:             //振动K值
   1405                    SendAccelerometerTimeFreq=freq*60;
   1406                    osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_ACCELEROMETER_FREQ_MSG_EVT);
   1407                    SendAccelerometerRemainTime = 0;      //send at once
   1408                    AppHeadNodeId->NodeId.sensor_type= EARTHQUAKE_ID ;
   1409                    p2p_test_SendAccelerometerTimeFreqAndRequire(FREQ);
   1410                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1411                    break;
   1412                    */
   1413                    
   1414                  case COMMAND_TYPE_WATER_GAGE:            //水位K值
   1415          
   1416                    SendWaterGageTimeFreq= freq*60;
   \                     ??p2p_test_recv_108clusterId_3:
   \   000114   EE           MOV     A,R6
   \   000115   75F03C       MOV     B,#0x3c
   \   000118   A4           MUL     AB
   \   000119   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   00011C   12....       LCALL   ?Subroutine1 & 0xFFFF
   1417                    //osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_WATER_GAGE_MSG_EVT);
   1418                    //SendWaterGageRemainTime=0;
   1419                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1420                    //p2p_test_Send_Water_Gage(FREQ,WaterGageUnit);
   1421                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   \                     ??CrossCallReturnLabel_165:
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000122   90....       MOV     DPTR,#p2p_test_DstAddr
   \   000125   7404         MOV     A,#0x4
   \   000127   12....       LCALL   ?PUSH_XSTACK8_X
   \   00012A   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   00012D   12....       LCALL   ?DEALLOC_XSTACK8
   1422          #if DEBUG
   1423                    HalUARTWrite_uint16(SendWaterGageTimeFreq);
   \   000130                ; Setup parameters for call to function HalUARTWrite_uint16
   \   000130   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \                     ??p2p_test_recv_108clusterId_12:
   \   000133   12....       LCALL   ??Subroutine3_0 & 0xFFFF
   1424          #endif             
   1425                    break;
   1426                    
   1427                  case COMMAND_TYPE_WATER_HIGHTYPE:          //水位计数据类型
   1428                    WaterGageUnit = BUILD_UINT16(pkt[7],0x00 );
   1429                    //osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_WATER_GAGE_MSG_EVT);
   1430                    //SendWaterGageRemainTime=0;
   1431                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1432                    //p2p_test_Send_Water_Gage(FREQ,WaterGageUnit);
   1433                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1434          #if DEBUG
   1435                    HalUARTWrite_uint16(WaterGageUnit);
   1436          #endif          
   1437                    break;
   1438                    
   1439                  case COMMAND_TYPE_WATER_T:                  //水位计自适应采集周期增加间隔T取值
   1440                    Water_gage_time = BUILD_UINT16(pkt[7],0x00 )*60;   
   1441                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1442                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1443          #if DEBUG
   1444                    HalUARTWrite(0,&pkt[7], sizeof(pkt[7]));
   1445          #endif
   1446                    break;
   1447                    
   1448                  case COMMAND_TYPE_WATER_EDGE_A:              //水位计自适应边界取值A
   1449                    Water_gage_err_a = pkt[7];
   1450                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1451                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   1452          #if DEBUG
   1453                    HalUARTWrite(0,&Water_gage_err_a, sizeof(Water_gage_err_a));
   1454          #endif
   1455                    
   1456                    break;
   1457                    
   1458                  case COMMAND_TYPE_WATER_EDGE_B:               //水位计自适应边界取值B
   1459                    Water_gage_err_b = pkt[7];
   1460                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1461                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);          
   1462          #if DEBUG
   1463                    HalUARTWrite(0,&Water_gage_err_b, sizeof(Water_gage_err_b));
   1464          #endif
   1465                    break;
   1466                    
   1467                  case COMMAND_TYPE_WATER_EDGE_C:               //水位计自适应边界取值C
   1468                    Water_gage_err_c = pkt[7];
   1469                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1470                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);          
   1471          #if DEBUG
   1472                    HalUARTWrite(0,&Water_gage_err_c, sizeof(Water_gage_err_c));
   1473          #endif
   1474                    break;
   1475                    
   1476                  case COMMAND_TYPE_ZIGBEE_RESTART:             //zigbee重启的设置
   1477                    {
   1478                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1479                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);   
   1480                  
   1481          /*          Zigbee_Restart_Command_t *pkt_zst = (Zigbee_Restart_Command_t *)pkt;
   1482                 
   1483                    WaterGageUnit = pkt_zst->water_gage_type;
   1484                    SendWaterGageTimeFreq = pkt_zst-> water_gage_freq;
   1485                    Water_gage_time = pkt_zst-> water_gage_T;
   1486                    Water_gage_err_a = pkt_zst-> water_gage_A;
   1487                    Water_gage_err_b = pkt_zst-> water_gage_B;
   1488                    Water_gage_err_c = pkt_zst-> water_gage_C;  
   1489          */
   1490                   // osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_WATER_GAGE_MSG_EVT);
   1491                    WaterGageUnit = BUILD_UINT16(pkt[8],pkt[7]);
   1492                    SendWaterGageTimeFreq = BUILD_UINT16(pkt[10],pkt[9])*60;
   1493                    Water_gage_time = BUILD_UINT16(pkt[12],pkt[11])*60;
   1494                    Water_gage_err_a = pkt[13];
   1495                    Water_gage_err_b = pkt[14];
   1496                    Water_gage_err_c = pkt[15];
   1497                  
   1498          #if DEBUG
   1499                    HalUARTWrite_uint16(WaterGageUnit);
   1500                    HalUARTWrite_uint16(SendWaterGageTimeFreq);
   1501                    HalUARTWrite_uint16(Water_gage_time);
   1502                    HalUARTWrite(0,&Water_gage_err_a, sizeof(Water_gage_err_a));        
   1503                    HalUARTWrite(0,&Water_gage_err_b, sizeof(Water_gage_err_b));          
   1504                    HalUARTWrite(0,&Water_gage_err_c, sizeof(Water_gage_err_c));
   1505          #endif   
   1506                    }
   1507                    break ;
   1508                    
   1509                  case COMMAND_TYPE_ACCEPTANCE:
   1510                    acceptance = pkt[7] ;
   1511                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1512                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);          
   1513          #if DEBUG
   1514                    HalUARTWrite(0,&acceptance, sizeof(acceptance));
   1515          #endif
   1516                    break;
   1517                    
   1518                  case COMMAND_TYPE_ZIGBEE_RESTART_COMMAND:
   1519                    AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1520                    SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);          
   1521          #if DEBUG
   1522                    HalUARTWrite(0,&pkt[7], sizeof(pkt[7]));
   1523          #endif      
   1524                    halWait(100);
   1525                    SystemReset();
   1526                    
   1527                  default :
   1528                    break;
   1529                   
   1530                  }
   1531                  
   1532                  osal_msg_deallocate((uint8 *)AppHeadNodeId); 
   \                     ??CrossCallReturnLabel_13:
   \   000136                ; Setup parameters for call to function osal_msg_deallocate
   \   000136   AA..         MOV     R2,?V0 + 6
   \   000138   AB..         MOV     R3,?V0 + 7
   \   00013A   12....       LCALL   ??osal_msg_deallocate?relay
   1533                  return;
   \                     ??p2p_test_recv_108clusterId_2:
   \   00013D   7401         MOV     A,#0x1
   \   00013F   02....       LJMP    ?Subroutine53 & 0xFFFF
   \                     ??p2p_test_recv_108clusterId_4:
   \   000142   85..82       MOV     DPL,?V0 + 2
   \   000145   85..83       MOV     DPH,?V0 + 3
   \   000148   A3           INC     DPTR
   \   000149   A3           INC     DPTR
   \   00014A   A3           INC     DPTR
   \   00014B   A3           INC     DPTR
   \   00014C   A3           INC     DPTR
   \   00014D   A3           INC     DPTR
   \   00014E   A3           INC     DPTR
   \   00014F   E0           MOVX    A,@DPTR
   \   000150   90....       MOV     DPTR,#WaterGageUnit
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   E4           CLR     A
   \   000156   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015C   90....       MOV     DPTR,#p2p_test_DstAddr
   \   00015F   7404         MOV     A,#0x4
   \   000161   12....       LCALL   ?PUSH_XSTACK8_X
   \   000164   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016A                ; Setup parameters for call to function HalUARTWrite_uint16
   \   00016A   90....       MOV     DPTR,#WaterGageUnit
   \   00016D   80C4         SJMP    ??p2p_test_recv_108clusterId_12
   \                     ??p2p_test_recv_108clusterId_5:
   \   00016F   E5..         MOV     A,?V0 + 2
   \   000171   2407         ADD     A,#0x7
   \   000173   FE           MOV     R6,A
   \   000174   E5..         MOV     A,?V0 + 3
   \   000176   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000179   75F03C       MOV     B,#0x3c
   \   00017C   A4           MUL     AB
   \   00017D   90....       MOV     DPTR,#Water_gage_time
   \   000180   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000183   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000186   90....       MOV     DPTR,#p2p_test_DstAddr
   \   000189   7404         MOV     A,#0x4
   \   00018B   12....       LCALL   ?PUSH_XSTACK8_X
   \   00018E   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000191   12....       LCALL   ?DEALLOC_XSTACK8
   \   000194                ; Setup parameters for call to function HalUARTWrite
   \   000194   7C01         MOV     R4,#0x1
   \   000196   7D00         MOV     R5,#0x0
   \   000198   EE           MOV     A,R6
   \   000199   FA           MOV     R2,A
   \   00019A   EF           MOV     A,R7
   \   00019B   FB           MOV     R3,A
   \                     ??p2p_test_recv_108clusterId_13:
   \   00019C   7900         MOV     R1,#0x0
   \   00019E   12....       LCALL   ??HalUARTWrite?relay
   \   0001A1   8093         SJMP    ??CrossCallReturnLabel_13
   \                     ??p2p_test_recv_108clusterId_6:
   \   0001A3   85..82       MOV     DPL,?V0 + 2
   \   0001A6   85..83       MOV     DPH,?V0 + 3
   \   0001A9   A3           INC     DPTR
   \   0001AA   A3           INC     DPTR
   \   0001AB   A3           INC     DPTR
   \   0001AC   A3           INC     DPTR
   \   0001AD   A3           INC     DPTR
   \   0001AE   A3           INC     DPTR
   \   0001AF   A3           INC     DPTR
   \   0001B0   E0           MOVX    A,@DPTR
   \   0001B1   90....       MOV     DPTR,#Water_gage_err_a
   \   0001B4   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   0001B7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001BA   90....       MOV     DPTR,#p2p_test_DstAddr
   \   0001BD   7404         MOV     A,#0x4
   \   0001BF   12....       LCALL   ?PUSH_XSTACK8_X
   \   0001C2   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0001C5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C8                ; Setup parameters for call to function HalUARTWrite
   \   0001C8   7C01         MOV     R4,#0x1
   \   0001CA   7D00         MOV     R5,#0x0
   \   0001CC   7A..         MOV     R2,#(Water_gage_err_a & 0xff)
   \   0001CE   7B..         MOV     R3,#((Water_gage_err_a >> 8) & 0xff)
   \   0001D0   80CA         SJMP    ??p2p_test_recv_108clusterId_13
   \                     ??p2p_test_recv_108clusterId_7:
   \   0001D2   85..82       MOV     DPL,?V0 + 2
   \   0001D5   85..83       MOV     DPH,?V0 + 3
   \   0001D8   A3           INC     DPTR
   \   0001D9   A3           INC     DPTR
   \   0001DA   A3           INC     DPTR
   \   0001DB   A3           INC     DPTR
   \   0001DC   A3           INC     DPTR
   \   0001DD   A3           INC     DPTR
   \   0001DE   A3           INC     DPTR
   \   0001DF   E0           MOVX    A,@DPTR
   \   0001E0   90....       MOV     DPTR,#Water_gage_err_b
   \   0001E3   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   0001E6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001E9   90....       MOV     DPTR,#p2p_test_DstAddr
   \   0001EC   7404         MOV     A,#0x4
   \   0001EE   12....       LCALL   ?PUSH_XSTACK8_X
   \   0001F1   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   0001F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001F7                ; Setup parameters for call to function HalUARTWrite
   \   0001F7   7C01         MOV     R4,#0x1
   \   0001F9   7D00         MOV     R5,#0x0
   \   0001FB   7A..         MOV     R2,#(Water_gage_err_b & 0xff)
   \   0001FD   7B..         MOV     R3,#((Water_gage_err_b >> 8) & 0xff)
   \   0001FF   809B         SJMP    ??p2p_test_recv_108clusterId_13
   \                     ??p2p_test_recv_108clusterId_8:
   \   000201   85..82       MOV     DPL,?V0 + 2
   \   000204   85..83       MOV     DPH,?V0 + 3
   \   000207   A3           INC     DPTR
   \   000208   A3           INC     DPTR
   \   000209   A3           INC     DPTR
   \   00020A   A3           INC     DPTR
   \   00020B   A3           INC     DPTR
   \   00020C   A3           INC     DPTR
   \   00020D   A3           INC     DPTR
   \   00020E   E0           MOVX    A,@DPTR
   \   00020F   90....       MOV     DPTR,#Water_gage_err_c
   \   000212   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000215   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000218   90....       MOV     DPTR,#p2p_test_DstAddr
   \   00021B   7404         MOV     A,#0x4
   \   00021D   12....       LCALL   ?PUSH_XSTACK8_X
   \   000220   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000223   12....       LCALL   ?DEALLOC_XSTACK8
   \   000226                ; Setup parameters for call to function HalUARTWrite
   \                     ??p2p_test_recv_108clusterId_14:
   \   000226   7C01         MOV     R4,#0x1
   \   000228   7D00         MOV     R5,#0x0
   \   00022A   7A..         MOV     R2,#(Water_gage_err_c & 0xff)
   \   00022C   7B..         MOV     R3,#((Water_gage_err_c >> 8) & 0xff)
   \   00022E   02....       LJMP    ??p2p_test_recv_108clusterId_13 & 0xFFFF
   \                     ??p2p_test_recv_108clusterId_9:
   \   000231   12....       LCALL   ??Subroutine1_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000234   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000237   90....       MOV     DPTR,#p2p_test_DstAddr
   \   00023A   7404         MOV     A,#0x4
   \   00023C   12....       LCALL   ?PUSH_XSTACK8_X
   \   00023F   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000242   12....       LCALL   ?DEALLOC_XSTACK8
   \   000245   85..82       MOV     DPL,?V0 + 2
   \   000248   85..83       MOV     DPH,?V0 + 3
   \   00024B   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   00024E   E0           MOVX    A,@DPTR
   \   00024F   F9           MOV     R1,A
   \   000250   EA           MOV     A,R2
   \   000251   90....       MOV     DPTR,#WaterGageUnit
   \   000254   12....       LCALL   ??Subroutine31_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000257   85..82       MOV     DPL,?V0 + 2
   \   00025A   85..83       MOV     DPH,?V0 + 3
   \   00025D   A3           INC     DPTR
   \   00025E   A3           INC     DPTR
   \   00025F   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000262   A3           INC     DPTR
   \   000263   A3           INC     DPTR
   \   000264   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000267   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   00026A   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00026D   E5..         MOV     A,?V0 + 2
   \   00026F   240C         ADD     A,#0xc
   \   000271   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000274   FA           MOV     R2,A
   \   000275   E5..         MOV     A,?V0 + 2
   \   000277   240B         ADD     A,#0xb
   \   000279   F582         MOV     DPL,A
   \   00027B   E5..         MOV     A,?V0 + 3
   \   00027D   3400         ADDC    A,#0x0
   \   00027F   F583         MOV     DPH,A
   \   000281   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000284   90....       MOV     DPTR,#Water_gage_time
   \   000287   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   00028A   E5..         MOV     A,?V0 + 2
   \   00028C   240D         ADD     A,#0xd
   \   00028E   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000291   90....       MOV     DPTR,#Water_gage_err_a
   \   000294   F0           MOVX    @DPTR,A
   \   000295   E5..         MOV     A,?V0 + 2
   \   000297   240E         ADD     A,#0xe
   \   000299   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   00029C   90....       MOV     DPTR,#Water_gage_err_b
   \   00029F   F0           MOVX    @DPTR,A
   \   0002A0   E5..         MOV     A,?V0 + 2
   \   0002A2   240F         ADD     A,#0xf
   \   0002A4   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   0002A7   90....       MOV     DPTR,#Water_gage_err_c
   \   0002AA   F0           MOVX    @DPTR,A
   \   0002AB                ; Setup parameters for call to function HalUARTWrite_uint16
   \   0002AB   90....       MOV     DPTR,#WaterGageUnit
   \   0002AE   12....       LCALL   ??Subroutine3_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0002B1                ; Setup parameters for call to function HalUARTWrite_uint16
   \   0002B1   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   0002B4                ; Setup parameters for call to function HalUARTWrite_uint16
   \   0002B4   90....       MOV     DPTR,#Water_gage_time
   \   0002B7   12....       LCALL   ??Subroutine3_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0002BA                ; Setup parameters for call to function HalUARTWrite
   \   0002BA   7C01         MOV     R4,#0x1
   \   0002BC   7D00         MOV     R5,#0x0
   \   0002BE   7A..         MOV     R2,#(Water_gage_err_a & 0xff)
   \   0002C0   7B..         MOV     R3,#((Water_gage_err_a >> 8) & 0xff)
   \   0002C2   7900         MOV     R1,#0x0
   \   0002C4   12....       LCALL   ??HalUARTWrite?relay
   \   0002C7                ; Setup parameters for call to function HalUARTWrite
   \   0002C7   7C01         MOV     R4,#0x1
   \   0002C9   7D00         MOV     R5,#0x0
   \   0002CB   7A..         MOV     R2,#(Water_gage_err_b & 0xff)
   \   0002CD   7B..         MOV     R3,#((Water_gage_err_b >> 8) & 0xff)
   \   0002CF   7900         MOV     R1,#0x0
   \   0002D1   12....       LCALL   ??HalUARTWrite?relay
   \   0002D4                ; Setup parameters for call to function HalUARTWrite
   \   0002D4   02....       LJMP    ??p2p_test_recv_108clusterId_14 & 0xFFFF
   \                     ??p2p_test_recv_108clusterId_10:
   \   0002D7   85..82       MOV     DPL,?V0 + 2
   \   0002DA   85..83       MOV     DPH,?V0 + 3
   \   0002DD   A3           INC     DPTR
   \   0002DE   A3           INC     DPTR
   \   0002DF   A3           INC     DPTR
   \   0002E0   A3           INC     DPTR
   \   0002E1   A3           INC     DPTR
   \   0002E2   A3           INC     DPTR
   \   0002E3   A3           INC     DPTR
   \   0002E4   E0           MOVX    A,@DPTR
   \   0002E5   90....       MOV     DPTR,#acceptance
   \   0002E8   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   0002EB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002EE   90....       MOV     DPTR,#p2p_test_DstAddr
   \   0002F1   7404         MOV     A,#0x4
   \   0002F3   12....       LCALL   ?PUSH_XSTACK8_X
   \   0002F6   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0002F9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002FC                ; Setup parameters for call to function HalUARTWrite
   \   0002FC   7C01         MOV     R4,#0x1
   \   0002FE   7D00         MOV     R5,#0x0
   \   000300   7A..         MOV     R2,#(acceptance & 0xff)
   \   000302   7B..         MOV     R3,#((acceptance >> 8) & 0xff)
   \   000304   02....       LJMP    ??p2p_test_recv_108clusterId_13 & 0xFFFF
   \                     ??p2p_test_recv_108clusterId_11:
   \   000307   12....       LCALL   ??Subroutine1_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   00030A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00030D   90....       MOV     DPTR,#p2p_test_DstAddr
   \   000310   7404         MOV     A,#0x4
   \   000312   12....       LCALL   ?PUSH_XSTACK8_X
   \   000315   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000318   12....       LCALL   ?DEALLOC_XSTACK8
   \   00031B                ; Setup parameters for call to function HalUARTWrite
   \   00031B   7C01         MOV     R4,#0x1
   \   00031D   7D00         MOV     R5,#0x0
   \   00031F   E5..         MOV     A,?V0 + 2
   \   000321   2407         ADD     A,#0x7
   \   000323   FA           MOV     R2,A
   \   000324   E5..         MOV     A,?V0 + 3
   \   000326   3400         ADDC    A,#0x0
   \   000328   FB           MOV     R3,A
   \   000329   7900         MOV     R1,#0x0
   \   00032B   12....       LCALL   ??HalUARTWrite?relay
   \   00032E                ; Setup parameters for call to function halWait
   \   00032E   7964         MOV     R1,#0x64
   \   000330   12....       LCALL   ??halWait?relay
   \   000333   C2AF         CLR     0xa8.7
   \   000335   75C9AB       MOV     0xc9,#-0x55
   \   000338   75C95B       MOV     0xc9,#0x5b
   \                     ??p2p_test_recv_108clusterId_15:
   \   00033B   00           NOP
   \   00033C   80FD         SJMP    ??p2p_test_recv_108clusterId_15
   \   00033E                REQUIRE _A_IEN0
   \   00033E                REQUIRE WDCTL
   1534              }
   1535                /*
   1536                  else if(AppHead->TypeCode == TYPE_CODE_COMMAND_MODIFY_N)
   1537                  {
   1538                    uint8 sensor_type = pkt[6];
   1539                    if(sensor_type == TYPE_CODE_SENSOR_RAIN)
   1540                    {
   1541                      SendRainCountFreq = pkt[7];
   1542                      RainCountNum = 0;//reset        
   1543                    }
   1544                    return;
   1545                  }
   1546                  else if(AppHead->TypeCode == TYPE_CODE_COMMAND_REQUIRE)
   1547                  {
   1548                    uint8 sensor_type = pkt[6];
   1549                    if(sensor_type == TYPE_CODE_SENSOR_RAIN)
   1550                    {
   1551                      p2p_test_SendRainTimeFreqAndRequire(REQUIRE);
   1552                    }
   1553                    else if(sensor_type == TYPE_CODE_SENSOR_SOIL_HUMIDITY )
   1554                    {
   1555                      SOIL_TYPE = pkt[7];
   1556                      p2p_test_SendSoilHumidityTimeFreqAndRequire(REQUIRE);
   1557                    }   
   1558                     else if(sensor_type == TYPE_CODE_SENSOR_READ_VCC)
   1559                   {
   1560                    p2p_test_Send_VCC_VALUE(REQUIRE);
   1561                   }
   1562                    return;
   1563                  }     
   1564                  else if(AppHead->TypeCode == TYPE_CODE_COMMAND_SENSOR_STOP_EVT)
   1565                  {
   1566                    uint8 sensor_type = pkt[6];
   1567                    if (sensor_type ==  TYPE_CODE_SENSOR_RAIN)
   1568                    {
   1569                     osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_RAIN_FREQ_MSG_EVT);
   1570                     SendRainRemainTime = 0;//keep next send at once
   1571                    } 
   1572                    else if(sensor_type == TYPE_CODE_SENSOR_SOIL_HUMIDITY)
   1573                    {
   1574                     osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT );
   1575                     SendSoilHumidityRemainTime = 0;   //keep next send at once
   1576                    }
   1577                    else if(sensor_type == TYPE_CODE_SENSOR_READ_VCC)
   1578                    {
   1579                    osal_stop_timerEx(p2p_test_TaskID, p2p_test_SEND_VCC_VALUE_FREQ_MSG_EVT);
   1580                    SendVccValueRemainTime = 0;       //keep next send at once
   1581                    }
   1582                  }
   1583              }*/
   1584            }
   1585               
   1586               
   1587             /* else if(AppHead->type == TYPE_MAINTAIN)
   1588              {
   1589                if((AppHead->TypeCode == TYPE_CODE_MAINTAIN_RESET_TIME) || (AppHead->TypeCode == TYPE_CODE_MAINTAIN_RELATION_1))
   1590                {
   1591                  p2p_test_SendToUart(pkt, length);
   1592                  return;
   1593                }
   1594              */
   1595           /* else if(AppHead->type == TYPE_ZIGBEE_RESTART_COMMAND)
   1596            {
   1597              uint8 temp_arm_id,temp_zigbee_id;
   1598              temp_arm_id=(pkt[4]&0x0f);
   1599              temp_zigbee_id=(pkt[5]&0xf0)>>4;
   1600              uint16 SerialNumber =BUILD_UINT16(AppHead->sn[1],AppHead->sn[0]);
   1601              //uint16 SerialNumber =BUILD_UINT16(pkt[3],pkt[2]);
   1602              
   1603              if(ARM_ID==temp_arm_id && Zigbee_ID==temp_zigbee_id)
   1604              {
   1605          
   1606             //     uint8 sensor_type = pkt[6];
   1607            //      uint16 freq = BUILD_UINT16(pkt[7], 0x00);
   1608                  AppHeadNodeId_t *AppHeadNodeId=(AppHeadNodeId_t *)osal_msg_allocate(sizeof(AppHeadNodeId_t));
   1609                  //fill_AppHead((AppHead_t *)&AppHeadNodeId->AppHead,ACK_NO, MAIN_VERSION, SUB_VERSION,TYPE_ACK,TYPE_ACK_UP);
   1610                  fill_AppHead_sn((AppHead_t *)&AppHeadNodeId->AppHead,ACK_NO, MAIN_VERSION, SUB_VERSION,TYPE_ACK,TYPE_ACK_UP, SerialNumber);
   1611          
   1612                  AppHeadNodeId->NodeId.r=RES;
   1613                  AppHeadNodeId->NodeId.ARM_id=ARM_ID;
   1614                  AppHeadNodeId->NodeId.Zigbee_id=Zigbee_ID;
   1615                  AppHeadNodeId->NodeId.sensor_type= WATER_GAGE_ID ;
   1616                  SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);   
   1617                  
   1618                  Zigbee_Restart_Command_t *pkt_zst = (Zigbee_Restart_Command_t *)pkt;
   1619                
   1620                  WaterGageUnit = pkt_zst->water_gage_type;
   1621                  SendWaterGageTimeFreq = pkt_zst-> water_gage_freq;
   1622                  Water_gage_time = pkt_zst-> water_gage_T ;
   1623                  Water_gage_err_a = pkt_zst-> water_gage_A;
   1624                  Water_gage_err_b = pkt_zst-> water_gage_B;
   1625                  Water_gage_err_c = pkt_zst-> water_gage_C;   
   1626                  
   1627          #if DEBUG
   1628                  HalUARTWrite_uint16(WaterGageUnit);
   1629                  HalUARTWrite(0,&Water_gage_err_a, sizeof(Water_gage_err_a));
   1630                  HalUARTWrite_uint16(SendWaterGageTimeFreq);
   1631                  HalUARTWrite(0,&Water_gage_err_b, sizeof(Water_gage_err_b));
   1632                  HalUARTWrite_uint16(Water_gage_time);
   1633                  HalUARTWrite(0,&Water_gage_err_c, sizeof(Water_gage_err_c));
   1634          #endif        
   1635                  osal_msg_deallocate((uint8 *)AppHeadNodeId);
   1636              }
   1637              return ;
   1638            }*/
   1639          
   1640            else if(AppHead->type == TYPE_REPORT)
   1641            {
   1642            }
   1643            else if(AppHead->type == TYPE_ACK)
   1644            {
   1645            }
   1646           
   1647          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   85..82       MOV     DPL,?V0 + 2
   \   000005                REQUIRE ?Subroutine58
   \   000005                ; // Fall through to label ?Subroutine58

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   8B83         MOV     DPH,R3
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FA           MOV     R2,A
   \   00000A   85..82       MOV     DPL,?V0 + 2
   \   00000D   85..83       MOV     DPH,?V0 + 3
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013                REQUIRE ?Subroutine57
   \   000013                ; // Fall through to label ?Subroutine57

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   EA           MOV     A,R2
   \   000003   75F03C       MOV     B,#0x3c
   \   000006   A4           MUL     AB
   \   000007   F8           MOV     R0,A
   \   000008   AAF0         MOV     R2,B
   \   00000A   75F03C       MOV     B,#0x3c
   \   00000D   E9           MOV     A,R1
   \   00000E   A4           MUL     AB
   \   00000F   2A           ADD     A,R2
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E5F0         MOV     A,B
   \                     ??Subroutine1_0:
   \   000004   F0           MOVX    @DPTR,A
   \                     ??Subroutine1_1:
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   54F0         ANL     A,#0xf0
   \   00000C   4403         ORL     A,#0x3
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F                ; Setup parameters for call to function SendMsg
   \   00000F   75..02       MOV     ?V0 + 0,#0x2
   \   000012                REQUIRE ?Subroutine56
   \   000012                ; // Fall through to label ?Subroutine56

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   75..00       MOV     ?V0 + 1,#0x0
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   4A           ORL     A,R2
   \   000001   FA           MOV     R2,A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#ARM_ID
   \   000006   E0           MOVX    A,@DPTR
   \   000007   540F         ANL     A,#0xf
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   E5..         MOV     A,?V0 + 6
   \   000002   2404         ADD     A,#0x4
   \   000004   F8           MOV     R0,A
   \   000005   E5..         MOV     A,?V0 + 7
   \   000007   3400         ADDC    A,#0x0
   \   000009   F9           MOV     R1,A
   \   00000A   90....       MOV     DPTR,#RES
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   C4           SWAP    A
   \   00000F   54F0         ANL     A,#0xf0
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FF           MOV     R7,A
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   EA           MOV     A,R2
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   E9           MOV     A,R1
   \   000006   F5..         MOV     ?V0 + 1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \                     ??Subroutine3_0:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FB           MOV     R3,A
   \   000008   12....       LCALL   ??HalUARTWrite_uint16?relay
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   7C20         MOV     R4,#0x20
   \   000002   7906         MOV     R1,#0x6
   \   000004   AA..         MOV     R2,?V0 + 6
   \   000006   AB..         MOV     R3,?V0 + 7
   \                     ??Subroutine38_0:
   \   000008   12....       LCALL   ??SendMsg?relay
   \   00000B   7406         MOV     A,#0x6
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \                     ??Subroutine25_0:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   540F         ANL     A,#0xf
   \   000007   FA           MOV     R2,A
   \   000008   22           RET
   1648          
   1649          /*********************************************************************
   1650           * @fn      p2p_test_recv_RelationMsgclusterId
   1651           *
   1652           * @brief   
   1653           *
   1654           * @param   none
   1655           *
   1656           * @return  none
   1657           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1658          void p2p_test_recv_RelationMsgclusterId(uint8 *pkt,uint8 length,uint16 srcaddr)
   \                     p2p_test_recv_RelationMsgclusterId:
   1659          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EC           MOV     A,R4
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   ED           MOV     A,R5
   \   000014   F0           MOVX    @DPTR,A
   \   000015   8A..         MOV     ?V0 + 0,R2
   \   000017   8B..         MOV     ?V0 + 1,R3
   \   000019   89..         MOV     ?V0 + 2,R1
   1660            AppHead_t *AppHead = (AppHead_t *)pkt;
   1661            uint16 num;
   1662            uint8 temp_Zigbee_ID;
   1663            uint8 temp_ARM_ID;
   1664            uint8 temp_ACK;
   1665            uint8 SendOption;
   1666            struct RelationMap_t *temp_map=NULL;
   1667           // static uint8 acknum=0;
   1668            //coord print
   1669           // SendMsg((uint8 *)pkt, length, p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   1670            if(AppHead->type==TYPE_MAINTAIN)//coord receive fronm commom node relation Msg Request
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   540F         ANL     A,#0xf
   \   000022   6401         XRL     A,#0x1
   \   000024   6003         JZ      $+5
   \   000026   02....       LJMP    ??p2p_test_recv_RelationMsgclusterId_0 & 0xFFFF
   1671            {
   1672              if(AppHead->TypeCode==RELATION_MSG_UP)
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   6401         XRL     A,#0x1
   \   00002D   6003         JZ      $+5
   \   00002F   02....       LJMP    ??p2p_test_recv_RelationMsgclusterId_1 & 0xFFFF
   1673              {
   1674                num=BUILD_UINT16(pkt[5],pkt[4]);
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FA           MOV     R2,A
   \   00003D   85..82       MOV     DPL,?V0 + 0
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   EA           MOV     A,R2
   \   000049   FE           MOV     R6,A
   \   00004A   E9           MOV     A,R1
   \   00004B   FF           MOV     R7,A
   1675                //SendMsg((uint8 *)pkt, length, p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   1676             /*   if(AppHead->AckRequire)
   1677                {
   1678                  SendOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   1679                }
   1680                else
   1681                {
   1682                  SendOption = AF_DISCV_ROUTE;
   1683                } */
   1684                AppHeadNodeId_t *AppHeadNodeId=(AppHeadNodeId_t *)osal_msg_allocate(sizeof(AppHeadNodeId_t));
   \   00004C                ; Setup parameters for call to function osal_msg_allocate
   \   00004C   7A06         MOV     R2,#0x6
   \   00004E   7B00         MOV     R3,#0x0
   \   000050   12....       LCALL   ??osal_msg_allocate?relay
   \   000053   8A..         MOV     ?V0 + 6,R2
   \   000055   8B..         MOV     ?V0 + 7,R3
   1685                SendOption = AF_DISCV_ROUTE;
   1686                if(0==num)
   \   000057   EE           MOV     A,R6
   \   000058   7001         JNZ     ??p2p_test_recv_RelationMsgclusterId_2
   \   00005A   EF           MOV     A,R7
   \                     ??p2p_test_recv_RelationMsgclusterId_2:
   \   00005B   6003         JZ      $+5
   \   00005D   02....       LJMP    ??p2p_test_recv_RelationMsgclusterId_3 & 0xFFFF
   1687                {
   1688                  temp_ACK=ACK_YES;
   1689                  //SendMsg((uint8 *)pkt, length, p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   1690                  fill_AppHead((AppHead_t *)&AppHeadNodeId->AppHead, temp_ACK, MAIN_VERSION, SUB_VERSION, TYPE_ACK,RELATION_MSG_DOWN);
   \   000060                ; Setup parameters for call to function fill_AppHead
   \   000060   75..01       MOV     ?V0 + 0,#0x1
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   75..0F       MOV     ?V0 + 0,#0xf
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000070   7D01         MOV     R5,#0x1
   \   000072   7C00         MOV     R4,#0x0
   \   000074   7901         MOV     R1,#0x1
   \   000076   12....       LCALL   ??fill_AppHead?relay
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   1691                  if(Zigbee_ID!=0)
   \   00007E   90....       MOV     DPTR,#Zigbee_ID
   \   000081   E0           MOVX    A,@DPTR
   \   000082   7003         JNZ     $+5
   \   000084   02....       LJMP    ??p2p_test_recv_RelationMsgclusterId_4 & 0xFFFF
   1692                   {
   1693                     temp_Zigbee_ID=search_RelationMap(srcaddr);//check srcaddr is in the RelationMap
   \   000087                ; Setup parameters for call to function search_RelationMap
   \   000087   85..82       MOV     DPL,?XSP + 0
   \   00008A   85..83       MOV     DPH,?XSP + 1
   \   00008D   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000090   12....       LCALL   ??search_RelationMap?relay
   \   000093   E9           MOV     A,R1
   \   000094   FE           MOV     R6,A
   1694                     p2p_test_EnddeviceAddr.addr.shortAddr = srcaddr;//add by yd
   \   000095   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000098   90....       MOV     DPTR,#p2p_test_EnddeviceAddr
   \   00009B   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   1695                    //  HalUARTWrite(0,(uint8 *)&temp_Zigbee_ID,sizeof(temp_Zigbee_ID));
   1696                    if(0==temp_Zigbee_ID)
   \                     ??CrossCallReturnLabel_90:
   \   00009E   EE           MOV     A,R6
   \   00009F   7045         JNZ     ??p2p_test_recv_RelationMsgclusterId_5
   1697                    {
   1698                      uint8 i;
   1699                      uint16 temp_flag;
   1700                      temp_flag=FlagMap;
   \   0000A1   90....       MOV     DPTR,#FlagMap
   \   0000A4   12....       LCALL   ?Subroutine54 & 0xFFFF
   1701                      uint16 t;
   1702                      for(i=1;i<16;i++)
   \                     ??CrossCallReturnLabel_151:
   \   0000A7   7901         MOV     R1,#0x1
   1703                      {
   1704                        t=(temp_flag>>(i-1))&0x0001;
   1705                        if(t==0)
   \                     ??p2p_test_recv_RelationMsgclusterId_6:
   \   0000A9   8A..         MOV     ?V0 + 0,R2
   \   0000AB   8B..         MOV     ?V0 + 1,R3
   \   0000AD   74FF         MOV     A,#-0x1
   \   0000AF   29           ADD     A,R1
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   12....       LCALL   ?US_SHR
   \   0000B5   E5..         MOV     A,?V0 + 0
   \   0000B7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B9   5007         JNC     ??p2p_test_recv_RelationMsgclusterId_7
   1706                          break;
   1707                      }
   \   0000BB   09           INC     R1
   \   0000BC   E9           MOV     A,R1
   \   0000BD   C3           CLR     C
   \   0000BE   9410         SUBB    A,#0x10
   \   0000C0   40E7         JC      ??p2p_test_recv_RelationMsgclusterId_6
   1708                      FlagMap=ADDFLAG16(FlagMap,i);
   \                     ??p2p_test_recv_RelationMsgclusterId_7:
   \   0000C2   75..01       MOV     ?V0 + 0,#0x1
   \   0000C5   75..00       MOV     ?V0 + 1,#0x0
   \   0000C8   74FF         MOV     A,#-0x1
   \   0000CA   29           ADD     A,R1
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?S_SHL
   \   0000D0   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000D3   F0           MOVX    @DPTR,A
   1709                      temp_Zigbee_ID=i;
   \   0000D4   E9           MOV     A,R1
   \   0000D5   FE           MOV     R6,A
   1710                      insert_RelationMap(temp_map,srcaddr,i); 
   \   0000D6                ; Setup parameters for call to function insert_RelationMap
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   0000DF   7A00         MOV     R2,#0x0
   \   0000E1   7B00         MOV     R3,#0x0
   \   0000E3   12....       LCALL   ??insert_RelationMap?relay
   1711                    }
   1712                    AppHeadNodeId->NodeId.r=RES;
   \                     ??p2p_test_recv_RelationMsgclusterId_5:
   \   0000E6   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   0000E9   C0E0         PUSH    A
   \   0000EB   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0000EE   D0E0         POP     A
   \   0000F0   12....       LCALL   ?Subroutine39 & 0xFFFF
   1713                    AppHeadNodeId->NodeId.ARM_id=ARM_ID;
   \                     ??CrossCallReturnLabel_120:
   \   0000F3   C0E0         PUSH    A
   \   0000F5   74F0         MOV     A,#-0x10
   \   0000F7   5A           ANL     A,R2
   \   0000F8   FA           MOV     R2,A
   \   0000F9   D0E0         POP     A
   \   0000FB   4A           ORL     A,R2
   \   0000FC   8882         MOV     DPL,R0
   \   0000FE   8983         MOV     DPH,R1
   \   000100   F0           MOVX    @DPTR,A
   1714                    AppHeadNodeId->NodeId.Zigbee_id= temp_Zigbee_ID;//
   1715                    AppHeadNodeId->NodeId.sensor_type=0x00;
   \   000101   EE           MOV     A,R6
   \   000102   C4           SWAP    A
   \   000103   54F0         ANL     A,#0xf0
   \   000105   85..82       MOV     DPL,?V0 + 6
   \   000108   85..83       MOV     DPH,?V0 + 7
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   F0           MOVX    @DPTR,A
   1716                   // SendMsg((uint8 *)AppHeadNodeId,sizeof(AppHeadNodeId_t), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   1717                    afAddrType_t p2p_test_DstAddr_temp;
   1718                    p2p_test_DstAddr_temp.addrMode = (afAddrMode_t)Addr16Bit;
   \   000111   7404         MOV     A,#0x4
   \   000113   12....       LCALL   ?XSTACK_DISP0_8
   \   000116   7402         MOV     A,#0x2
   \   000118   F0           MOVX    @DPTR,A
   1719                    p2p_test_DstAddr_temp.endPoint = p2p_test_ENDPOINT;
   \   000119   7405         MOV     A,#0x5
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   740A         MOV     A,#0xa
   \   000120   F0           MOVX    @DPTR,A
   1720                    p2p_test_DstAddr_temp.addr.shortAddr = srcaddr;  
   \   000121   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000124   7402         MOV     A,#0x2
   \   000126   12....       LCALL   ?XSTACK_DISP0_8
   \   000129   12....       LCALL   ?Subroutine30 & 0xFFFF
   1721                    AF_DataRequest( &p2p_test_DstAddr_temp, &p2p_test_epDesc,
   1722                                             p2p_test_RelationMsg,
   1723                                             sizeof(AppHeadNodeId_t),
   1724                                             (uint8*)AppHeadNodeId,
   1725                                             &p2p_test_TransID,
   1726                                             SendOption, AF_DEFAULT_RADIUS);
   \                     ??CrossCallReturnLabel_82:
   \   00012C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00012F   75....       MOV     ?V0 + 0,#(p2p_test_TransID & 0xff)
   \   000132   75....       MOV     ?V0 + 1,#((p2p_test_TransID >> 8) & 0xff)
   \   000135   78..         MOV     R0,#?V0 + 0
   \   000137   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013A   78..         MOV     R0,#?V0 + 6
   \   00013C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013F   75..06       MOV     ?V0 + 0,#0x6
   \   000142   75..00       MOV     ?V0 + 1,#0x0
   \   000145   78..         MOV     R0,#?V0 + 0
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014A   75..04       MOV     ?V0 + 0,#0x4
   \   00014D   78..         MOV     R0,#?V0 + 0
   \   00014F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000152   7920         MOV     R1,#0x20
   \   000154   7C..         MOV     R4,#(p2p_test_epDesc & 0xff)
   \   000156   7D..         MOV     R5,#((p2p_test_epDesc >> 8) & 0xff)
   \   000158   740B         MOV     A,#0xb
   \   00015A   12....       LCALL   ?XSTACK_DISP0_8
   \   00015D   AA82         MOV     R2,DPL
   \   00015F   AB83         MOV     R3,DPH
   \   000161   12....       LCALL   ??AF_DataRequest?relay
   \   000164   7409         MOV     A,#0x9
   \   000166   12....       LCALL   ?DEALLOC_XSTACK8
   \   000169   8027         SJMP    ??p2p_test_recv_RelationMsgclusterId_4
   1727                    
   1728                  }
   1729          #if defined(RTR_NWK)      
   1730                  print_AssociatedDevList();
   1731          #endif 
   1732                }
   1733                else if(Zigbee_ID!=0 && num!=0)//num!=0,then send to uart
   \                     ??p2p_test_recv_RelationMsgclusterId_3:
   \   00016B   90....       MOV     DPTR,#Zigbee_ID
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   6021         JZ      ??p2p_test_recv_RelationMsgclusterId_4
   1734                {
   1735                  temp_ACK=ACK_YES;
   1736                  SendMsg((uint8 *)pkt, length, p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   \   000171                ; Setup parameters for call to function SendMsg
   \   000171   75..04       MOV     ?V0 + 4,#0x4
   \   000174   75..00       MOV     ?V0 + 5,#0x0
   \   000177   78..         MOV     R0,#?V0 + 4
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017C   90....       MOV     DPTR,#p2p_test_DstAddr
   \   00017F   7404         MOV     A,#0x4
   \   000181   12....       LCALL   ?PUSH_XSTACK8_X
   \   000184   7C20         MOV     R4,#0x20
   \   000186   A9..         MOV     R1,?V0 + 2
   \   000188   AA..         MOV     R2,?V0 + 0
   \   00018A   AB..         MOV     R3,?V0 + 1
   \   00018C   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00018F   12....       LCALL   ?DEALLOC_XSTACK8
   1737                }
   1738                //fill_AppHead((AppHead_t *)&temp_DownAckMsg.AppHead,temp_ACK,MAIN_VERSION,SUB_VERSION,TYPE_ACK,RELATION_MSG_DOWN);
   1739                osal_msg_deallocate((uint8 *)AppHeadNodeId); 
   \                     ??p2p_test_recv_RelationMsgclusterId_4:
   \   000192                ; Setup parameters for call to function osal_msg_deallocate
   \   000192   AA..         MOV     R2,?V0 + 6
   \   000194   AB..         MOV     R3,?V0 + 7
   \   000196   12....       LCALL   ??osal_msg_deallocate?relay
   \   000199   805C         SJMP    ??p2p_test_recv_RelationMsgclusterId_1
   1740              }    
   1741            }
   1742            else if(AppHead->type==TYPE_ACK)//only common node receive form coord node's ACK RelationMsg
   \                     ??p2p_test_recv_RelationMsgclusterId_0:
   \   00019B   E0           MOVX    A,@DPTR
   \   00019C   540F         ANL     A,#0xf
   \   00019E   640F         XRL     A,#0xf
   \   0001A0   7055         JNZ     ??p2p_test_recv_RelationMsgclusterId_1
   1743            { 
   1744              //print something as flag
   1745             // uint16 A=0xAAAA;
   1746             // HalUARTWrite(0,(uint8 *)A,sizeof(A));
   1747              if(AppHead->TypeCode==RELATION_MSG_DOWN)
   \   0001A2   A3           INC     DPTR
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   6401         XRL     A,#0x1
   \   0001A6   704F         JNZ     ??p2p_test_recv_RelationMsgclusterId_1
   1748              {
   1749                temp_ARM_ID=pkt[4]&0x0f;
   \   0001A8   8A82         MOV     DPL,R2
   \   0001AA   8B83         MOV     DPH,R3
   \   0001AC   A3           INC     DPTR
   \   0001AD   A3           INC     DPTR
   \   0001AE   A3           INC     DPTR
   \   0001AF   A3           INC     DPTR
   \   0001B0   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   1750                temp_Zigbee_ID=(pkt[5]&0xf0)>>4;
   \                     ??CrossCallReturnLabel_69:
   \   0001B3   85..82       MOV     DPL,?V0 + 0
   \   0001B6   8B83         MOV     DPH,R3
   \   0001B8   A3           INC     DPTR
   \   0001B9   A3           INC     DPTR
   \   0001BA   A3           INC     DPTR
   \   0001BB   A3           INC     DPTR
   \   0001BC   A3           INC     DPTR
   \   0001BD   E0           MOVX    A,@DPTR
   \   0001BE   C4           SWAP    A
   \   0001BF   540F         ANL     A,#0xf
   \   0001C1   FE           MOV     R6,A
   1751                if(ARM_ID==0 && Zigbee_ID==0)
   \   0001C2   90....       MOV     DPTR,#ARM_ID
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   7011         JNZ     ??p2p_test_recv_RelationMsgclusterId_8
   \   0001C8   90....       MOV     DPTR,#Zigbee_ID
   \   0001CB   E0           MOVX    A,@DPTR
   \   0001CC   700B         JNZ     ??p2p_test_recv_RelationMsgclusterId_8
   1752                {
   1753                  ARM_ID=temp_ARM_ID;
   \   0001CE   EA           MOV     A,R2
   \   0001CF   90....       MOV     DPTR,#ARM_ID
   \   0001D2   F0           MOVX    @DPTR,A
   1754                  Zigbee_ID=temp_Zigbee_ID;
   \   0001D3   EE           MOV     A,R6
   \   0001D4   90....       MOV     DPTR,#Zigbee_ID
   \   0001D7   801D         SJMP    ??CrossCallReturnLabel_34
   1755                 // acknum=1;
   1756                }
   1757                else if(Zigbee_ID!=0 && ARM_ID==temp_ARM_ID && Zigbee_ID==temp_Zigbee_ID)  //ARM_ID!=0,Zigbee_ID!=0
   \                     ??p2p_test_recv_RelationMsgclusterId_8:
   \   0001D9   90....       MOV     DPTR,#Zigbee_ID
   \   0001DC   E0           MOVX    A,@DPTR
   \   0001DD   6018         JZ      ??p2p_test_recv_RelationMsgclusterId_1
   \   0001DF   90....       MOV     DPTR,#ARM_ID
   \   0001E2   E0           MOVX    A,@DPTR
   \   0001E3   6A           XRL     A,R2
   \   0001E4   7011         JNZ     ??p2p_test_recv_RelationMsgclusterId_1
   \   0001E6   90....       MOV     DPTR,#Zigbee_ID
   \   0001E9   E0           MOVX    A,@DPTR
   \   0001EA   6E           XRL     A,R6
   \   0001EB   700A         JNZ     ??p2p_test_recv_RelationMsgclusterId_1
   1758                { 
   1759                  if(relation_done == 0)//解决多次收到ack影响数据采集时间的bug
   \   0001ED   90....       MOV     DPTR,#relation_done
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   7004         JNZ     ??p2p_test_recv_RelationMsgclusterId_1
   1760                  {
   1761                   osal_stop_timerEx( p2p_test_TaskID,p2p_test_SEND_MAINTAIN_MSG_EVT);
   \   0001F3                ; Setup parameters for call to function osal_stop_timerEx
   \   0001F3   12....       LCALL   ?Subroutine12 & 0xFFFF
   1762                   p2p_test_StartDataSensorTimer();
   1763                   relation_done =1;
   \                     ??CrossCallReturnLabel_34:
   \   0001F6   F0           MOVX    @DPTR,A
   1764                  }
   1765                }
   1766              }
   1767            }
   1768          }
   \                     ??p2p_test_recv_RelationMsgclusterId_1:
   \   0001F7   7406         MOV     A,#0x6
   \   0001F9                REQUIRE ?Subroutine53
   \   0001F9                ; // Fall through to label ?Subroutine53

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function AF_DataRequest
   \   000005                ; Setup parameters for call to function AF_DataRequest
   \   000005   75..0A       MOV     ?V0 + 0,#0xa
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   90....       MOV     DPTR,#FlagMap
   \   000003   E0           MOVX    A,@DPTR
   \   000004   45..         ORL     A,?V0 + 0
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   45..         ORL     A,?V0 + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   7A01         MOV     R2,#0x1
   \   000002   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000005                ; Setup parameters for call to function p2p_test_StartDataSensorTimer
   \   000005                ; Setup parameters for call to function p2p_test_StartDataSensorTimer
   \   000005   12....       LCALL   ??p2p_test_StartDataSensorTimer?relay
   \   000008   7401         MOV     A,#0x1
   \   00000A   90....       MOV     DPTR,#relation_done
   \   00000D   22           RET
   1769          /*********************************************************************
   1770           * @fn      p2p_test_RecvFromUart
   1771           *
   1772           * @brief   
   1773           *
   1774           * @param   none
   1775           *
   1776           * @return  none
   1777           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1778          void p2p_test_RecvFromUart(uint8 *Msg)
   \                     p2p_test_RecvFromUart:
   1779          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1780            //Msg = 0xAA 0x55 LEN shortaddr0 shortaddr1 DATA (Not include check, add short addr)
   1781            //temporarily not consider broadcast
   1782            uint16 temp_shortaddr = p2p_test_EnddeviceAddr.addr.shortAddr;
   \   00000E   90....       MOV     DPTR,#p2p_test_EnddeviceAddr
   \   000011   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   1783            static uint8 ack_num=0;
   1784            if((0x01==Msg[0])&&(0x03==Msg[1]))
   \                     ??CrossCallReturnLabel_47:
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6401         XRL     A,#0x1
   \   00001B   6003         JZ      $+5
   \   00001D   02....       LJMP    ??p2p_test_RecvFromUart_0 & 0xFFFF
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   6403         XRL     A,#0x3
   \   000024   6003         JZ      $+5
   \   000026   02....       LJMP    ??p2p_test_RecvFromUart_0 & 0xFFFF
   1785            {
   1786          #if DEBUG 
   1787                    uint8 x3 = 0xDD;
   \   000029   7408         MOV     A,#0x8
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   74DD         MOV     A,#-0x23
   \   000030   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   1788                    HalUARTWrite(0,&x3, sizeof(x3));
   1789          #endif     
   1790              //Msg = 0x01 0x03 LEN DATA 
   1791            //temporarily not consider broadcast
   1792                 no_charge_flag = 0;
   \                     ??CrossCallReturnLabel_77:
   \   000033   E4           CLR     A
   \   000034   90....       MOV     DPTR,#no_charge_flag
   \   000037   F0           MOVX    @DPTR,A
   1793                 WaterGageFlag=1;
   \   000038   7401         MOV     A,#0x1
   \   00003A   90....       MOV     DPTR,#WaterGageFlag
   \   00003D   F0           MOVX    @DPTR,A
   1794                 Water_Gage_t  temp_water_gage;
   1795            //temp_water_gage.water_gage_type[0]=HI_UINT16(WaterGageUnit);
   1796            //temp_water_gage.water_gage_type[1]=LO_UINT16(WaterGageUnit);   
   1797                 temp_water_gage.water_gage_value[0]=Msg[3];
   \   00003E   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000041   85..82       MOV     DPL,?V0 + 0
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   C0E0         PUSH    A
   \   000049   7413         MOV     A,#0x13
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   D0E0         POP     A
   \   000050   F0           MOVX    @DPTR,A
   1798                 temp_water_gage.water_gage_value[1]=Msg[4];
   \   000051   EE           MOV     A,R6
   \   000052   2404         ADD     A,#0x4
   \   000054   FE           MOV     R6,A
   \   000055   EF           MOV     A,R7
   \   000056   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000059   C0E0         PUSH    A
   \   00005B   7414         MOV     A,#0x14
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   D0E0         POP     A
   \   000062   F0           MOVX    @DPTR,A
   1799                 fill_AppHead((AppHead_t *)&temp_water_gage.AppHead, ACK_NO, MAIN_VERSION, SUB_VERSION, TYPE_SENSOR, TYPE_CODE_SENSOR_WATER_GAGE);
   \   000063                ; Setup parameters for call to function fill_AppHead
   \   000063   75..03       MOV     ?V0 + 2,#0x3
   \   000066   78..         MOV     R0,#?V0 + 2
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006B   75..00       MOV     ?V0 + 2,#0x0
   \   00006E   78..         MOV     R0,#?V0 + 2
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000073   7D01         MOV     R5,#0x1
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7900         MOV     R1,#0x0
   \   000079   740B         MOV     A,#0xb
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   AA82         MOV     R2,DPL
   \   000080   AB83         MOV     R3,DPH
   \   000082   12....       LCALL   ??fill_AppHead?relay
   \   000085   7402         MOV     A,#0x2
   \   000087   12....       LCALL   ?DEALLOC_XSTACK8
   1800                 fill_NodeId_time((NodeIdAndTime_t *)&temp_water_gage.NodeIdAndTime,ARM_ID,Zigbee_ID,WATER_GAGE_ID);
   \   00008A                ; Setup parameters for call to function fill_NodeId_time
   \   00008A   7D03         MOV     R5,#0x3
   \   00008C   90....       MOV     DPTR,#Zigbee_ID
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   FC           MOV     R4,A
   \   000091   90....       MOV     DPTR,#ARM_ID
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F9           MOV     R1,A
   \   000096   740D         MOV     A,#0xd
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   AA82         MOV     R2,DPL
   \   00009D   AB83         MOV     R3,DPH
   \   00009F   12....       LCALL   ??fill_NodeId_time?relay
   1801                 SendMsg((uint8 *)&temp_water_gage, sizeof(temp_water_gage), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);
   \   0000A2                ; Setup parameters for call to function SendMsg
   \   0000A2   75..02       MOV     ?V0 + 2,#0x2
   \   0000A5   75..00       MOV     ?V0 + 3,#0x0
   \   0000A8   78..         MOV     R0,#?V0 + 2
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AD   90....       MOV     DPTR,#p2p_test_DstAddr
   \   0000B0   7404         MOV     A,#0x4
   \   0000B2   12....       LCALL   ?PUSH_XSTACK8_X
   \   0000B5   7C20         MOV     R4,#0x20
   \   0000B7   790C         MOV     R1,#0xc
   \   0000B9   740F         MOV     A,#0xf
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   AA82         MOV     R2,DPL
   \   0000C0   AB83         MOV     R3,DPH
   \   0000C2   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   0000C5   12....       LCALL   ?DEALLOC_XSTACK8
   1802           
   1803              
   1804          //自己编写
   1805            
   1806                 uint16 temp_Water_gage_data = BUILD_UINT16(Msg[4], Msg[3]);
   \   0000C8   8E82         MOV     DPL,R6
   \   0000CA   8F83         MOV     DPH,R7
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   FA           MOV     R2,A
   \   0000CE   85..82       MOV     DPL,?V0 + 0
   \   0000D1   85..83       MOV     DPH,?V0 + 1
   \   0000D4   12....       LCALL   ?Subroutine23 & 0xFFFF
   1807            //HalUARTWrite(0,(uint8 *)&(temp_water_gage.water_gage_value),sizeof(temp_water_gage.water_gage_value));
   1808            //uint16 data = BUILD_UINT16(Msg[3], Msg[4]);
   1809            //HalUARTWrite(0,(uint8*)&data, sizeof(data));
   1810          #if DEBUG
   1811            //用于测试
   1812               uint8 a1 =1;
   \                     ??CrossCallReturnLabel_65:
   \   0000D7   7401         MOV     A,#0x1
   \   0000D9   85..82       MOV     DPL,?XSP + 0
   \   0000DC   85..83       MOV     DPH,?XSP + 1
   \   0000DF   F0           MOVX    @DPTR,A
   1813               uint8 a2 =2;
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   7402         MOV     A,#0x2
   \   0000E5   F0           MOVX    @DPTR,A
   1814               uint8 a3 =3;
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   7403         MOV     A,#0x3
   \   0000EB   F0           MOVX    @DPTR,A
   1815               uint8 a4 =4;
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   7404         MOV     A,#0x4
   \   0000F1   F0           MOVX    @DPTR,A
   1816          #endif
   1817           
   1818               //以WaterGageUnit == 3为默认情况存入数据及预测
   1819               if(WaterGageUnit == 0)
   \   0000F2   90....       MOV     DPTR,#WaterGageUnit
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   7002         JNZ     ??p2p_test_RecvFromUart_1
   \   0000F8   A3           INC     DPTR
   \   0000F9   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_1:
   \   0000FA   7033         JNZ     ??p2p_test_RecvFromUart_2
   1820               {
   1821                 Water_Gage_data_and_time.data[Water_gage_SerialNumber%3]=Water_gage_data_span - temp_Water_gage_data*10;
   \   0000FC   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0000FF   12....       LCALL   ?US_DIV_MOD
   \   000102   8A..         MOV     ?V0 + 2,R2
   \   000104   8B..         MOV     ?V0 + 3,R3
   \   000106   E5..         MOV     A,?V0 + 0
   \   000108   75F00A       MOV     B,#0xa
   \   00010B   A4           MUL     AB
   \   00010C   F8           MOV     R0,A
   \   00010D   ACF0         MOV     R4,B
   \   00010F   75F00A       MOV     B,#0xa
   \   000112   E5..         MOV     A,?V0 + 1
   \   000114   A4           MUL     AB
   \   000115   2C           ADD     A,R4
   \   000116   F9           MOV     R1,A
   \   000117   7430         MOV     A,#0x30
   \   000119   C3           CLR     C
   \   00011A   98           SUBB    A,R0
   \   00011B   FC           MOV     R4,A
   \   00011C   7475         MOV     A,#0x75
   \   00011E   99           SUBB    A,R1
   \                     ??p2p_test_RecvFromUart_3:
   \   00011F   FD           MOV     R5,A
   \   000120   EA           MOV     A,R2
   \   000121   F8           MOV     R0,A
   \   000122   EB           MOV     A,R3
   \   000123   F9           MOV     R1,A
   \   000124   E8           MOV     A,R0
   \   000125   C3           CLR     C
   \   000126   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000129   EC           MOV     A,R4
   \   00012A   F0           MOVX    @DPTR,A
   \   00012B   A3           INC     DPTR
   \   00012C   ED           MOV     A,R5
   \   00012D   806D         SJMP    ??p2p_test_RecvFromUart_4
   1822                 Water_Gage_data_and_time.time[Water_gage_SerialNumber%3]= now;
   1823          #if DEBUG
   1824                // HalUARTWrite(0,&a1, sizeof(a1));
   1825          #endif
   1826               }
   1827               else if(WaterGageUnit == 1)
   \                     ??p2p_test_RecvFromUart_2:
   \   00012F   90....       MOV     DPTR,#WaterGageUnit
   \   000132   E0           MOVX    A,@DPTR
   \   000133   6401         XRL     A,#0x1
   \   000135   7002         JNZ     ??p2p_test_RecvFromUart_5
   \   000137   A3           INC     DPTR
   \   000138   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_5:
   \   000139   7015         JNZ     ??p2p_test_RecvFromUart_6
   1828               {
   1829                 Water_Gage_data_and_time.data[Water_gage_SerialNumber%3]=Water_gage_data_span - temp_Water_gage_data;
   \   00013B   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00013E   12....       LCALL   ?US_DIV_MOD
   \   000141   8A..         MOV     ?V0 + 2,R2
   \   000143   8B..         MOV     ?V0 + 3,R3
   \   000145   7430         MOV     A,#0x30
   \   000147   95..         SUBB    A,?V0 + 0
   \   000149   FC           MOV     R4,A
   \   00014A   7475         MOV     A,#0x75
   \   00014C   95..         SUBB    A,?V0 + 1
   \   00014E   80CF         SJMP    ??p2p_test_RecvFromUart_3
   1830                 Water_Gage_data_and_time.time[Water_gage_SerialNumber%3]= now;    
   1831                 //HalUARTWrite(0,&a2, sizeof(a2));
   1832               }
   1833               else if(WaterGageUnit == 2)
   \                     ??p2p_test_RecvFromUart_6:
   \   000150   90....       MOV     DPTR,#WaterGageUnit
   \   000153   E0           MOVX    A,@DPTR
   \   000154   6402         XRL     A,#0x2
   \   000156   7002         JNZ     ??p2p_test_RecvFromUart_7
   \   000158   A3           INC     DPTR
   \   000159   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_7:
   \   00015A   701C         JNZ     ??p2p_test_RecvFromUart_8
   1834               {
   1835                 Water_Gage_data_and_time.data[Water_gage_SerialNumber%3]=temp_Water_gage_data*10;
   \   00015C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00015F   12....       LCALL   ?US_DIV_MOD
   \   000162   8A..         MOV     ?V0 + 2,R2
   \   000164   8B..         MOV     ?V0 + 3,R3
   \   000166   E5..         MOV     A,?V0 + 0
   \   000168   75F00A       MOV     B,#0xa
   \   00016B   A4           MUL     AB
   \   00016C   FC           MOV     R4,A
   \   00016D   AEF0         MOV     R6,B
   \   00016F   75F00A       MOV     B,#0xa
   \   000172   E5..         MOV     A,?V0 + 1
   \   000174   A4           MUL     AB
   \   000175   2E           ADD     A,R6
   \   000176   80A7         SJMP    ??p2p_test_RecvFromUart_3
   1836                 Water_Gage_data_and_time.time[Water_gage_SerialNumber%3]= now;
   1837                 //HalUARTWrite(0,&a3, sizeof(a3));       
   1838               }
   1839               else if(WaterGageUnit == 3)
   \                     ??p2p_test_RecvFromUart_8:
   \   000178   90....       MOV     DPTR,#WaterGageUnit
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   6403         XRL     A,#0x3
   \   00017E   7002         JNZ     ??p2p_test_RecvFromUart_9
   \   000180   A3           INC     DPTR
   \   000181   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_9:
   \   000182   7043         JNZ     ??p2p_test_RecvFromUart_10
   1840               {
   1841                 Water_Gage_data_and_time.data[Water_gage_SerialNumber%3]=temp_Water_gage_data;
   \   000184   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000187   12....       LCALL   ?US_DIV_MOD
   \   00018A   8A..         MOV     ?V0 + 2,R2
   \   00018C   8B..         MOV     ?V0 + 3,R3
   \   00018E   EA           MOV     A,R2
   \   00018F   F8           MOV     R0,A
   \   000190   EB           MOV     A,R3
   \   000191   F9           MOV     R1,A
   \   000192   E8           MOV     A,R0
   \   000193   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000196   E5..         MOV     A,?V0 + 0
   \   000198   F0           MOVX    @DPTR,A
   \   000199   A3           INC     DPTR
   \   00019A   E5..         MOV     A,?V0 + 1
   \                     ??p2p_test_RecvFromUart_4:
   \   00019C   F0           MOVX    @DPTR,A
   1842                 Water_Gage_data_and_time.time[Water_gage_SerialNumber%3]= now;  
   \   00019D   90....       MOV     DPTR,#now
   \   0001A0   78..         MOV     R0,#?V0 + 4
   \   0001A2   12....       LCALL   ?L_MOV_X
   \   0001A5   7402         MOV     A,#0x2
   \   0001A7   78..         MOV     R0,#?V0 + 2
   \   0001A9   12....       LCALL   ?S_SHL
   \   0001AC   E5..         MOV     A,?V0 + 2
   \   0001AE   24..         ADD     A,#((Water_Gage_data_and_time + 6) & 0xff)
   \   0001B0   F582         MOV     DPL,A
   \   0001B2   E5..         MOV     A,?V0 + 3
   \   0001B4   34..         ADDC    A,#(((Water_Gage_data_and_time + 6) >> 8) & 0xff)
   \   0001B6   F583         MOV     DPH,A
   \   0001B8   E5..         MOV     A,?V0 + 4
   \   0001BA   F0           MOVX    @DPTR,A
   \   0001BB   A3           INC     DPTR
   \   0001BC   E5..         MOV     A,?V0 + 5
   \   0001BE   F0           MOVX    @DPTR,A
   \   0001BF   A3           INC     DPTR
   \   0001C0   E5..         MOV     A,?V0 + 6
   \   0001C2   F0           MOVX    @DPTR,A
   \   0001C3   A3           INC     DPTR
   \   0001C4   E5..         MOV     A,?V0 + 7
   \   0001C6   F0           MOVX    @DPTR,A
   1843                 //HalUARTWrite(0,&a4, sizeof(a4));
   1844               }       
   1845                // HalUARTWrite(0,(uint8*)&Water_Gage_data_and_time.time[0], sizeof(Water_Gage_data_and_time.time[0]));
   1846                // HalUARTWrite(0,(uint8*)&Water_Gage_data_and_time.time[1], sizeof(Water_Gage_data_and_time.time[1]));
   1847                // HalUARTWrite(0,(uint8*)&Water_Gage_data_and_time.time[2], sizeof(Water_Gage_data_and_time.time[2]));
   1848                 
   1849               //  HalUARTWrite(0,(uint8*)& Water_Gage_data_and_time.data[Water_gage_SerialNumber%3], sizeof( Water_Gage_data_and_time.data[Water_gage_SerialNumber%3]));
   1850                 Water_gage_SerialNumber++;
   \                     ??p2p_test_RecvFromUart_10:
   \   0001C7   90....       MOV     DPTR,#Water_gage_SerialNumber
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   2401         ADD     A,#0x1
   \   0001CD   F0           MOVX    @DPTR,A
   \   0001CE   A3           INC     DPTR
   \   0001CF   E0           MOVX    A,@DPTR
   \   0001D0   3400         ADDC    A,#0x0
   \   0001D2   F0           MOVX    @DPTR,A
   1851            
   1852            //根据预测值选择定时器时间
   1853                 if(Water_gage_SerialNumber >=4)
   \   0001D3   90....       MOV     DPTR,#Water_gage_SerialNumber
   \   0001D6   C3           CLR     C
   \   0001D7   E0           MOVX    A,@DPTR
   \   0001D8   9404         SUBB    A,#0x4
   \   0001DA   A3           INC     DPTR
   \   0001DB   E0           MOVX    A,@DPTR
   \   0001DC   9400         SUBB    A,#0x0
   \   0001DE   5003         JNC     $+5
   \   0001E0   02....       LJMP    ??p2p_test_RecvFromUart_11 & 0xFFFF
   1854                     {
   1855                      if(WaterGageUnit == 0)
   \   0001E3   90....       MOV     DPTR,#WaterGageUnit
   \   0001E6   E0           MOVX    A,@DPTR
   \   0001E7   7002         JNZ     ??p2p_test_RecvFromUart_12
   \   0001E9   A3           INC     DPTR
   \   0001EA   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_12:
   \   0001EB   705A         JNZ     ??p2p_test_RecvFromUart_13
   1856                      {
   1857                       Water_gage_err = ((Water_gage_data_span - temp_Water_gage_data*10) >Water_gage_forValue )? 
   1858                          ( (Water_gage_data_span - temp_Water_gage_data*10)- Water_gage_forValue) : 
   1859                           (Water_gage_forValue -(Water_gage_data_span - temp_Water_gage_data*10));    
   \   0001ED   90....       MOV     DPTR,#Water_gage_forValue
   \   0001F0   E5..         MOV     A,?V0 + 0
   \   0001F2   75F00A       MOV     B,#0xa
   \   0001F5   A4           MUL     AB
   \   0001F6   F8           MOV     R0,A
   \   0001F7   AAF0         MOV     R2,B
   \   0001F9   75F00A       MOV     B,#0xa
   \   0001FC   E5..         MOV     A,?V0 + 1
   \   0001FE   A4           MUL     AB
   \   0001FF   2A           ADD     A,R2
   \   000200   F9           MOV     R1,A
   \   000201   7430         MOV     A,#0x30
   \   000203   C3           CLR     C
   \   000204   98           SUBB    A,R0
   \   000205   F8           MOV     R0,A
   \   000206   7475         MOV     A,#0x75
   \   000208   99           SUBB    A,R1
   \   000209   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00020C   5016         JNC     ??p2p_test_RecvFromUart_14
   \   00020E   E5..         MOV     A,?V0 + 0
   \   000210   75F00A       MOV     B,#0xa
   \   000213   A4           MUL     AB
   \   000214   F5..         MOV     ?V0 + 0,A
   \   000216   75F00A       MOV     B,#0xa
   \   000219   E5..         MOV     A,?V0 + 1
   \   00021B   A4           MUL     AB
   \   00021C   2A           ADD     A,R2
   \   00021D   F5..         MOV     ?V0 + 1,A
   \   00021F   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000222   8017         SJMP    ??CrossCallReturnLabel_32
   \                     ??p2p_test_RecvFromUart_14:
   \   000224   90....       MOV     DPTR,#Water_gage_forValue
   \   000227   E5..         MOV     A,?V0 + 0
   \   000229   75F00A       MOV     B,#0xa
   \   00022C   A4           MUL     AB
   \   00022D   F5..         MOV     ?V0 + 0,A
   \   00022F   75F00A       MOV     B,#0xa
   \   000232   E5..         MOV     A,?V0 + 1
   \   000234   A4           MUL     AB
   \   000235   2A           ADD     A,R2
   \   000236   F5..         MOV     ?V0 + 1,A
   \   000238   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00023B   12....       LCALL   ?Subroutine28 & 0xFFFF
   1860          #if DEBUG
   1861                           HalUARTWrite(0,&a1, sizeof(a1));
   \                     ??CrossCallReturnLabel_159:
   \   00023E   85..82       MOV     DPL,?XSP + 0
   \   000241   85..83       MOV     DPH,?XSP + 1
   \   000244   02....       LJMP    ??p2p_test_RecvFromUart_15 & 0xFFFF
   1862          #endif
   1863                      }
   1864                      else if(WaterGageUnit == 1)
   \                     ??p2p_test_RecvFromUart_13:
   \   000247   90....       MOV     DPTR,#WaterGageUnit
   \   00024A   E0           MOVX    A,@DPTR
   \   00024B   6401         XRL     A,#0x1
   \   00024D   7002         JNZ     ??p2p_test_RecvFromUart_16
   \   00024F   A3           INC     DPTR
   \   000250   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_16:
   \   000251   7024         JNZ     ??p2p_test_RecvFromUart_17
   1865                      {
   1866                       Water_gage_err = ((Water_gage_data_span - temp_Water_gage_data) >Water_gage_forValue )? 
   1867                          ( (Water_gage_data_span - temp_Water_gage_data)- Water_gage_forValue) : 
   1868                           (Water_gage_forValue -(Water_gage_data_span - temp_Water_gage_data));                 
   \   000253   90....       MOV     DPTR,#Water_gage_forValue
   \   000256   7430         MOV     A,#0x30
   \   000258   C3           CLR     C
   \   000259   95..         SUBB    A,?V0 + 0
   \   00025B   F8           MOV     R0,A
   \   00025C   7475         MOV     A,#0x75
   \   00025E   95..         SUBB    A,?V0 + 1
   \   000260   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000263   5005         JNC     ??p2p_test_RecvFromUart_18
   \   000265   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000268   8006         SJMP    ??CrossCallReturnLabel_33
   \                     ??p2p_test_RecvFromUart_18:
   \   00026A   90....       MOV     DPTR,#Water_gage_forValue
   \   00026D   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000270   12....       LCALL   ?Subroutine28 & 0xFFFF
   1869          #if DEBUG
   1870                           HalUARTWrite(0,&a2, sizeof(a2));
   \                     ??CrossCallReturnLabel_160:
   \   000273   EC           MOV     A,R4
   \   000274   02....       LJMP    ??p2p_test_RecvFromUart_19 & 0xFFFF
   1871          #endif
   1872                      }
   1873                      else if(WaterGageUnit == 2)
   \                     ??p2p_test_RecvFromUart_17:
   \   000277   90....       MOV     DPTR,#WaterGageUnit
   \   00027A   E0           MOVX    A,@DPTR
   \   00027B   6402         XRL     A,#0x2
   \   00027D   7002         JNZ     ??p2p_test_RecvFromUart_20
   \   00027F   A3           INC     DPTR
   \   000280   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_20:
   \   000281   705D         JNZ     ??p2p_test_RecvFromUart_21
   1874                      {
   1875                       Water_gage_err = (temp_Water_gage_data*10 >Water_gage_forValue )? 
   1876                          (temp_Water_gage_data*10- Water_gage_forValue) : 
   1877                           (Water_gage_forValue -temp_Water_gage_data*10);
   \   000283   90....       MOV     DPTR,#Water_gage_forValue
   \   000286   E5..         MOV     A,?V0 + 0
   \   000288   75F00A       MOV     B,#0xa
   \   00028B   A4           MUL     AB
   \   00028C   F8           MOV     R0,A
   \   00028D   AAF0         MOV     R2,B
   \   00028F   75F00A       MOV     B,#0xa
   \   000292   E5..         MOV     A,?V0 + 1
   \   000294   A4           MUL     AB
   \   000295   2A           ADD     A,R2
   \   000296   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000299   5021         JNC     ??p2p_test_RecvFromUart_22
   \   00029B   E5..         MOV     A,?V0 + 0
   \   00029D   75F00A       MOV     B,#0xa
   \   0002A0   A4           MUL     AB
   \   0002A1   F5..         MOV     ?V0 + 0,A
   \   0002A3   75F00A       MOV     B,#0xa
   \   0002A6   E5..         MOV     A,?V0 + 1
   \   0002A8   A4           MUL     AB
   \   0002A9   2A           ADD     A,R2
   \   0002AA   F5..         MOV     ?V0 + 1,A
   \   0002AC   90....       MOV     DPTR,#Water_gage_forValue
   \   0002AF   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0002B2   E5..         MOV     A,?V0 + 0
   \   0002B4   C3           CLR     C
   \   0002B5   98           SUBB    A,R0
   \   0002B6   F8           MOV     R0,A
   \   0002B7   E5..         MOV     A,?V0 + 1
   \   0002B9   99           SUBB    A,R1
   \   0002BA   801D         SJMP    ??p2p_test_RecvFromUart_23
   \                     ??p2p_test_RecvFromUart_22:
   \   0002BC   90....       MOV     DPTR,#Water_gage_forValue
   \   0002BF   E5..         MOV     A,?V0 + 0
   \   0002C1   75F00A       MOV     B,#0xa
   \   0002C4   A4           MUL     AB
   \   0002C5   F5..         MOV     ?V0 + 0,A
   \   0002C7   75F00A       MOV     B,#0xa
   \   0002CA   E5..         MOV     A,?V0 + 1
   \   0002CC   A4           MUL     AB
   \   0002CD   2A           ADD     A,R2
   \   0002CE   F5..         MOV     ?V0 + 1,A
   \   0002D0   E0           MOVX    A,@DPTR
   \   0002D1   C3           CLR     C
   \   0002D2   95..         SUBB    A,?V0 + 0
   \   0002D4   F8           MOV     R0,A
   \   0002D5   A3           INC     DPTR
   \   0002D6   E0           MOVX    A,@DPTR
   \   0002D7   95..         SUBB    A,?V0 + 1
   \                     ??p2p_test_RecvFromUart_23:
   \   0002D9   12....       LCALL   ?Subroutine28 & 0xFFFF
   1878          #if DEBUG
   1879                           HalUARTWrite(0,&a3, sizeof(a3));                 
   \                     ??CrossCallReturnLabel_161:
   \   0002DC   7402         MOV     A,#0x2
   \   0002DE   8038         SJMP    ??p2p_test_RecvFromUart_19
   1880          #endif
   1881                      } 
   1882                      else if(WaterGageUnit == 3)
   \                     ??p2p_test_RecvFromUart_21:
   \   0002E0   90....       MOV     DPTR,#WaterGageUnit
   \   0002E3   E0           MOVX    A,@DPTR
   \   0002E4   6403         XRL     A,#0x3
   \   0002E6   7002         JNZ     ??p2p_test_RecvFromUart_24
   \   0002E8   A3           INC     DPTR
   \   0002E9   E0           MOVX    A,@DPTR
   \                     ??p2p_test_RecvFromUart_24:
   \   0002EA   7038         JNZ     ??p2p_test_RecvFromUart_25
   1883                      {
   1884                       Water_gage_err = (temp_Water_gage_data >Water_gage_forValue )? 
   1885                          (temp_Water_gage_data- Water_gage_forValue) : 
   1886                           (Water_gage_forValue -temp_Water_gage_data); 
   \   0002EC   90....       MOV     DPTR,#Water_gage_forValue
   \   0002EF   C3           CLR     C
   \   0002F0   E0           MOVX    A,@DPTR
   \   0002F1   95..         SUBB    A,?V0 + 0
   \   0002F3   A3           INC     DPTR
   \   0002F4   E0           MOVX    A,@DPTR
   \   0002F5   95..         SUBB    A,?V0 + 1
   \   0002F7   90....       MOV     DPTR,#Water_gage_forValue
   \   0002FA   E0           MOVX    A,@DPTR
   \   0002FB   500E         JNC     ??p2p_test_RecvFromUart_26
   \   0002FD   F8           MOV     R0,A
   \   0002FE   A3           INC     DPTR
   \   0002FF   E0           MOVX    A,@DPTR
   \   000300   F9           MOV     R1,A
   \   000301   E5..         MOV     A,?V0 + 0
   \   000303   C3           CLR     C
   \   000304   98           SUBB    A,R0
   \   000305   F8           MOV     R0,A
   \   000306   E5..         MOV     A,?V0 + 1
   \   000308   99           SUBB    A,R1
   \   000309   8008         SJMP    ??p2p_test_RecvFromUart_27
   \                     ??p2p_test_RecvFromUart_26:
   \   00030B   C3           CLR     C
   \   00030C   95..         SUBB    A,?V0 + 0
   \   00030E   F8           MOV     R0,A
   \   00030F   A3           INC     DPTR
   \   000310   E0           MOVX    A,@DPTR
   \   000311   95..         SUBB    A,?V0 + 1
   \                     ??p2p_test_RecvFromUart_27:
   \   000313   12....       LCALL   ?Subroutine28 & 0xFFFF
   1887          #if DEBUG
   1888                           HalUARTWrite(0,&a4, sizeof(a4));
   \                     ??CrossCallReturnLabel_162:
   \   000316   7403         MOV     A,#0x3
   \                     ??p2p_test_RecvFromUart_19:
   \   000318   12....       LCALL   ?XSTACK_DISP0_8
   \                     ??p2p_test_RecvFromUart_15:
   \   00031B   AA82         MOV     R2,DPL
   \   00031D   AB83         MOV     R3,DPH
   \   00031F   7900         MOV     R1,#0x0
   \   000321   12....       LCALL   ??HalUARTWrite?relay
   1889          #endif
   1890                      }     
   1891                      
   1892          #if DEBUG
   1893                      HalUARTWrite_uint16(Water_gage_err);
   \                     ??p2p_test_RecvFromUart_25:
   \   000324                ; Setup parameters for call to function HalUARTWrite_uint16
   \   000324   90....       MOV     DPTR,#Water_gage_err
   \   000327   12....       LCALL   ??Subroutine3_0 & 0xFFFF
   1894          #endif
   1895                      
   1896                      
   1897                      
   1898                      
   1899                       if( Water_gage_err < Water_gage_err_a )
   \                     ??CrossCallReturnLabel_16:
   \   00032A   90....       MOV     DPTR,#Water_gage_err_a
   \   00032D   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000330   5018         JNC     ??p2p_test_RecvFromUart_28
   1900                       {
   1901                         SendWaterGageTimeFreq += 2*Water_gage_time;
   \   000332   90....       MOV     DPTR,#Water_gage_time
   \   000335   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000338   E8           MOV     A,R0
   \   000339   C3           CLR     C
   \   00033A   33           RLC     A
   \   00033B   F8           MOV     R0,A
   \   00033C   E9           MOV     A,R1
   \   00033D   33           RLC     A
   \   00033E   F9           MOV     R1,A
   \   00033F   12....       LCALL   ?Subroutine18 & 0xFFFF
   1902          #if DEBUG
   1903                         HalUARTWrite(0,&a1, sizeof(a1));
   \                     ??CrossCallReturnLabel_157:
   \   000342   85..82       MOV     DPL,?XSP + 0
   \   000345   85..83       MOV     DPH,?XSP + 1
   \   000348   805C         SJMP    ??p2p_test_RecvFromUart_29
   1904          #endif
   1905                       }
   1906          
   1907                       else if((Water_gage_err >= Water_gage_err_a) && ( Water_gage_err < Water_gage_err_b))  
   \                     ??p2p_test_RecvFromUart_28:
   \   00034A   90....       MOV     DPTR,#Water_gage_err_b
   \   00034D   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000350   500C         JNC     ??p2p_test_RecvFromUart_30
   1908                       {
   1909                         SendWaterGageTimeFreq += Water_gage_time;
   \   000352   90....       MOV     DPTR,#Water_gage_time
   \   000355   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000358   12....       LCALL   ?Subroutine18 & 0xFFFF
   1910          #if DEBUG
   1911                         HalUARTWrite(0,&a2, sizeof(a2));
   \                     ??CrossCallReturnLabel_158:
   \   00035B   EC           MOV     A,R4
   \   00035C   8045         SJMP    ??p2p_test_RecvFromUart_31
   1912          #endif
   1913                       }
   1914                      else if((Water_gage_err >= Water_gage_err_b) && ( Water_gage_err < Water_gage_err_c))
   \                     ??p2p_test_RecvFromUart_30:
   \   00035E   90....       MOV     DPTR,#Water_gage_err_c
   \   000361   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000364   5029         JNC     ??p2p_test_RecvFromUart_32
   1915                       {
   1916                         if(SendWaterGageTimeFreq >=Water_gage_time)
   \   000366   90....       MOV     DPTR,#Water_gage_time
   \   000369   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00036C   7583..       MOV     DPH,#((SendWaterGageTimeFreq >> 8) & 0xff)
   \   00036F   7582..       MOV     DPL,#(SendWaterGageTimeFreq & 0xff)
   \   000372   12....       LCALL   ??Subroutine22_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000375   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   000378   4009         JC      ??p2p_test_RecvFromUart_33
   1917                           SendWaterGageTimeFreq -= Water_gage_time;
   \   00037A   C3           CLR     C
   \   00037B   E0           MOVX    A,@DPTR
   \   00037C   98           SUBB    A,R0
   \   00037D   F0           MOVX    @DPTR,A
   \   00037E   A3           INC     DPTR
   \   00037F   E0           MOVX    A,@DPTR
   \   000380   99           SUBB    A,R1
   \   000381   8005         SJMP    ??p2p_test_RecvFromUart_34
   1918                         else
   1919                           SendWaterGageTimeFreq = 60;
   \                     ??p2p_test_RecvFromUart_33:
   \   000383   743C         MOV     A,#0x3c
   \   000385   F0           MOVX    @DPTR,A
   \   000386   A3           INC     DPTR
   \   000387   E4           CLR     A
   \                     ??p2p_test_RecvFromUart_34:
   \   000388   12....       LCALL   ?Subroutine55 & 0xFFFF
   1920          #if DEBUG
   1921                         HalUARTWrite(0,&a3, sizeof(a3));
   \                     ??CrossCallReturnLabel_164:
   \   00038B   7402         MOV     A,#0x2
   \   00038D   8014         SJMP    ??p2p_test_RecvFromUart_31
   1922          #endif
   1923                       }
   1924                       else if (Water_gage_err >= Water_gage_err_c)
   1925                       {
   1926                         SendWaterGageTimeFreq = (SendWaterGageTimeFreq/2) ;
   \                     ??p2p_test_RecvFromUart_32:
   \   00038F   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   000392   E0           MOVX    A,@DPTR
   \   000393   F8           MOV     R0,A
   \   000394   A3           INC     DPTR
   \   000395   E0           MOVX    A,@DPTR
   \   000396   C3           CLR     C
   \   000397   13           RRC     A
   \   000398   F9           MOV     R1,A
   \   000399   E8           MOV     A,R0
   \   00039A   13           RRC     A
   \   00039B   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   00039E   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   1927          #if DEBUG
   1928                         HalUARTWrite(0,&a4, sizeof(a4));
   \                     ??CrossCallReturnLabel_163:
   \   0003A1   7403         MOV     A,#0x3
   \                     ??p2p_test_RecvFromUart_31:
   \   0003A3   12....       LCALL   ?XSTACK_DISP0_8
   \                     ??p2p_test_RecvFromUart_29:
   \   0003A6   AA82         MOV     R2,DPL
   \   0003A8   AB83         MOV     R3,DPH
   \   0003AA   7900         MOV     R1,#0x0
   \   0003AC   12....       LCALL   ??HalUARTWrite?relay
   1929          #endif
   1930                       }
   1931                     }
   1932                 // HalUARTWrite(0,(uint8*)&Water_gage_forValue, sizeof(Water_gage_forValue));
   1933                 // HalUARTWrite(0,(uint8*)&Water_gage_err, sizeof(Water_gage_err));      
   1934                 // HalUARTWrite(0,(uint8*)&SendWaterGageTimeFreq, sizeof(SendWaterGageTimeFreq));
   1935                 // HalUARTWrite(0,(uint8*)&UartHead, sizeof(UartHead))
   1936                 if ( SendWaterGageTimeFreq > 8*Water_gage_time )
   \                     ??p2p_test_RecvFromUart_11:
   \   0003AF   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0003B2   12....       LCALL   ?S_SHL
   \   0003B5   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   0003B8   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0003BB   C3           CLR     C
   \   0003BC   E5..         MOV     A,?V0 + 0
   \   0003BE   98           SUBB    A,R0
   \   0003BF   E5..         MOV     A,?V0 + 1
   \   0003C1   99           SUBB    A,R1
   \   0003C2   5011         JNC     ??p2p_test_RecvFromUart_35
   1937                       SendWaterGageTimeFreq = 8*Water_gage_time;
   \   0003C4   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0003C7   12....       LCALL   ?S_SHL
   \   0003CA   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   0003CD   E5..         MOV     A,?V0 + 0
   \   0003CF   F0           MOVX    @DPTR,A
   \   0003D0   A3           INC     DPTR
   \   0003D1   E5..         MOV     A,?V0 + 1
   \   0003D3   8015         SJMP    ??p2p_test_RecvFromUart_36
   1938                 else if( SendWaterGageTimeFreq < 60)
   \                     ??p2p_test_RecvFromUart_35:
   \   0003D5   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   0003D8   C3           CLR     C
   \   0003D9   E0           MOVX    A,@DPTR
   \   0003DA   943C         SUBB    A,#0x3c
   \   0003DC   A3           INC     DPTR
   \   0003DD   E0           MOVX    A,@DPTR
   \   0003DE   9400         SUBB    A,#0x0
   \   0003E0   5009         JNC     ??p2p_test_RecvFromUart_37
   1939                       SendWaterGageTimeFreq = 60;
   \   0003E2   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   0003E5   743C         MOV     A,#0x3c
   \   0003E7   F0           MOVX    @DPTR,A
   \   0003E8   A3           INC     DPTR
   \   0003E9   E4           CLR     A
   \                     ??p2p_test_RecvFromUart_36:
   \   0003EA   F0           MOVX    @DPTR,A
   1940                  //HalUARTWrite(0,(uint8*)&SendWaterGageTimeFreq, sizeof(SendWaterGageTimeFreq));
   1941          #if DEBUG
   1942                 HalUARTWrite_uint16(SendWaterGageTimeFreq);
   \                     ??p2p_test_RecvFromUart_37:
   \   0003EB                ; Setup parameters for call to function HalUARTWrite_uint16
   \   0003EB   12....       LCALL   ?Subroutine3 & 0xFFFF
   1943          #endif
   1944                 
   1945            //从收到第三个数据后开始预测下一个数据
   1946                 if(Water_gage_SerialNumber>=3)
   \                     ??CrossCallReturnLabel_12:
   \   0003EE   90....       MOV     DPTR,#Water_gage_SerialNumber
   \   0003F1   C3           CLR     C
   \   0003F2   E0           MOVX    A,@DPTR
   \   0003F3   9403         SUBB    A,#0x3
   \   0003F5   A3           INC     DPTR
   \   0003F6   E0           MOVX    A,@DPTR
   \   0003F7   9400         SUBB    A,#0x0
   \   0003F9   4035         JC      ??CrossCallReturnLabel_17
   1947                   {
   1948                       Water_gage_forValue =Water_gage_forecastValue(Water_Gage_data_and_time);
   \   0003FB                ; Setup parameters for call to function Water_gage_forecastValue
   \   0003FB   90....       MOV     DPTR,#Water_Gage_data_and_time
   \   0003FE   7412         MOV     A,#0x12
   \   000400   12....       LCALL   ?PUSH_XSTACK8_X
   \   000403   12....       LCALL   ??Water_gage_forecastValue?relay
   \   000406   7412         MOV     A,#0x12
   \   000408   12....       LCALL   ?DEALLOC_XSTACK8
   \   00040B   90....       MOV     DPTR,#Water_gage_forValue
   \   00040E   EA           MOV     A,R2
   \   00040F   F0           MOVX    @DPTR,A
   \   000410   A3           INC     DPTR
   \   000411   EB           MOV     A,R3
   \   000412   F0           MOVX    @DPTR,A
   1949                        
   1950                       if (Water_gage_forValue > Water_gage_data_span)
   \   000413   90....       MOV     DPTR,#Water_gage_forValue
   \   000416   C3           CLR     C
   \   000417   E0           MOVX    A,@DPTR
   \   000418   9431         SUBB    A,#0x31
   \   00041A   A3           INC     DPTR
   \   00041B   E0           MOVX    A,@DPTR
   \   00041C   9475         SUBB    A,#0x75
   \   00041E   400A         JC      ??p2p_test_RecvFromUart_38
   1951                         Water_gage_forValue = Water_gage_data_span;
   \   000420   90....       MOV     DPTR,#Water_gage_forValue
   \   000423   7430         MOV     A,#0x30
   \   000425   F0           MOVX    @DPTR,A
   \   000426   A3           INC     DPTR
   \   000427   7475         MOV     A,#0x75
   \   000429   F0           MOVX    @DPTR,A
   1952                       //HalUARTWrite(0,(uint8*)&Water_gage_forValue, sizeof(Water_gage_forValue));
   1953          #if DEBUG
   1954                       HalUARTWrite_uint16(Water_gage_forValue);
   \                     ??p2p_test_RecvFromUart_38:
   \   00042A                ; Setup parameters for call to function HalUARTWrite_uint16
   \   00042A   90....       MOV     DPTR,#Water_gage_forValue
   \   00042D   12....       LCALL   ??Subroutine3_0 & 0xFFFF
   1955          #endif
   1956                   } 
   1957          
   1958          //P1_1可用
   1959                 if(acceptance == 1)                    // 项目验收才关闭水位计
   \                     ??CrossCallReturnLabel_17:
   \   000430   90....       MOV     DPTR,#acceptance
   \   000433   E0           MOVX    A,@DPTR
   \   000434   6401         XRL     A,#0x1
   \   000436   700F         JNZ     ??p2p_test_RecvFromUart_39
   1960                 {
   1961                   if(SendWaterGageTimeFreq >= 120)     //关闭水位计门的门限 2min
   \   000438   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   00043B   C3           CLR     C
   \   00043C   E0           MOVX    A,@DPTR
   \   00043D   9478         SUBB    A,#0x78
   \   00043F   A3           INC     DPTR
   \   000440   E0           MOVX    A,@DPTR
   \   000441   9400         SUBB    A,#0x0
   \   000443   4002         JC      ??p2p_test_RecvFromUart_39
   1962                   {
   1963                      P1_1 = 0;                           //关闭水位计
   \   000445   C291         CLR     0x90.1
   1964                   }
   1965                 }
   1966                 water_gage_on = 0;                     //逻辑关闭水位计
   \                     ??p2p_test_RecvFromUart_39:
   \   000447   E4           CLR     A
   \   000448   90....       MOV     DPTR,#water_gage_on
   \   00044B   F0           MOVX    @DPTR,A
   1967                 
   1968                 start_Water_gage_timer();
   \   00044C                ; Setup parameters for call to function start_Water_gage_timer
   \   00044C   12....       LCALL   ??start_Water_gage_timer?relay
   \   00044F   02....       LJMP    ??p2p_test_RecvFromUart_40 & 0xFFFF
   1969            }
   1970              
   1971          
   1972            else
   1973            {// Msg=0xAA 0x55 LEN AppHead(receive from ARM's Relation ACK Msg)
   1974              uint8 temp_arm_id,temp_zigbee_id,temp_res;
   1975              AppHead_t *AppHead = (AppHead_t *)(Msg+3);
   \                     ??p2p_test_RecvFromUart_0:
   \   000452   EE           MOV     A,R6
   \   000453   2403         ADD     A,#0x3
   \   000455   F582         MOV     DPL,A
   \   000457   EF           MOV     A,R7
   \   000458   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   1976                /*---------------------print-------------------*/
   1977               // HalUARTWrite(0,Msg,10);
   1978                /*********************************************/
   1979                if(AppHead->type==TYPE_ACK)
   \                     ??CrossCallReturnLabel_97:
   \   00045B   540F         ANL     A,#0xf
   \   00045D   640F         XRL     A,#0xf
   \   00045F   6003         JZ      $+5
   \   000461   02....       LJMP    ??p2p_test_RecvFromUart_41 & 0xFFFF
   1980                {
   1981                  if(AppHead->TypeCode==RELATION_MSG_DOWN)
   \   000464   A3           INC     DPTR
   \   000465   E0           MOVX    A,@DPTR
   \   000466   6401         XRL     A,#0x1
   \   000468   6003         JZ      $+5
   \   00046A   02....       LJMP    ??p2p_test_RecvFromUart_40 & 0xFFFF
   1982                  {
   1983                    temp_res=(Msg[7]&0xf0)>>4;
   \   00046D   8E82         MOV     DPL,R6
   \   00046F   8F83         MOV     DPH,R7
   \   000471   A3           INC     DPTR
   \   000472   A3           INC     DPTR
   \   000473   A3           INC     DPTR
   \   000474   A3           INC     DPTR
   \   000475   A3           INC     DPTR
   \   000476   A3           INC     DPTR
   \   000477   A3           INC     DPTR
   \   000478   E0           MOVX    A,@DPTR
   \   000479   FA           MOV     R2,A
   \   00047A   C4           SWAP    A
   \   00047B   540F         ANL     A,#0xf
   \   00047D   FB           MOV     R3,A
   1984                    temp_arm_id=(Msg[7]&0x0f);
   \   00047E   740F         MOV     A,#0xf
   \   000480   5A           ANL     A,R2
   \   000481   FA           MOV     R2,A
   1985                    temp_zigbee_id=(Msg[8]&0xf0)>>4;
   \   000482   8E82         MOV     DPL,R6
   \   000484   8F83         MOV     DPH,R7
   \   000486   A3           INC     DPTR
   \   000487   A3           INC     DPTR
   \   000488   A3           INC     DPTR
   \   000489   A3           INC     DPTR
   \   00048A   A3           INC     DPTR
   \   00048B   A3           INC     DPTR
   \   00048C   A3           INC     DPTR
   \   00048D   A3           INC     DPTR
   \   00048E   E0           MOVX    A,@DPTR
   \   00048F   C4           SWAP    A
   \   000490   540F         ANL     A,#0xf
   \   000492   FC           MOV     R4,A
   1986                    if(Zigbee_ID==0 & ARM_ID==0)
   \   000493   90....       MOV     DPTR,#Zigbee_ID
   \   000496   E0           MOVX    A,@DPTR
   \   000497   703C         JNZ     ??p2p_test_RecvFromUart_42
   \   000499   90....       MOV     DPTR,#ARM_ID
   \   00049C   E0           MOVX    A,@DPTR
   \   00049D   7036         JNZ     ??p2p_test_RecvFromUart_42
   1987                    {
   1988                      ack_num=ack_num+1;
   \   00049F   90....       MOV     DPTR,#??ack_num
   \   0004A2   E0           MOVX    A,@DPTR
   \   0004A3   04           INC     A
   \   0004A4   F0           MOVX    @DPTR,A
   1989                      ARM_ID=temp_arm_id;
   \   0004A5   EA           MOV     A,R2
   \   0004A6   90....       MOV     DPTR,#ARM_ID
   \   0004A9   F0           MOVX    @DPTR,A
   1990                      Zigbee_ID= temp_zigbee_id;
   \   0004AA   EC           MOV     A,R4
   \   0004AB   90....       MOV     DPTR,#Zigbee_ID
   \   0004AE   F0           MOVX    @DPTR,A
   1991                      RES=temp_res;
   \   0004AF   EB           MOV     A,R3
   \   0004B0   90....       MOV     DPTR,#RES
   \   0004B3   12....       LCALL   ?Subroutine9 & 0xFFFF
   1992                      Head_Map->addr16=0x0000;
   1993                      Head_Map->Zigbee_id=Zigbee_ID;
   \                     ??CrossCallReturnLabel_31:
   \   0004B6   C0E0         PUSH    A
   \   0004B8   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0004BB   D0E0         POP     A
   \   0004BD   F0           MOVX    @DPTR,A
   1994                      FlagMap=ADDFLAG16(FlagMap,Zigbee_ID); 
   \   0004BE   75..01       MOV     ?V0 + 0,#0x1
   \   0004C1   75..00       MOV     ?V0 + 1,#0x0
   \   0004C4   90....       MOV     DPTR,#Zigbee_ID
   \   0004C7   E0           MOVX    A,@DPTR
   \   0004C8   14           DEC     A
   \   0004C9   78..         MOV     R0,#?V0 + 0
   \   0004CB   12....       LCALL   ?S_SHL
   \   0004CE   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0004D1   F0           MOVX    @DPTR,A
   \   0004D2   02....       LJMP    ??p2p_test_RecvFromUart_40 & 0xFFFF
   1995                    }
   1996                    else if(ARM_ID==temp_arm_id && Zigbee_ID== temp_zigbee_id )
   \                     ??p2p_test_RecvFromUart_42:
   \   0004D5   90....       MOV     DPTR,#ARM_ID
   \   0004D8   E0           MOVX    A,@DPTR
   \   0004D9   6A           XRL     A,R2
   \   0004DA   701B         JNZ     ??p2p_test_RecvFromUart_43
   \   0004DC   90....       MOV     DPTR,#Zigbee_ID
   \   0004DF   E0           MOVX    A,@DPTR
   \   0004E0   6C           XRL     A,R4
   \   0004E1   7014         JNZ     ??p2p_test_RecvFromUart_43
   1997                    { 
   1998                      if(Zigbee_ID!=0)
   \   0004E3   E0           MOVX    A,@DPTR
   \   0004E4   7003         JNZ     $+5
   \   0004E6   02....       LJMP    ??p2p_test_RecvFromUart_40 & 0xFFFF
   1999                      {
   2000                        if(relation_done == 0)
   \   0004E9   90....       MOV     DPTR,#relation_done
   \   0004EC   E0           MOVX    A,@DPTR
   \   0004ED   6003         JZ      $+5
   \   0004EF   02....       LJMP    ??p2p_test_RecvFromUart_40 & 0xFFFF
   2001                        {
   2002                          osal_stop_timerEx( p2p_test_TaskID,p2p_test_SEND_MAINTAIN_MSG_EVT);
   \   0004F2                ; Setup parameters for call to function osal_stop_timerEx
   \   0004F2   12....       LCALL   ?Subroutine12 & 0xFFFF
   2003                          p2p_test_StartDataSensorTimer();
   2004                          relation_done =1;
   \                     ??CrossCallReturnLabel_35:
   \   0004F5   80DA         SJMP    ??CrossCallReturnLabel_73
   2005                        }
   2006                      }
   2007                    }
   2008                    else
   2009                    {
   2010                      afAddrType_t p2p_test_DstAddr_temp;
   2011                      p2p_test_DstAddr_temp.addrMode = (afAddrMode_t) Addr16Bit;
   \                     ??p2p_test_RecvFromUart_43:
   \   0004F7   7406         MOV     A,#0x6
   \   0004F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0004FC   7402         MOV     A,#0x2
   \   0004FE   F0           MOVX    @DPTR,A
   2012                      p2p_test_DstAddr_temp.endPoint = p2p_test_ENDPOINT;
   \   0004FF   7407         MOV     A,#0x7
   \   000501   12....       LCALL   ?XSTACK_DISP0_8
   \   000504   740A         MOV     A,#0xa
   \   000506   F0           MOVX    @DPTR,A
   2013                      p2p_test_DstAddr_temp.addr.shortAddr = temp_shortaddr;
   \   000507   7404         MOV     A,#0x4
   \   000509   12....       LCALL   ?XSTACK_DISP0_8
   \   00050C   12....       LCALL   ?Subroutine30 & 0xFFFF
   2014                      AF_DataRequest( &p2p_test_DstAddr_temp, &p2p_test_epDesc,
   2015                                         p2p_test_RelationMsg,
   2016                                         Msg[2],
   2017                                         Msg+3,
   2018                                         &p2p_test_TransID,
   2019                                         AF_DISCV_ROUTE, AF_DEFAULT_RADIUS);
   \                     ??CrossCallReturnLabel_83:
   \   00050F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000512   75....       MOV     ?V0 + 0,#(p2p_test_TransID & 0xff)
   \   000515   75....       MOV     ?V0 + 1,#((p2p_test_TransID >> 8) & 0xff)
   \   000518   78..         MOV     R0,#?V0 + 0
   \   00051A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00051D   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000520   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000523   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000526   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000529   75..04       MOV     ?V0 + 0,#0x4
   \   00052C   02....       LJMP    ??p2p_test_RecvFromUart_44 & 0xFFFF
   2020                    
   2021                    }
   2022                  }
   2023                }
   2024                else if(AppHead->type==TYPE_COMMAND )
   \                     ??p2p_test_RecvFromUart_41:
   \   00052F   E0           MOVX    A,@DPTR
   \   000530   540F         ANL     A,#0xf
   \   000532   6408         XRL     A,#0x8
   \   000534   6003         JZ      $+5
   \   000536   02....       LJMP    ??p2p_test_RecvFromUart_40 & 0xFFFF
   2025                {
   2026                  temp_arm_id=(Msg[7]&0x0f);
   2027                  temp_zigbee_id=(Msg[8]&0xf0)>>4;
   \   000539   8E82         MOV     DPL,R6
   \   00053B   8F83         MOV     DPH,R7
   \   00053D   A3           INC     DPTR
   \   00053E   A3           INC     DPTR
   \   00053F   A3           INC     DPTR
   \   000540   A3           INC     DPTR
   \   000541   A3           INC     DPTR
   \   000542   A3           INC     DPTR
   \   000543   A3           INC     DPTR
   \   000544   A3           INC     DPTR
   \   000545   E0           MOVX    A,@DPTR
   \   000546   C4           SWAP    A
   \   000547   540F         ANL     A,#0xf
   \   000549   FC           MOV     R4,A
   2028                  if(temp_arm_id==ARM_ID && temp_zigbee_id==Zigbee_ID)
   \   00054A   8E82         MOV     DPL,R6
   \   00054C   8F83         MOV     DPH,R7
   \   00054E   A3           INC     DPTR
   \   00054F   A3           INC     DPTR
   \   000550   A3           INC     DPTR
   \   000551   A3           INC     DPTR
   \   000552   A3           INC     DPTR
   \   000553   A3           INC     DPTR
   \   000554   A3           INC     DPTR
   \   000555   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000558   90....       MOV     DPTR,#ARM_ID
   \   00055B   E0           MOVX    A,@DPTR
   \   00055C   6A           XRL     A,R2
   \   00055D   701C         JNZ     ??p2p_test_RecvFromUart_45
   \   00055F   90....       MOV     DPTR,#Zigbee_ID
   \   000562   E0           MOVX    A,@DPTR
   \   000563   6C           XRL     A,R4
   \   000564   7015         JNZ     ??p2p_test_RecvFromUart_45
   2029                    p2p_test_recv_108clusterId(Msg+3, Msg[2]);
   \   000566                ; Setup parameters for call to function p2p_test_recv_108clusterId
   \   000566   8E82         MOV     DPL,R6
   \   000568   8F83         MOV     DPH,R7
   \   00056A   A3           INC     DPTR
   \   00056B   A3           INC     DPTR
   \   00056C   E0           MOVX    A,@DPTR
   \   00056D   F9           MOV     R1,A
   \   00056E   EE           MOV     A,R6
   \   00056F   2403         ADD     A,#0x3
   \   000571   FA           MOV     R2,A
   \   000572   EF           MOV     A,R7
   \   000573   3400         ADDC    A,#0x0
   \   000575   FB           MOV     R3,A
   \   000576   12....       LCALL   ??p2p_test_recv_108clusterId?relay
   \   000579   8058         SJMP    ??p2p_test_RecvFromUart_40
   2030                  else
   2031                  {
   2032                      afAddrType_t p2p_test_DstAddr_temp;
   2033                      p2p_test_DstAddr_temp.addrMode = (afAddrMode_t) Addr16Bit;
   \                     ??p2p_test_RecvFromUart_45:
   \   00057B   7406         MOV     A,#0x6
   \   00057D   12....       LCALL   ?XSTACK_DISP0_8
   \   000580   7402         MOV     A,#0x2
   \   000582   F0           MOVX    @DPTR,A
   2034                      p2p_test_DstAddr_temp.endPoint = p2p_test_ENDPOINT;
   \   000583   7407         MOV     A,#0x7
   \   000585   12....       LCALL   ?XSTACK_DISP0_8
   \   000588   740A         MOV     A,#0xa
   \   00058A   F0           MOVX    @DPTR,A
   2035                      p2p_test_DstAddr_temp.addr.shortAddr = 0xFFFF;
   \   00058B   7404         MOV     A,#0x4
   \   00058D   12....       LCALL   ?XSTACK_DISP0_8
   \   000590   74FF         MOV     A,#-0x1
   \   000592   F0           MOVX    @DPTR,A
   \   000593   A3           INC     DPTR
   \   000594   F0           MOVX    @DPTR,A
   2036                      AF_DataRequest( &p2p_test_DstAddr_temp, &p2p_test_epDesc,
   2037                                         p2p_test_108ID,
   2038                                         Msg[2],
   2039                                         Msg+3,
   2040                                         &p2p_test_TransID,
   2041                                         AF_DISCV_ROUTE, AF_DEFAULT_RADIUS);
   \   000595                ; Setup parameters for call to function AF_DataRequest
   \   000595   75..0A       MOV     ?V0 + 0,#0xa
   \   000598   78..         MOV     R0,#?V0 + 0
   \   00059A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00059D   75....       MOV     ?V0 + 0,#(p2p_test_TransID & 0xff)
   \   0005A0   75....       MOV     ?V0 + 1,#((p2p_test_TransID >> 8) & 0xff)
   \   0005A3   78..         MOV     R0,#?V0 + 0
   \   0005A5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0005A8   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0005AB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0005AE   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   0005B1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0005B4   75..02       MOV     ?V0 + 0,#0x2
   \                     ??p2p_test_RecvFromUart_44:
   \   0005B7   78..         MOV     R0,#?V0 + 0
   \   0005B9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0005BC   7920         MOV     R1,#0x20
   \   0005BE   7C..         MOV     R4,#(p2p_test_epDesc & 0xff)
   \   0005C0   7D..         MOV     R5,#((p2p_test_epDesc >> 8) & 0xff)
   \   0005C2   740D         MOV     A,#0xd
   \   0005C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0005C7   AA82         MOV     R2,DPL
   \   0005C9   AB83         MOV     R3,DPH
   \   0005CB   12....       LCALL   ??AF_DataRequest?relay
   \   0005CE   7409         MOV     A,#0x9
   \   0005D0   12....       LCALL   ?DEALLOC_XSTACK8
   2042                    
   2043                  }
   2044                    
   2045                }
   2046          
   2047              
   2048              
   2049              //Msg = 0xAA 0x55 LEN shortaddr0 shortaddr1 DATA (Not include check, add short addr)
   2050            //temporarily not consider broadcast
   2051              /*
   2052                  uint16 shortAddr_temp = BUILD_UINT16(Msg[4], Msg[3]);
   2053                  AppHead_t *AppHead = (AppHead_t *)(Msg+5);
   2054                  uint8 SendOption;
   2055                  if(AppHead->AckRequire)
   2056                  {
   2057                        SendOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2058                  }
   2059                  else
   2060                  {
   2061                        SendOption = AF_DISCV_ROUTE;
   2062                  }
   2063                  
   2064                  if ( p2p_test_NwkState == DEV_ZB_COORD )
   2065                  {
   2066                    if(shortAddr_temp == 0x0000)
   2067                    {
   2068                      //maybe we will ack to arm if ack is required
   2069                      p2p_test_recv_108clusterId(Msg+5, Msg[2]-2);
   2070                    }
   2071                    else
   2072                    {
   2073                      afAddrType_t p2p_test_DstAddr_temp;
   2074                      p2p_test_DstAddr_temp.addrMode = (afAddrMode_t)Addr16Bit;
   2075                      p2p_test_DstAddr_temp.endPoint = p2p_test_ENDPOINT;
   2076                      p2p_test_DstAddr_temp.addr.shortAddr = shortAddr_temp;
   2077                    
   2078                      AF_DataRequest( &p2p_test_DstAddr_temp, &p2p_test_epDesc,
   2079                                         p2p_test_108ID,
   2080                                         Msg[2]-2,
   2081                                         Msg+5,
   2082                                         &p2p_test_TransID,
   2083                                         SendOption, AF_DEFAULT_RADIUS);//need ack
   2084                
   2085                    }
   2086                  }
   2087              */
   2088              
   2089             }
   2090          }
   \                     ??p2p_test_RecvFromUart_40:
   \   0005D3   7415         MOV     A,#0x15
   \   0005D5   02....       LJMP    ?Subroutine53 & 0xFFFF
   \   0005D8                REQUIRE _A_P1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   33           RLC     A
   \   000001   F8           MOV     R0,A
   \   000002   E9           MOV     A,R1
   \   000003   33           RLC     A
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   24..         ADD     A,#(Water_Gage_data_and_time & 0xff)
   \   000008   F582         MOV     DPL,A
   \   00000A   E9           MOV     A,R1
   \   00000B   34..         ADDC    A,#((Water_Gage_data_and_time >> 8) & 0xff)
   \   00000D   F583         MOV     DPH,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   EE           MOV     A,R6
   \   000001   2403         ADD     A,#0x3
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   F9           MOV     R1,A
   \   000001   90....       MOV     DPTR,#Water_gage_err
   \   000004   E8           MOV     A,R0
   \                     ??Subroutine28_0:
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E9           MOV     A,R1
   \   000008                REQUIRE ?Subroutine55
   \   000008                ; // Fall through to label ?Subroutine55

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 0,A
   \   000009   02....       LJMP    ?Subroutine56 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F9           MOV     R1,A
   \                     ??Subroutine22_0:
   \   000001   C3           CLR     C
   \   000002   E0           MOVX    A,@DPTR
   \   000003   98           SUBB    A,R0
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   99           SUBB    A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   90....       MOV     DPTR,#SendWaterGageTimeFreq
   \   000003   E0           MOVX    A,@DPTR
   \   000004   28           ADD     A,R0
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   39           ADDC    A,R1
   \   000009   80..         SJMP    ?Subroutine55

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   7430         MOV     A,#0x30
   \   000002   C3           CLR     C
   \   000003   95..         SUBB    A,?V0 + 0
   \   000005   FA           MOV     R2,A
   \   000006   7475         MOV     A,#0x75
   \   000008   95..         SUBB    A,?V0 + 1
   \   00000A   FB           MOV     R3,A
   \   00000B   90....       MOV     DPTR,#Water_gage_forValue
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   EA           MOV     A,R2
   \   000014   C3           CLR     C
   \   000015   98           SUBB    A,R0
   \   000016   F8           MOV     R0,A
   \   000017   EB           MOV     A,R3
   \   000018   99           SUBB    A,R1
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   90....       MOV     DPTR,#Water_gage_time
   \   000003   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000006   7403         MOV     A,#0x3
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   25..         ADD     A,?V0 + 0
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   35..         ADDC    A,?V0 + 1
   \   000008   F9           MOV     R1,A
   \   000009   74D0         MOV     A,#-0x30
   \   00000B   28           ADD     A,R0
   \   00000C   F8           MOV     R0,A
   \   00000D   748A         MOV     A,#-0x76
   \   00000F   39           ADDC    A,R1
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   90....       MOV     DPTR,#Water_gage_SerialNumber
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   7A03         MOV     R2,#0x3
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   7583..       MOV     DPH,#((Water_gage_err >> 8) & 0xff)
   \   000005   7582..       MOV     DPL,#(Water_gage_err & 0xff)
   \   000008   C3           CLR     C
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   98           SUBB    A,R0
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??ack_num:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
   2091          
   2092          /*********************************************************************
   2093           * @fn      p2p_test_SendToUart
   2094           *
   2095           * @brief   
   2096           *
   2097           * @param   none
   2098           *
   2099           * @return  none
   2100           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2101          void p2p_test_SendToUart(uint8 *Data, uint8 DataLength)
   \                     p2p_test_SendToUart:
   2102          {  
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   E9           MOV     A,R1
   \   00000F   FE           MOV     R6,A
   2103            UartHeadMsg_t UartHead;
   2104            uint8 check[2],checksum;
   2105            
   2106            UartHead.head[0] = 0xAA;
   \   000010   7401         MOV     A,#0x1
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   74AA         MOV     A,#-0x56
   \   000017   F0           MOVX    @DPTR,A
   2107            UartHead.head[1] = 0x55;
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   7455         MOV     A,#0x55
   \   00001F   F0           MOVX    @DPTR,A
   2108            UartHead.len = DataLength;
   \   000020   7403         MOV     A,#0x3
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E9           MOV     A,R1
   \   000026   F0           MOVX    @DPTR,A
   2109            check[0] = SPIMgr_CalcFCS((uint8*)&UartHead,3);  
   \   000027                ; Setup parameters for call to function SPIMgr_CalcFCS
   \   000027   7903         MOV     R1,#0x3
   \   000029   7401         MOV     A,#0x1
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   AA82         MOV     R2,DPL
   \   000030   AB83         MOV     R3,DPH
   \   000032   12....       LCALL   ??SPIMgr_CalcFCS?relay
   \   000035   7404         MOV     A,#0x4
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E9           MOV     A,R1
   \   00003B   F0           MOVX    @DPTR,A
   2110            check[1] = SPIMgr_CalcFCS(Data,DataLength);
   \   00003C                ; Setup parameters for call to function SPIMgr_CalcFCS
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   AA..         MOV     R2,?V0 + 0
   \   000040   AB..         MOV     R3,?V0 + 1
   \   000042   12....       LCALL   ??SPIMgr_CalcFCS?relay
   \   000045   7405         MOV     A,#0x5
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E9           MOV     A,R1
   \   00004B   F0           MOVX    @DPTR,A
   2111            checksum = SPIMgr_CalcFCS(check,2);
   \   00004C                ; Setup parameters for call to function SPIMgr_CalcFCS
   \   00004C   7902         MOV     R1,#0x2
   \   00004E   7404         MOV     A,#0x4
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   AA82         MOV     R2,DPL
   \   000055   AB83         MOV     R3,DPH
   \   000057   12....       LCALL   ??SPIMgr_CalcFCS?relay
   \   00005A   E9           MOV     A,R1
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   F0           MOVX    @DPTR,A
   2112            
   2113            HalUARTWrite(0,(uint8*)&UartHead, sizeof(UartHead));
   \   000062                ; Setup parameters for call to function HalUARTWrite
   \   000062   7C03         MOV     R4,#0x3
   \   000064   7D00         MOV     R5,#0x0
   \   000066   7401         MOV     A,#0x1
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   AA82         MOV     R2,DPL
   \   00006D   AB83         MOV     R3,DPH
   \   00006F   7900         MOV     R1,#0x0
   \   000071   12....       LCALL   ??HalUARTWrite?relay
   2114            HalUARTWrite(0, Data, DataLength);
   \   000074                ; Setup parameters for call to function HalUARTWrite
   \   000074   EE           MOV     A,R6
   \   000075   FC           MOV     R4,A
   \   000076   7D00         MOV     R5,#0x0
   \   000078   AA..         MOV     R2,?V0 + 0
   \   00007A   AB..         MOV     R3,?V0 + 1
   \   00007C   7900         MOV     R1,#0x0
   \   00007E   12....       LCALL   ??HalUARTWrite?relay
   2115            HalUARTWrite(0, (uint8*)&checksum, 1);
   \   000081                ; Setup parameters for call to function HalUARTWrite
   \   000081   7C01         MOV     R4,#0x1
   \   000083   7D00         MOV     R5,#0x0
   \   000085   85..82       MOV     DPL,?XSP + 0
   \   000088   85..83       MOV     DPH,?XSP + 1
   \   00008B   AA82         MOV     R2,DPL
   \   00008D   AB83         MOV     R3,DPH
   \   00008F   7900         MOV     R1,#0x0
   \   000091   12....       LCALL   ??HalUARTWrite?relay
   2116          }
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099   7F03         MOV     R7,#0x3
   \   00009B   02....       LJMP    ?BANKED_LEAVE_XDATA
   2117          
   2118          /*********************************************************************
   2119           * @fn      fill_AppHead
   2120           *
   2121           * @brief   
   2122           *
   2123           * @param   none
   2124           *
   2125           * @return  none
   2126           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2127          void fill_AppHead(AppHead_t *AppHead, uint8 AckRequire, uint8 MainVersion, uint8 SubVersion, uint8 type, uint8 TypeCode)
   \                     fill_AppHead:
   2128          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FE           MOV     R6,A
   \   00000C   740A         MOV     A,#0xa
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FF           MOV     R7,A
   2129            AppHead->AckRequire = AckRequire;
   2130            AppHead->MainVersion = MainVersion;
   2131            AppHead->SubVersion = SubVersion;
   2132            AppHead->type = type;
   \   000013   740F         MOV     A,#0xf
   \   000015   5E           ANL     A,R6
   \   000016   C0E0         PUSH    A
   \   000018   ED           MOV     A,R5
   \   000019   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001B   E4           CLR     A
   \   00001C   92E0         MOV     0xE0 /* A   */.0,C
   \   00001E   C4           SWAP    A
   \   00001F   C0E0         PUSH    A
   \   000021   EC           MOV     A,R4
   \   000022   C4           SWAP    A
   \   000023   33           RLC     A
   \   000024   54E0         ANL     A,#0xe0
   \   000026   5460         ANL     A,#0x60
   \   000028   C0E0         PUSH    A
   \   00002A   E9           MOV     A,R1
   \   00002B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002D   E4           CLR     A
   \   00002E   92E0         MOV     0xE0 /* A   */.0,C
   \   000030   13           RRC     A
   \   000031   13           RRC     A
   \   000032   5480         ANL     A,#0x80
   \   000034   FC           MOV     R4,A
   \   000035   D0E0         POP     A
   \   000037   4C           ORL     A,R4
   \   000038   FC           MOV     R4,A
   \   000039   D0E0         POP     A
   \   00003B   4C           ORL     A,R4
   \   00003C   FC           MOV     R4,A
   \   00003D   D0E0         POP     A
   \   00003F   4C           ORL     A,R4
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   F0           MOVX    @DPTR,A
   2133            AppHead->TypeCode = TypeCode;
   \   000045   EF           MOV     A,R7
   \   000046   12....       LCALL   ?Subroutine33 & 0xFFFF
   2134            //SerialNumber++;
   2135            uint16 SerialNumber = 0;
   2136            
   2137            AppHead->sn[0] = HI_UINT16(SerialNumber);
   \                     ??CrossCallReturnLabel_180:
   \   000049   12....       LCALL   ?Subroutine34 & 0xFFFF
   2138            AppHead->sn[1] = LO_UINT16(SerialNumber);  
   \                     ??CrossCallReturnLabel_95:
   \   00004C   F0           MOVX    @DPTR,A
   2139          }
   \   00004D                REQUIRE ?Subroutine61
   \   00004D                ; // Fall through to label ?Subroutine61

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   E4           CLR     A
   \   000003   8A82         MOV     DPL,R2
   \   000005   02....       LJMP    ?Subroutine58 & 0xFFFF
   2140          //带序列号的ack的头部

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2141          void fill_AppHead_sn(AppHead_t *AppHead, uint8 AckRequire, uint8 MainVersion, uint8 SubVersion, uint8 type, uint8 TypeCode,uint16 SerialNumber)
   \                     fill_AppHead_sn:
   2142          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   740B         MOV     A,#0xb
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 1,A
   \   000019   740C         MOV     A,#0xc
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   12....       LCALL   ?Subroutine44 & 0xFFFF
   2143            AppHead->AckRequire = AckRequire;
   2144            AppHead->MainVersion = MainVersion;
   2145            AppHead->SubVersion = SubVersion;
   2146            AppHead->type = type;
   \                     ??CrossCallReturnLabel_130:
   \   000021   740F         MOV     A,#0xf
   \   000023   55..         ANL     A,?V0 + 0
   \   000025   C0E0         PUSH    A
   \   000027   EF           MOV     A,R7
   \   000028   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002A   E4           CLR     A
   \   00002B   92E0         MOV     0xE0 /* A   */.0,C
   \   00002D   C4           SWAP    A
   \   00002E   C0E0         PUSH    A
   \   000030   EE           MOV     A,R6
   \   000031   C4           SWAP    A
   \   000032   33           RLC     A
   \   000033   54E0         ANL     A,#0xe0
   \   000035   5460         ANL     A,#0x60
   \   000037   C0E0         PUSH    A
   \   000039   E9           MOV     A,R1
   \   00003A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003C   E4           CLR     A
   \   00003D   92E0         MOV     0xE0 /* A   */.0,C
   \   00003F   13           RRC     A
   \   000040   13           RRC     A
   \   000041   5480         ANL     A,#0x80
   \   000043   FE           MOV     R6,A
   \   000044   D0E0         POP     A
   \   000046   4E           ORL     A,R6
   \   000047   FE           MOV     R6,A
   \   000048   D0E0         POP     A
   \   00004A   4E           ORL     A,R6
   \   00004B   FE           MOV     R6,A
   \   00004C   D0E0         POP     A
   \   00004E   4E           ORL     A,R6
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   F0           MOVX    @DPTR,A
   2147            AppHead->TypeCode = TypeCode;
   \   000054   A3           INC     DPTR
   \   000055   E5..         MOV     A,?V0 + 1
   \   000057   F0           MOVX    @DPTR,A
   2148            AppHead->sn[0] = HI_UINT16(SerialNumber);
   \   000058   ED           MOV     A,R5
   \   000059   8A82         MOV     DPL,R2
   \   00005B   8B83         MOV     DPH,R3
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   F0           MOVX    @DPTR,A
   2149            AppHead->sn[1] = LO_UINT16(SerialNumber);  
   \   000060   EC           MOV     A,R4
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   F0           MOVX    @DPTR,A
   2150          }
   \   000069                REQUIRE ?Subroutine60
   \   000069                ; // Fall through to label ?Subroutine60
   2151          /*********************************************************************
   2152           * @fn      fill_NodeId_time
   2153           *
   2154           * @brief   
   2155           *
   2156           * @param   none
   2157           *
   2158           * @return  none
   2159           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2160          void fill_NodeId_time(NodeIdAndTime_t *NodeIdAndTime,uint8 ARM_Id,uint8 Zigbee_Id,uint8 sensor_type)
   \                     fill_NodeId_time:
   2161          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 6,R1
   \   00000B   8C..         MOV     ?V0 + 5,R4
   \   00000D   8D..         MOV     ?V0 + 4,R5
   2162            /*uint32*/ now = osal_GetSystemClock();  
   \   00000F                ; Setup parameters for call to function osal_GetSystemClock
   \   00000F   12....       LCALL   ??osal_GetSystemClock?relay
   \   000012   90....       MOV     DPTR,#now
   \   000015   EA           MOV     A,R2
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   EB           MOV     A,R3
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   EC           MOV     A,R4
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   12....       LCALL   ?Subroutine29 & 0xFFFF
   2163            NodeIdAndTime->time[0] = BREAK_UINT32(now, 3);
   \                     ??CrossCallReturnLabel_78:
   \   000021   12....       LCALL   ?L_MOV_X
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   12....       LCALL   ?Subroutine29 & 0xFFFF
   2164            NodeIdAndTime->time[1] = BREAK_UINT32(now, 2);
   \                     ??CrossCallReturnLabel_79:
   \   00002B   12....       LCALL   ?L_MOV_X
   \   00002E   7410         MOV     A,#0x10
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?UL_SHR
   \   000035   8E82         MOV     DPL,R6
   \   000037   8F83         MOV     DPH,R7
   \   000039   A3           INC     DPTR
   \   00003A   E5..         MOV     A,?V0 + 0
   \   00003C   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   2165            NodeIdAndTime->time[2] = BREAK_UINT32(now, 1);
   \                     ??CrossCallReturnLabel_80:
   \   00003F   12....       LCALL   ?L_MOV_X
   \   000042   E5..         MOV     A,?V0 + 1
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   2166            NodeIdAndTime->time[3] = BREAK_UINT32(now, 0); 
   \                     ??CrossCallReturnLabel_81:
   \   00004D   12....       LCALL   ?L_MOV_X
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E5..         MOV     A,?V0 + 0
   \   000059   F0           MOVX    @DPTR,A
   2167            NodeIdAndTime->NodeId.r=RES;
   2168            NodeIdAndTime->NodeId.ARM_id=ARM_Id;
   \   00005A   740F         MOV     A,#0xf
   \   00005C   55..         ANL     A,?V0 + 6
   \   00005E   C0E0         PUSH    A
   \   000060   90....       MOV     DPTR,#RES
   \   000063   E0           MOVX    A,@DPTR
   \   000064   C4           SWAP    A
   \   000065   54F0         ANL     A,#0xf0
   \   000067   FA           MOV     R2,A
   \   000068   D0E0         POP     A
   \   00006A   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   00006D   F0           MOVX    @DPTR,A
   2169            NodeIdAndTime->NodeId.Zigbee_id = Zigbee_Id;
   2170            NodeIdAndTime->NodeId.sensor_type=sensor_type;
   \   00006E   740F         MOV     A,#0xf
   \   000070   55..         ANL     A,?V0 + 4
   \   000072   C0E0         PUSH    A
   \   000074   E5..         MOV     A,?V0 + 5
   \   000076   C4           SWAP    A
   \   000077   54F0         ANL     A,#0xf0
   \   000079   FA           MOV     R2,A
   \   00007A   D0E0         POP     A
   \   00007C   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   00007F   A3           INC     DPTR
   \   000080   F0           MOVX    @DPTR,A
   2171          }
   \   000081   7F07         MOV     R7,#0x7
   \   000083   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   4A           ORL     A,R2
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   02....       LJMP    ?Subroutine57 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   ED           MOV     A,R5
   \                     ??Subroutine29_0:
   \   000001   F0           MOVX    @DPTR,A
   \   000002   90....       MOV     DPTR,#now
   \   000005   78..         MOV     R0,#?V0 + 0
   \   000007   22           RET
   2172          
   2173          /*********************************************************************
   2174           * @fn      SendMsg
   2175           *
   2176           * @brief   
   2177           *
   2178           * @param   none
   2179           *
   2180           * @return  none
   2181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2182          void SendMsg(uint8 *msg, uint8 MsgSize, afAddrType_t Dst, uint8 options,uint16 cID)
   \                     SendMsg:
   2183          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   E9           MOV     A,R1
   \   00000A   FE           MOV     R6,A
   \   00000B   EC           MOV     A,R4
   \   00000C   F9           MOV     R1,A
   \   00000D   7410         MOV     A,#0x10
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine54 & 0xFFFF
   2184            if ( p2p_test_NwkState == DEV_ZB_COORD )
   \                     ??CrossCallReturnLabel_152:
   \   000015   90....       MOV     DPTR,#p2p_test_NwkState
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6409         XRL     A,#0x9
   \   00001B   700C         JNZ     ??SendMsg_0
   2185            {
   2186              p2p_test_SendToUart(msg, MsgSize);
   \                     ??SendMsg_1:
   \   00001D                ; Setup parameters for call to function p2p_test_SendToUart
   \   00001D   EE           MOV     A,R6
   \   00001E   F9           MOV     R1,A
   \   00001F   AA..         MOV     R2,?V0 + 0
   \   000021   AB..         MOV     R3,?V0 + 1
   \   000023   12....       LCALL   ??p2p_test_SendToUart?relay
   2187            }
   2188            else
   2189            {
   2190              AF_DataRequest( &Dst, &p2p_test_epDesc,
   2191                                 cID,
   2192                                 MsgSize,
   2193                                 msg,
   2194                                 &p2p_test_TransID,
   2195                                 options, AF_DEFAULT_RADIUS );
   2196          #if DEBUG
   2197                    p2p_test_SendToUart(msg, MsgSize);//添加部分 普通发串口
   2198          #endif
   2199            }  
   2200          }
   \   000026   02....       LJMP    ??Subroutine59_0 & 0xFFFF
   \                     ??SendMsg_0:
   \   000029                ; Setup parameters for call to function AF_DataRequest
   \   000029   75..0A       MOV     ?V0 + 2,#0xa
   \   00002C   78..         MOV     R0,#?V0 + 2
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000031   75....       MOV     ?V0 + 2,#(p2p_test_TransID & 0xff)
   \   000034   75....       MOV     ?V0 + 3,#((p2p_test_TransID >> 8) & 0xff)
   \   000037   78..         MOV     R0,#?V0 + 2
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   78..         MOV     R0,#?V0 + 0
   \   00003E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000041   8E..         MOV     ?V0 + 2,R6
   \   000043   75..00       MOV     ?V0 + 3,#0x0
   \   000046   78..         MOV     R0,#?V0 + 2
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   8A..         MOV     ?V0 + 2,R2
   \   00004D   8B..         MOV     ?V0 + 3,R3
   \   00004F   78..         MOV     R0,#?V0 + 2
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7C..         MOV     R4,#(p2p_test_epDesc & 0xff)
   \   000056   7D..         MOV     R5,#((p2p_test_epDesc >> 8) & 0xff)
   \   000058   7415         MOV     A,#0x15
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   AA82         MOV     R2,DPL
   \   00005F   AB83         MOV     R3,DPH
   \   000061   12....       LCALL   ??AF_DataRequest?relay
   \   000064   7409         MOV     A,#0x9
   \   000066   12....       LCALL   ?DEALLOC_XSTACK8
   \   000069   80B2         SJMP    ??SendMsg_1
   2201          
   2202          /*********************************************************************
   2203           * @fn      p2p_test_SendResetRelativeTime
   2204           *
   2205           * @brief   
   2206           *
   2207           * @param   none
   2208           *
   2209           * @return  none
   2210           */
   2211          //void p2p_test_SendResetRelativeTime( void )
   2212          //{
   2213            /*
   2214            ResetTimeMsg_t ResetTimeMsg;
   2215            
   2216            fill_AppHead((AppHead_t *)&ResetTimeMsg.AppHead, ACK_YES, MAIN_VERSION, SUB_VERSION, TYPE_MAINTAIN, TYPE_CODE_MAINTAIN_RESET_TIME);
   2217            fill_NodeId_time((NodeIdAndTime_t *)&temp_water_gage.NodeIdAndTime,ARM_ID,Zigbee_ID,0);//start from load 
   2218            
   2219            SendMsg((uint8 *)&ResetTimeMsg, sizeof(ResetTimeMsg), p2p_test_DstAddr, AF_DISCV_ROUTE|AF_ACK_REQUEST,p2p_test_RealtionMsg);//need ack 
   2220            */
   2221          //}
   2222          
   2223          /*********************************************************************
   2224           * @fn      p2p_test_SendRelationPkt
   2225           *
   2226           * @brief   
   2227           *
   2228           * @param   none
   2229           *
   2230           * @return  none
   2231           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2232          void p2p_test_SendRelationPkt()
   \                     p2p_test_SendRelationPkt:
   2233          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 22
   \   000005   74EA         MOV     A,#-0x16
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2234            osal_start_timerEx( p2p_test_TaskID,
   2235                               p2p_test_SEND_MAINTAIN_MSG_EVT,10000);  //10s一次关联报文
   \   00000A                ; Setup parameters for call to function osal_start_timerEx
   \   00000A   7C10         MOV     R4,#0x10
   \   00000C   7D27         MOV     R5,#0x27
   \   00000E   7A01         MOV     R2,#0x1
   \   000010   12....       LCALL   ??Subroutine20_1 & 0xFFFF
   2236            RelationMsg_t RelationMsg;
   2237            uint16 num;
   2238            num=0;
   2239            //zigbee's own id
   2240            RelationMsg.NodeId[0].r=0x00;
   2241            RelationMsg.NodeId[0].ARM_id=ARM_ID;
   \                     ??CrossCallReturnLabel_59:
   \   000013   90....       MOV     DPTR,#ARM_ID
   \   000016   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000019   7406         MOV     A,#0x6
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   EA           MOV     A,R2
   \   00001F   F0           MOVX    @DPTR,A
   2242            RelationMsg.NodeId[0].Zigbee_id=Zigbee_ID;
   2243            RelationMsg.NodeId[0].sensor_type=0;
   \   000020   90....       MOV     DPTR,#Zigbee_ID
   \   000023   E0           MOVX    A,@DPTR
   \   000024   C4           SWAP    A
   \   000025   54F0         ANL     A,#0xf0
   \   000027   FB           MOV     R3,A
   \   000028   7407         MOV     A,#0x7
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   EB           MOV     A,R3
   \   00002E   F0           MOVX    @DPTR,A
   2244            #if RAIN_FLAG!=0
   2245               num++;
   2246               RelationMsg.NodeId[num].sensor_type=RAIN_ID;
   2247            #endif
   2248            #if SOIL_FLAG!=0
   2249               num++;
   2250               RelationMsg.NodeId[num].sensor_type=SOIL_ID;
   2251            #endif
   2252            #if WATER_GAGE_FLAG!=0
   2253               num++;
   2254               RelationMsg.NodeId[num].sensor_type=WATER_GAGE_ID;
   \   00002F   7409         MOV     A,#0x9
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   54F0         ANL     A,#0xf0
   \   000037   4403         ORL     A,#0x3
   \   000039   F0           MOVX    @DPTR,A
   2255            #endif
   2256            #if EARTHQUAKE_FLAG!=0
   2257               num++;
   2258               RelationMsg.NodeId[num].sensor_type=EARTHQUAKE_ID;
   2259            #endif
   2260            #if PORE_FLAG!=0
   2261               num++;
   2262               RelationMsg.NodeId[num].sensor_type=PORE_ID;
   2263            #endif
   2264            
   2265            uint8 i;
   2266            for(i=1;i<=num;i++)
   2267            {
   2268              RelationMsg.NodeId[i].r=0;
   2269              RelationMsg.NodeId[i].ARM_id=ARM_ID;
   \   00003A   7408         MOV     A,#0x8
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   EA           MOV     A,R2
   \   000040   F0           MOVX    @DPTR,A
   2270              RelationMsg.NodeId[i].Zigbee_id=Zigbee_ID;
   \   000041   7403         MOV     A,#0x3
   \   000043   4B           ORL     A,R3
   \   000044   C0E0         PUSH    A
   \   000046   7409         MOV     A,#0x9
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   D0E0         POP     A
   \   00004D   F0           MOVX    @DPTR,A
   2271            }
   2272            fill_AppHead((AppHead_t *)&RelationMsg.AppHead, ACK_YES, MAIN_VERSION, SUB_VERSION, TYPE_MAINTAIN,RELATION_MSG_UP);
   \   00004E                ; Setup parameters for call to function fill_AppHead
   \   00004E   75..01       MOV     ?V0 + 0,#0x1
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7D01         MOV     R5,#0x1
   \   00005D   7C00         MOV     R4,#0x0
   \   00005F   7901         MOV     R1,#0x1
   \   000061   7402         MOV     A,#0x2
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   12....       LCALL   ??fill_AppHead?relay
   \   00006D   7402         MOV     A,#0x2
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
   2273            if(0==Zigbee_ID)//first send RelationMsg
   \   000072   90....       MOV     DPTR,#Zigbee_ID
   \   000075   E0           MOVX    A,@DPTR
   \   000076   7015         JNZ     ??p2p_test_SendRelationPkt_0
   2274            {
   2275              
   2276              RelationMsg.Num[0]=0x00;
   \   000078   7404         MOV     A,#0x4
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   E4           CLR     A
   \   00007E   F0           MOVX    @DPTR,A
   2277              RelationMsg.Num[1]=0x00;
   \   00007F   7405         MOV     A,#0x5
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E4           CLR     A
   \   000085   F0           MOVX    @DPTR,A
   2278             // SendMsg((uint8 *)&RelationMsg, sizeof(RelationMsg)-2*(MAX_ID-0), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);//need ack
   2279              //EndDevice print
   2280             // HalUARTWrite(0,&Zigbee_ID,1);
   2281              SendMsg((uint8 *)&RelationMsg, sizeof(RelationMsg), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   \   000086                ; Setup parameters for call to function SendMsg
   \   000086   75..04       MOV     ?V0 + 0,#0x4
   \   000089   F5..         MOV     ?V0 + 1,A
   \   00008B   8015         SJMP    ??p2p_test_SendRelationPkt_1
   2282            }
   2283            else      //second send RElationMsg
   2284            {
   2285              RelationMsg.Num[0]=HI_UINT16(num+1);
   \                     ??p2p_test_SendRelationPkt_0:
   \   00008D   7404         MOV     A,#0x4
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   E4           CLR     A
   \   000093   F0           MOVX    @DPTR,A
   2286              RelationMsg.Num[1]=LO_UINT16(num+1);
   \   000094   7405         MOV     A,#0x5
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   7402         MOV     A,#0x2
   \   00009B   F0           MOVX    @DPTR,A
   2287            //  SendMsg((uint8 *)&RelationMsg, sizeof(RelationMsg)-2*(MAX_ID-num-1), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);//need ack
   2288              SendMsg((uint8 *)&RelationMsg, sizeof(RelationMsg), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_RelationMsg);
   \   00009C                ; Setup parameters for call to function SendMsg
   \   00009C   75..04       MOV     ?V0 + 0,#0x4
   \   00009F   75..00       MOV     ?V0 + 1,#0x0
   \                     ??p2p_test_SendRelationPkt_1:
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   90....       MOV     DPTR,#p2p_test_DstAddr
   \   0000AA   7404         MOV     A,#0x4
   \   0000AC   12....       LCALL   ?PUSH_XSTACK8_X
   \   0000AF   7C20         MOV     R4,#0x20
   \   0000B1   7916         MOV     R1,#0x16
   \   0000B3   7406         MOV     A,#0x6
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   AA82         MOV     R2,DPL
   \   0000BA   AB83         MOV     R3,DPH
   \   0000BC   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   0000BF   12....       LCALL   ?DEALLOC_XSTACK8
   2289              //EndDevice print
   2290             //HalUARTWrite(0,&Zigbee_ID,1);
   2291            }
   2292          
   2293            
   2294           // shortaddr = NLME_GetShortAddr();
   2295            //RelationMsg.ShortAddr[0] = HI_UINT16(shortaddr);
   2296           // RelationMsg.ShortAddr[1] = LO_UINT16(shortaddr);
   2297              
   2298          }
   \   0000C2   7416         MOV     A,#0x16
   \   0000C4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C7   02....       LJMP    ?Subroutine60 & 0xFFFF
   2299          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2300          void p2p_test_StartDataSensorTimer()
   \                     p2p_test_StartDataSensorTimer:
   2301          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2302          #if RAIN_FLAG!=0
   2303                  osal_start_timerEx( p2p_test_TaskID,
   2304                                        p2p_test_SEND_RAIN_FREQ_MSG_EVT,
   2305                                        1000 );     
   2306          #endif
   2307          #if SOIL_FLAG!=0
   2308                  osal_start_timerEx(p2p_test_TaskID,
   2309                                        p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT,
   2310                                        2000); 
   2311          #endif    
   2312          #if EARTHQUAKE_FLAG!=0 
   2313                
   2314                  osal_start_timerEx(p2p_test_TaskID,
   2315                                        p2p_test_SEND_ACCELEROMETER_FREQ_MSG_EVT,
   2316                                         1000);
   2317          #endif         
   2318                   
   2319                     
   2320                      //  uint8 te=0xAA;
   2321                      //  HalUARTWrite(0,&te,1);
   2322          
   2323                     
   2324                     
   2325            /*         osal_start_timerEx(p2p_test_TaskID,
   2326                                        p2p_test_SEND_VCC_VALUE_FREQ_MSG_EVT ,
   2327                                        1000);   
   2328            */        
   2329          
   2330               /*   if (  (p2p_test_NwkState == DEV_ROUTER)
   2331                        || (p2p_test_NwkState == DEV_END_DEVICE) )
   2332                    {
   2333                        osal_start_timerEx( p2p_test_TaskID,
   2334                                          p2p_test_SEND_MSG_EVT,
   2335                                         10 );
   2336                    }  */
   2337          #if WATER_GAGE_FLAG!=0   
   2338             osal_start_timerEx(p2p_test_TaskID,
   2339                                       p2p_test_SEND_WATER_GAGE_MSG_EVT,
   2340                                       1000); 
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   7CE8         MOV     R4,#-0x18
   \   000006   7D03         MOV     R5,#0x3
   \   000008   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   2341              osal_start_timerEx(p2p_test_TaskID,
   2342                                    p2p_test_CHECK_WATER_GAGE_CHARGE_MSG_EVT, 
   2343                                    CheckWaterGageChargeTimeFreq * 1000);
   \                     ??CrossCallReturnLabel_56:
   \   00000B                ; Setup parameters for call to function osal_start_timerEx
   \   00000B   12....       LCALL   ?Subroutine2 & 0xFFFF
   2344           /*     osal_start_timerEx( p2p_test_TaskID,
   2345                                    p2p_test_START_WATER_GAGE_TIME_MSG_EVT, 
   2346                                    1000);*/
   2347           #endif 
   2348          }
   \                     ??CrossCallReturnLabel_10:
   \   00000E   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   2349          
   2350          /*********************************************************************
   2351           * @fn      p2p_test_interrupt_rain
   2352           *
   2353           * @brief   
   2354           *
   2355           * @param   none
   2356           *
   2357           * @return  none
   2358           
   2359          
   2360          void p2p_test_interrupt_rain(uint16 count)
   2361          {
   2362            if(++RainCountNum != SendRainCountFreq)
   2363            {
   2364              return;
   2365            }
   2366            if(count>=RainCountNum)
   2367              count=count-RainCountNum;
   2368              //reset
   2369          
   2370            RainMsg_t RainMsg;  
   2371            fill_AppHead((AppHead_t *)&RainMsg.AppHead, ACK_NO, MAIN_VERSION, SUB_VERSION, TYPE_SENSOR, TYPE_CODE_SENSOR_RAIN);
   2372            fill_NodeId_time((NodeIdAndTime_t *)&RainMsg.NodeIdAndTime,ARM_ID,Zigbee_ID,RAIN_ID);//start from load  
   2373            RainMsg.count[0] = HI_UINT16(RainCountNum);
   2374            RainMsg.count[1] = LO_UINT16(RainCountNum);
   2375            RainCountNum=0;
   2376            SendMsg((uint8 *)&RainMsg, sizeof(RainMsg), p2p_test_DstAddr, AF_DISCV_ROUTE,p2p_test_108ID);//no ack
   2377          }
   2378          */
   2379          /*********************************************************************
   2380           * @fn      p2p_test_SendRainTimeFreqAndRequire
   2381           *
   2382           * @brief   
   2383           *
   2384           * @param   none
   2385           *
   2386           * @return  none
   2387           
   2388          
   2389          void p2p_test_SendRainTimeFreqAndRequire( uint8 FreqOrRequire )
   2390          {
   2391            if(FreqOrRequire == FREQ)
   2392            {
   2393              uint8 timeout = 0;  
   2394              if(!SendRainRemainTime)//SendRainRemainTime==0, send the msg
   2395              {
   2396                SendRainRemainTime = SendRainTimeFreq;//test unit=second, product unit=minute
   2397                //SendRainRemainTime = SendRainTimeFreq*60;
   2398                timeout = 1;
   2399              }
   2400          
   2401              if(SendRainRemainTime>65)//osal_start_timerEx max time is 65.535s
   2402              {
   2403                SendRainRemainTime -= 65;
   2404                osal_start_timerEx( p2p_test_TaskID,
   2405                                p2p_test_SEND_RAIN_FREQ_MSG_EVT,
   2406                                65000 );//uint=ms
   2407              }
   2408              else
   2409              {
   2410                 osal_start_timerEx( p2p_test_TaskID,
   2411                                p2p_test_SEND_RAIN_FREQ_MSG_EVT,
   2412                                SendRainTimeFreq*1000 );
   2413                 SendRainRemainTime = 0;
   2414              }
   2415              if(!timeout)
   2416              {
   2417                return;      
   2418              }
   2419            }
   2420            
   2421            static uint16 precount=0;
   2422            RainMsg_t RainMsg;
   2423            uint8 SendMsgOption, AckRequire;
   2424            if(FreqOrRequire == FREQ)
   2425            {
   2426              SendMsgOption = AF_DISCV_ROUTE;
   2427              AckRequire = ACK_NO;
   2428            }
   2429            else
   2430            {
   2431              SendMsgOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2432              AckRequire = ACK_YES;      
   2433            }
   2434            fill_AppHead((AppHead_t *)&RainMsg.AppHead, AckRequire, MAIN_VERSION, SUB_VERSION, TYPE_SENSOR, TYPE_CODE_SENSOR_RAIN);
   2435            fill_NodeId_time((NodeIdAndTime_t *)&RainMsg.NodeIdAndTime,ARM_ID,Zigbee_ID,RAIN_ID);;//start from load  
   2436            uint16 count = QueryP1Interrupt(PIN_3);
   2437            RainMsg.count[0] = HI_UINT16(count-precount);
   2438            RainMsg.count[1] = LO_UINT16(count-precount);
   2439            precount=count;
   2440            SendMsg((uint8 *)&RainMsg, sizeof(RainMsg), p2p_test_DstAddr, SendMsgOption,p2p_test_108ID);
   2441          }*/
   2442          
   2443          /*********************************************************************
   2444           * @fn      p2p_test_SendSoilHumidityTimeFreqAndRequire
   2445           *
   2446           * @brief   
   2447           *
   2448           * @param   none
   2449           *
   2450           * @return  none
   2451           */
   2452          //void p2p_test_SendSoilHumidityTimeFreqAndRequire( uint8 FreqOrRequire )
   2453          //{
   2454            /*if(FreqOrRequire == FREQ)
   2455            {
   2456              uint8 timeout = 0;  
   2457              if(!SendSoilHumidityRemainTime)//SendIlluminationRemainTime==0, send the msg
   2458              {
   2459                SendSoilHumidityRemainTime = SendSoilHumidityTimeFreq;//test unit=second product unit=minute
   2460                //SendIlluminationRemainTime = SendIlluminationTimeFreq*60;
   2461                timeout = 1;
   2462              }
   2463          
   2464              if(SendSoilHumidityRemainTime>65)//osal_start_timerEx max time is 65.535s
   2465              {
   2466                SendSoilHumidityRemainTime -= 65;
   2467                osal_start_timerEx( p2p_test_TaskID,
   2468                                p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT,
   2469                                65000 );//uint=ms
   2470              }
   2471              else
   2472              {
   2473                 osal_start_timerEx( p2p_test_TaskID,
   2474                                p2p_test_SEND_SOIL_HUMIDITY_FREQ_MSG_EVT,
   2475                                SendSoilHumidityTimeFreq*1000 );
   2476                 SendSoilHumidityRemainTime = 0;
   2477              }
   2478              if(!timeout)
   2479              {
   2480                return;      
   2481              }
   2482            }
   2483            */
   2484          /*
   2485            uint16 AdcValue=0,AdcVcc=0;
   2486           // float tmp_value;
   2487            //P0.1 IS GENERAL AND INPUT
   2488            P0SEL &=~ (0x02);
   2489            P0DIR &=~ (0x02);
   2490            HalAdcInit();
   2491            //adcground=HalAdcCheckGround(HAL_ADC_RESOLUTION_14);
   2492            AdcVcc = HalAdcReadVcc( HAL_ADC_RESOLUTION_14 );
   2493            AdcValue = HalAdcRead(1,HAL_ADC_RESOLUTION_14);
   2494            AdcVcc = AdcVcc*3;
   2495            
   2496            Soil_Humidity_t Soil_Humidity;
   2497            uint8 SendMsgOption, AckRequire;
   2498            
   2499            if(FreqOrRequire == FREQ)
   2500            {
   2501              SendMsgOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2502              AckRequire = ACK_NO;    
   2503            }
   2504            else{
   2505              SendMsgOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2506              AckRequire = ACK_YES;     
   2507            }
   2508            fill_AppHead((AppHead_t *)&Soil_Humidity.AppHead, AckRequire, MAIN_VERSION, SUB_VERSION, TYPE_SENSOR, TYPE_CODE_SENSOR_SOIL_HUMIDITY);
   2509            fill_NodeId_time((NodeIdAndTime_t *)&Soil_Humidity.NodeIdAndTime,ARM_ID,Zigbee_ID,SOIL_ID);  
   2510            Soil_Humidity.AdcVcc[0] = HI_UINT16(AdcVcc);
   2511            Soil_Humidity.AdcVcc[1] = LO_UINT16(AdcVcc);
   2512            Soil_Humidity.AdcValue[0] = HI_UINT16(AdcValue);
   2513            Soil_Humidity.AdcValue[1] = LO_UINT16(AdcValue);*/
   2514          
   2515            //GET PORT OF VALUE P0.1
   2516           /* tmp_value = (float)AdcValue/0x1FFF;
   2517            tmp_value = (float)AdcVcc/0x1FFF*1.25*tmp_value;
   2518            if(tmp_value <= 2.5)
   2519            {
   2520              switch(SOIL_TYPE)
   2521              {
   2522               case Clay_Soil:
   2523                    Soil_Humidity.SoilValue = (0.055*tmp_value*tmp_value+0.02*tmp_value-0.0002)*100;
   2524               break;
   2525               case Loam_Soil:
   2526                    Soil_Humidity.SoilValue = (0.0145*tmp_value*tmp_value+0.1022*tmp_value+0.0003)*100;
   2527               break;
   2528               case Sand_Soil:
   2529               Soil_Humidity.SoilValue = (0.0154*tmp_value*tmp_value+0.1438*tmp_value-0.0026)*100;
   2530               break;
   2531              }
   2532            } 
   2533            else 
   2534            { 
   2535              Soil_Humidity.SoilValue= 100.0;
   2536            } */
   2537            
   2538          /*
   2539            SendMsg((uint8 *)&Soil_Humidity, sizeof(Soil_Humidity), p2p_test_DstAddr, SendMsgOption,p2p_test_108ID);  
   2540          
   2541          //自己编写
   2542            
   2543          
   2544            uint16 Soil_humidity_data_temp = BUILD_UINT16(Soil_Humidity.AdcValue[1], 
   2545                                                          Soil_Humidity.AdcValue[0]);
   2546            uint16 Soil_humidity_vcc_temp = BUILD_UINT16(Soil_Humidity.AdcVcc[1], 
   2547                                                         Soil_Humidity.AdcVcc[0]);
   2548            float Soil_humidity_data =Soil_humidity_DtoA(Soil_humidity_data_temp,Soil_humidity_vcc_temp);
   2549            //HalUARTWrite(0,(uint8 *)&(temp_water_gage.water_gage_value),sizeof(temp_water_gage.water_gage_value));
   2550            //uint16 data = BUILD_UINT16(Msg[3], Msg[4]);
   2551            //HalUARTWrite(0,(uint8*)&data, sizeof(data));
   2552            //用于测试
   2553               uint8 a1 =1;
   2554               uint8 a2 =2;
   2555               uint8 a3 =3;
   2556               uint8 a4 =4;
   2557               
   2558                float x=Soil_humidity_data*100;
   2559                HalUARTWrite_uint16((uint16)x);
   2560          
   2561                 Soil_humidity_data_and_time.data[Soil_humidity_SerialNumber%3]=Soil_humidity_data;
   2562                 Soil_humidity_data_and_time.time[Soil_humidity_SerialNumber%3]= now;
   2563                        
   2564                // HalUARTWrite(0,(uint8*)&Water_Gage_data_and_time.time[0], sizeof(Water_Gage_data_and_time.time[0]));
   2565                // HalUARTWrite(0,(uint8*)&Water_Gage_data_and_time.time[1], sizeof(Water_Gage_data_and_time.time[1]));
   2566                // HalUARTWrite(0,(uint8*)&Water_Gage_data_and_time.time[2], sizeof(Water_Gage_data_and_time.time[2]));
   2567                 
   2568               //  HalUARTWrite(0,(uint8*)& Water_Gage_data_and_time.data[Water_gage_SerialNumber%3], sizeof( Water_Gage_data_and_time.data[Water_gage_SerialNumber%3]));
   2569                 Soil_humidity_SerialNumber++;
   2570            
   2571            //根据预测值选择定时器时间
   2572                 if(Soil_humidity_SerialNumber >=4)
   2573                     {
   2574                      Soil_humidity_err = (Soil_humidity_data >Soil_humidity_forValue )? 
   2575                          ( Soil_humidity_data- Soil_humidity_forValue) : 
   2576                           (Soil_humidity_forValue -Soil_humidity_data);    
   2577                  
   2578                      float y =Soil_humidity_err*100;
   2579                      HalUARTWrite_uint16((uint16)y);
   2580                     // HalUARTWrite_uint16((uint16)&x);
   2581            
   2582                      
   2583                       if( Soil_humidity_err < Soil_humidity_err_a)
   2584                       {
   2585                         SendSoilHumidityTimeFreq += 2*Soil_humidity_time;
   2586                         HalUARTWrite(0,&a1, sizeof(a1));
   2587                       }
   2588          
   2589                       else if((Soil_humidity_err >= Soil_humidity_err_a) && ( Soil_humidity_err < Soil_humidity_err_b))  
   2590                       {
   2591                         SendSoilHumidityTimeFreq += Soil_humidity_time;
   2592                         HalUARTWrite(0,&a2, sizeof(a2));
   2593                       }
   2594                      else if((Soil_humidity_err >= Soil_humidity_err_b) && ( Soil_humidity_err < Soil_humidity_err_c))
   2595                       {
   2596                         SendSoilHumidityTimeFreq -= Soil_humidity_time;
   2597                         HalUARTWrite(0,&a3, sizeof(a3));
   2598                       }
   2599                       else if (Soil_humidity_err >= Soil_humidity_err_c)
   2600                       {
   2601                         SendSoilHumidityTimeFreq = (SendSoilHumidityTimeFreq/2) ;
   2602                         HalUARTWrite(0,&a4, sizeof(a4));
   2603                       }
   2604                     }
   2605                 // HalUARTWrite(0,(uint8*)&Water_gage_forValue, sizeof(Water_gage_forValue));
   2606                 // HalUARTWrite(0,(uint8*)&Water_gage_err, sizeof(Water_gage_err));      
   2607                 // HalUARTWrite(0,(uint8*)&SendWaterGageTimeFreq, sizeof(SendWaterGageTimeFreq));
   2608                 // HalUARTWrite(0,(uint8*)&UartHead, sizeof(UartHead))
   2609                 if ( SendSoilHumidityTimeFreq > 8*Soil_humidity_time)
   2610                       SendSoilHumidityTimeFreq = 8*Soil_humidity_time;
   2611                 
   2612                  //HalUARTWrite(0,(uint8*)&SendWaterGageTimeFreq, sizeof(SendWaterGageTimeFreq));
   2613                  HalUARTWrite_uint16(SendSoilHumidityTimeFreq);
   2614                  
   2615            //从收到第三个数据后开始预测下一个数据
   2616                 if(Soil_humidity_SerialNumber>=3)
   2617                   {
   2618                       Soil_humidity_forValue =Soil_humidity_forecastValue(Soil_humidity_data_and_time);
   2619                        if(Soil_humidity_forValue < 0 ) 
   2620                          Soil_humidity_forValue=0;
   2621                        else if(Soil_humidity_forValue > 2.5)
   2622                          Soil_humidity_forValue = 2.5;
   2623                       //HalUARTWrite(0,(uint8*)&Water_gage_forValue, sizeof(Water_gage_forValue));
   2624                      float z =Soil_humidity_forValue*100;
   2625                     HalUARTWrite_uint16((uint16)z);
   2626                   } 
   2627          
   2628                 
   2629                  start_Soil_humidity_timer();
   2630                // conPrintROMString("shoudao yige shuju ");
   2631          
   2632          
   2633          
   2634          
   2635          }*/
   2636          
   2637          
   2638          /*********************************************************************
   2639           * @fn      p2p_test_SendAccelerometerTimeFreqAndRequire
   2640           *
   2641           * @brief   
   2642           *
   2643           * @param   none
   2644           *
   2645           * @return  none
   2646          
   2647          
   2648          void p2p_test_SendAccelerometerTimeFreqAndRequire( uint8 FreqOrRequire )
   2649          {
   2650            if(FreqOrRequire == FREQ)
   2651            {
   2652              uint8 timeout = 0;  
   2653              if(!SendAccelerometerRemainTime)//SendIlluminationRemainTime==0, send the msg
   2654              {
   2655                SendAccelerometerRemainTime = SendAccelerometerTimeFreq;//test unit=second product unit=minute
   2656                //SendIlluminationRemainTime = SendIlluminationTimeFreq*60;
   2657                timeout = 1;
   2658              }
   2659          
   2660              if(SendAccelerometerRemainTime>65)//osal_start_timerEx max time is 65.535s
   2661              {
   2662                SendAccelerometerRemainTime -= 65;
   2663                osal_start_timerEx( p2p_test_TaskID,
   2664                                p2p_test_SEND_ACCELEROMETER_FREQ_MSG_EVT,
   2665                                65000 );//uint=ms
   2666              }
   2667              else
   2668              {
   2669                 osal_start_timerEx( p2p_test_TaskID,
   2670                                 p2p_test_SEND_ACCELEROMETER_FREQ_MSG_EVT,
   2671                                 SendAccelerometerTimeFreq*1000 );
   2672                 SendAccelerometerRemainTime = 0;
   2673              }
   2674              if(!timeout)
   2675              {
   2676                return;      
   2677              }
   2678            }
   2679            
   2680            uint16 AdcValue=0,AdcVcc=0;
   2681            //HalUARTWrite(0,(uint8 *))
   2682           // float tmp_value;
   2683            //P0.7 is input externel Vcc
   2684            //p0.4 p0.5 is about differential input
   2685            // P0SEL &=~ (0x04);
   2686             //P0DIR &=~ (0x04);
   2687           //  P0SEL &=~ (0x30);
   2688           //  P0DIR &=~ (0x30);
   2689             P0SEL &=~ (0xc0);
   2690             P0DIR &=~ (0xc0);
   2691            HalAdcInit();
   2692            //adcground=HalAdcCheckGround(HAL_ADC_RESOLUTION_14);
   2693            //float tempvalue;
   2694            AdcVcc = HalAdcReadVcc( HAL_ADC_RESOLUTION_14 );
   2695           // AdcValue = HalAdcRead(5,HAL_ADC_RESOLUTION_14); 
   2696            AdcValue=  HalDiffAdcRead(6,7,HAL_ADC_RESOLUTION_14);
   2697            //tempvalue=(float)AdcVcc/0x1fff;
   2698            //tempvalue=(float)AdcValue/0x1fff*tempvalue*5;
   2699            
   2700            Accelerometer_t Accelerometer;
   2701            uint8 SendMsgOption, AckRequire;
   2702            
   2703            if(FreqOrRequire == FREQ)
   2704            {
   2705              SendMsgOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2706              AckRequire = ACK_NO;    
   2707            }
   2708            else{
   2709              SendMsgOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2710              AckRequire = ACK_YES;     
   2711            }
   2712            fill_AppHead((AppHead_t *)&Accelerometer.AppHead, AckRequire, MAIN_VERSION, SUB_VERSION, TYPE_SENSOR, TYPE_CODE_SENSOR_ACCELEROMETER);
   2713            fill_NodeId_time((NodeIdAndTime_t *)&Accelerometer.NodeIdAndTime,ARM_ID,Zigbee_ID,EARTHQUAKE_ID);  
   2714            Accelerometer.AdcVcc[0] = HI_UINT16(AdcVcc);
   2715            Accelerometer.AdcVcc[1] = LO_UINT16(AdcVcc);
   2716            Accelerometer.AdcValue[0] = HI_UINT16(AdcValue);
   2717            Accelerometer.AdcValue[1] = LO_UINT16(AdcValue);
   2718           // Accelerometer.Accelevalue=tempvalue;
   2719            SendMsg((uint8 *)&Accelerometer, sizeof(Accelerometer), p2p_test_DstAddr, SendMsgOption,p2p_test_108ID);  
   2720          } */
   2721          
   2722          /*********************************************************************
   2723           * @fn      p2p_test_Send_VCC_VALUE
   2724           *
   2725           * @brief   read vcc and sent to coor.COMMOND FOR supply voltage. read digital value is vcc/3 and ref 
   2726           *          value is 1.25v of internal voltage .  RESOLUTION is 14 bit .if the dev is coor, 
   2727           *          send to pc through serial port,other send to coor.
   2728           *
   2729           * @param   Freq: the time , send data to coor unit s
   2730           *          Require: the commend for read value once
   2731           *
   2732           * @return  none
   2733          
   2734          void p2p_test_Send_VCC_VALUE(uint8 FreqOrRequire)
   2735          {
   2736             if (FreqOrRequire == FREQ)
   2737             {
   2738               uint8 timeout = 0;
   2739               if(!SendVccValueRemainTime)
   2740               {
   2741                 SendVccValueRemainTime = SendVccValueTimeFreq;
   2742                 timeout = 1;
   2743               }
   2744               if(SendVccValueRemainTime > 65)//osal_start_timerEx max time is 65.535s
   2745               {
   2746                 SendVccValueRemainTime -= 65;
   2747                 osal_start_timerEx( p2p_test_TaskID,
   2748                                    p2p_test_SEND_VCC_VALUE_FREQ_MSG_EVT, 
   2749                                    65000);
   2750               }
   2751               else 
   2752               {
   2753                 osal_start_timerEx(p2p_test_TaskID,
   2754                                    p2p_test_SEND_VCC_VALUE_FREQ_MSG_EVT, 
   2755                                    SendVccValueTimeFreq*1000);
   2756                SendVccValueRemainTime = 0;
   2757               }
   2758               if(!timeout)
   2759               {
   2760                 return;
   2761               }
   2762             }
   2763            //set read adc
   2764              uint16 AdcVccTmp =0;
   2765              Vccvalue_t Vccvalue;
   2766              uint8 SendMsgOption, AckRequire;
   2767              HalAdcInit();
   2768              AdcVccTmp = HalAdcReadVcc(HAL_ADC_RESOLUTION_14);
   2769              AdcVccTmp = AdcVccTmp*3;
   2770              
   2771              if(FreqOrRequire == FREQ)
   2772              {
   2773                SendMsgOption = AF_DISCV_ROUTE;
   2774                AckRequire = ACK_NO;
   2775              }   
   2776              else
   2777               {
   2778                SendMsgOption = AF_DISCV_ROUTE|AF_ACK_REQUEST;
   2779                AckRequire = ACK_YES;          
   2780               }
   2781              fill_AppHead((AppHead_t *)&Vccvalue.AppHead,AckRequire,MAIN_VERSION,
   2782                           SUB_VERSION,TYPE_SENSOR,TYPE_CODE_SENSOR_READ_VCC);
   2783              fill_NodeId_time((NodeIdAndTime_t *)&Vccvalue.NodeIdAndTime,ARM_ID,Zigbee_ID,0);
   2784              Vccvalue.AdcVcc[0] =  HI_UINT16(AdcVccTmp);
   2785              Vccvalue.AdcVcc[1] =  LO_UINT16(AdcVccTmp);
   2786              SendMsg((uint8 *)&Vccvalue, sizeof(Vccvalue), p2p_test_DstAddr, 
   2787                      SendMsgOption,p2p_test_108ID); 
   2788           }
   2789           */
   2790          
   2791          //*********************************************************************
   2792           /* @fn       crc_water_gage
   2793           *
   2794           * @brief   
   2795           *
   2796           * @param   Freq: the time , send data to coor unit s
   2797           *          Require: the commend for read value once
   2798           *
   2799           * @return  none
   2800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2801          void crc_water_gage(Water_Send_Infor_t *temp)
   \                     crc_water_gage:
   2802          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2803             uint16 Crc=0xffff;
   \   00000A   78FF         MOV     R0,#-0x1
   \   00000C   79FF         MOV     R1,#-0x1
   2804             uint16 a001=0xa001;
   2805             
   2806             uint8 a[6],crc[2];
   2807             a[0]=temp->station_number;
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   C0E0         PUSH    A
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   D0E0         POP     A
   \   00001C   12....       LCALL   ?Subroutine51 & 0xFFFF
   2808             a[1]=temp->func_code;
   \                     ??CrossCallReturnLabel_145:
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   C0E0         PUSH    A
   \   000022   7403         MOV     A,#0x3
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   D0E0         POP     A
   \   000029   12....       LCALL   ?Subroutine51 & 0xFFFF
   2809             a[2]=temp->first_addr[0];
   \                     ??CrossCallReturnLabel_146:
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   C0E0         PUSH    A
   \   000030   7404         MOV     A,#0x4
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   D0E0         POP     A
   \   000037   12....       LCALL   ?Subroutine34 & 0xFFFF
   2810             a[3]=temp->first_addr[1];
   \                     ??CrossCallReturnLabel_96:
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   C0E0         PUSH    A
   \   00003D   7405         MOV     A,#0x5
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   D0E0         POP     A
   \   000044   12....       LCALL   ?Subroutine32 & 0xFFFF
   2811             a[4]=temp->read_num[0];
   \                     ??CrossCallReturnLabel_93:
   \   000047   E0           MOVX    A,@DPTR
   \   000048   C0E0         PUSH    A
   \   00004A   7406         MOV     A,#0x6
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   D0E0         POP     A
   \   000051   12....       LCALL   ?Subroutine32 & 0xFFFF
   2812             a[5]=temp->read_num[1];
   \                     ??CrossCallReturnLabel_94:
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   C0E0         PUSH    A
   \   000058   7407         MOV     A,#0x7
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   D0E0         POP     A
   \   00005F   F0           MOVX    @DPTR,A
   2813          
   2814             for(int i=0;i<6;i++)
   \   000060   7C00         MOV     R4,#0x0
   \   000062   7D00         MOV     R5,#0x0
   2815             {   
   2816                 crc[0]= LO_UINT16(Crc);
   \                     ??crc_water_gage_0:
   \   000064   E8           MOV     A,R0
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   F0           MOVX    @DPTR,A
   2817                 crc[1]= HI_UINT16(Crc);
   \   00006C   7401         MOV     A,#0x1
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   E9           MOV     A,R1
   \   000072   F0           MOVX    @DPTR,A
   2818                 crc[0]=crc[0]^a[i];
   \   000073   7402         MOV     A,#0x2
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E582         MOV     A,DPL
   \   00007A   2C           ADD     A,R4
   \   00007B   F582         MOV     DPL,A
   \   00007D   E583         MOV     A,DPH
   \   00007F   3D           ADDC    A,R5
   \   000080   F583         MOV     DPH,A
   \   000082   E0           MOVX    A,@DPTR
   \   000083   FE           MOV     R6,A
   \   000084   85..82       MOV     DPL,?XSP + 0
   \   000087   85..83       MOV     DPH,?XSP + 1
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   6E           XRL     A,R6
   \   00008C   F0           MOVX    @DPTR,A
   2819                 Crc= BUILD_UINT16(crc[0],crc[1]);
   \   00008D   FE           MOV     R6,A
   \   00008E   7401         MOV     A,#0x1
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F9           MOV     R1,A
   \   000095   EE           MOV     A,R6
   \   000096   F8           MOV     R0,A
   2820                	for(int j=0;j<8;j++)
   \   000097   7E08         MOV     R6,#0x8
   2821          	{
   2822          	   if((Crc&0x0001)==1)
   \                     ??crc_water_gage_1:
   \   000099   E8           MOV     A,R0
   \   00009A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00009C   E9           MOV     A,R1
   \   00009D   5010         JNC     ??crc_water_gage_2
   2823          	   {
   2824          	     Crc=(Crc>>1)&0x7fff;
   2825                       Crc=Crc^a001;
   \   00009F   C3           CLR     C
   \   0000A0   13           RRC     A
   \   0000A1   F9           MOV     R1,A
   \   0000A2   E8           MOV     A,R0
   \   0000A3   13           RRC     A
   \   0000A4   F8           MOV     R0,A
   \   0000A5   7401         MOV     A,#0x1
   \   0000A7   68           XRL     A,R0
   \   0000A8   F8           MOV     R0,A
   \   0000A9   74A0         MOV     A,#-0x60
   \   0000AB   69           XRL     A,R1
   \   0000AC   F9           MOV     R1,A
   \   0000AD   8006         SJMP    ??crc_water_gage_3
   2826          	   }
   2827          	   else if((Crc&0x0001)==0)
   2828          	    Crc=(Crc>>1)&0x7fff;
   \                     ??crc_water_gage_2:
   \   0000AF   C3           CLR     C
   \   0000B0   13           RRC     A
   \   0000B1   F9           MOV     R1,A
   \   0000B2   E8           MOV     A,R0
   \   0000B3   13           RRC     A
   \   0000B4   F8           MOV     R0,A
   2829          	}
   \                     ??crc_water_gage_3:
   \   0000B5   1E           DEC     R6
   \   0000B6   EE           MOV     A,R6
   \   0000B7   70E0         JNZ     ??crc_water_gage_1
   2830          		
   2831             }
   \   0000B9   EC           MOV     A,R4
   \   0000BA   2401         ADD     A,#0x1
   \   0000BC   0C           INC     R4
   \   0000BD   ED           MOV     A,R5
   \   0000BE   3400         ADDC    A,#0x0
   \   0000C0   FD           MOV     R5,A
   \   0000C1   C3           CLR     C
   \   0000C2   EC           MOV     A,R4
   \   0000C3   9406         SUBB    A,#0x6
   \   0000C5   ED           MOV     A,R5
   \   0000C6   9400         SUBB    A,#0x0
   \   0000C8   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000CA   65D0         XRL     A,PSW
   \   0000CC   33           RLC     A
   \   0000CD   4095         JC      ??crc_water_gage_0
   2832            // uint8 a,b;
   2833              temp->crc[0]=LO_UINT16(Crc);
   \   0000CF   E8           MOV     A,R0
   \   0000D0   8A82         MOV     DPL,R2
   \   0000D2   8B83         MOV     DPH,R3
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   F0           MOVX    @DPTR,A
   2834              temp->crc[1]=HI_UINT16(Crc);
   \   0000DB   E9           MOV     A,R1
   \   0000DC   8A82         MOV     DPL,R2
   \   0000DE   8B83         MOV     DPH,R3
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   F0           MOVX    @DPTR,A
   2835             
   2836          }
   \   0000E8   7408         MOV     A,#0x8
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000ED   02....       LJMP    ?Subroutine61 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   2837          
   2838          /*********************************************************************
   2839           * @fn      p2p_test_Send_Water_Gage
   2840           *
   2841           * @brief   
   2842           *
   2843           * @param   Freq: the time , send data to coor unit s
   2844           *          Require: the commend for read value once
   2845           *
   2846           * @return  none
   2847           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2848          void p2p_test_Send_Water_Gage(uint8 FreqOrRequire,uint16 watergageuint)
   \                     p2p_test_Send_Water_Gage:
   2849          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2850           // if (FreqOrRequire == FREQ)
   2851            //  start_Water_gage_timer();
   2852           /*  {
   2853               uint8 timeout = 0;
   2854               if(!SendWaterGageRemainTime)
   2855               {
   2856                 SendWaterGageRemainTime= SendWaterGageTimeFreq;
   2857                 timeout = 1;
   2858               }
   2859               if(SendWaterGageRemainTime > 65)//osal_start_timerEx max time is 65.535s
   2860               {
   2861                 SendWaterGageRemainTime-= 65;
   2862                 osal_start_timerEx( p2p_test_TaskID,
   2863                                    p2p_test_SEND_WATER_GAGE_MSG_EVT, 
   2864                                    65000);
   2865               }
   2866               else 
   2867               {
   2868                 osal_start_timerEx(p2p_test_TaskID,
   2869                                    p2p_test_SEND_WATER_GAGE_MSG_EVT, 
   2870                                    SendWaterGageRemainTime*1000);
   2871                SendWaterGageRemainTime= 0;
   2872               }
   2873               if(!timeout)
   2874               {
   2875                 return;
   2876               }
   2877             }*/
   2878          //P1_1可用
   2879            if(water_gage_on ==0 )
   \   00000E   90....       MOV     DPTR,#water_gage_on
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7024         JNZ     ??p2p_test_Send_Water_Gage_0
   2880            {
   2881              if(acceptance == 1)
   \   000014   90....       MOV     DPTR,#acceptance
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   7004         JNZ     ??p2p_test_Send_Water_Gage_1
   2882              {
   2883                 P1_1 = 1;//开启水位计
   \                     ??p2p_test_Send_Water_Gage_2:
   \   00001C   D291         SETB    0x90.1
   \   00001E   8007         SJMP    ??p2p_test_Send_Water_Gage_3
   2884              }
   2885              else if(acceptance == 0 && P1_1 == 0 )
   \                     ??p2p_test_Send_Water_Gage_1:
   \   000020   E0           MOVX    A,@DPTR
   \   000021   7004         JNZ     ??p2p_test_Send_Water_Gage_3
   \   000023   A291         MOV     C,0x90.1
   \   000025   50F5         JNC     ??p2p_test_Send_Water_Gage_2
   2886              {
   2887                P1_1 = 1;
   2888              }
   2889              P1_1 = 1;
   \                     ??p2p_test_Send_Water_Gage_3:
   \   000027   D291         SETB    0x90.1
   2890              water_gage_on = 1;
   \   000029   7401         MOV     A,#0x1
   \   00002B   90....       MOV     DPTR,#water_gage_on
   \   00002E   F0           MOVX    @DPTR,A
   2891              osal_start_timerEx(p2p_test_TaskID,
   2892                             p2p_test_SEND_WATER_GAGE_MSG_EVT, 
   2893                             60000);   //等待一分钟，以使水位计数据稳定
   \   00002F                ; Setup parameters for call to function osal_start_timerEx
   \   00002F   7C60         MOV     R4,#0x60
   \   000031   7DEA         MOV     R5,#-0x16
   \   000033   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000036   806A         SJMP    ??CrossCallReturnLabel_76
   2894            } 
   2895            else 
   2896            {
   2897               no_charge_flag =1;
   \                     ??p2p_test_Send_Water_Gage_0:
   \   000038   7401         MOV     A,#0x1
   \   00003A   90....       MOV     DPTR,#no_charge_flag
   \   00003D   F0           MOVX    @DPTR,A
   2898           //send to uart 
   2899               Water_Send_Infor_t *temp_water=(Water_Send_Infor_t *)osal_msg_allocate(sizeof(Water_Send_Infor_t));
   \   00003E                ; Setup parameters for call to function osal_msg_allocate
   \   00003E   7A08         MOV     R2,#0x8
   \   000040   7B00         MOV     R3,#0x0
   \   000042   12....       LCALL   ??osal_msg_allocate?relay
   \   000045   8A..         MOV     ?V0 + 0,R2
   \   000047   8B..         MOV     ?V0 + 1,R3
   2900               temp_water->station_number=Station_Num;
   \   000049   7401         MOV     A,#0x1
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   F0           MOVX    @DPTR,A
   2901               temp_water->func_code=Water_Func_Code;
   \   000050   7403         MOV     A,#0x3
   \   000052   A3           INC     DPTR
   \   000053   F0           MOVX    @DPTR,A
   2902               temp_water->first_addr[0]=HI_UINT16(watergageuint);
   \   000054   EF           MOV     A,R7
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   F0           MOVX    @DPTR,A
   2903               temp_water->first_addr[1]=LO_UINT16(watergageuint);
   \   00005C   EE           MOV     A,R6
   \   00005D   8A82         MOV     DPL,R2
   \   00005F   8B83         MOV     DPH,R3
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   12....       LCALL   ?Subroutine33 & 0xFFFF
   2904               temp_water->read_num[0]=HI_UINT16(Water_num);
   \                     ??CrossCallReturnLabel_181:
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   F0           MOVX    @DPTR,A
   2905               temp_water->read_num[1]=LO_UINT16(Water_num);
   \   000069   7402         MOV     A,#0x2
   \   00006B   8A82         MOV     DPL,R2
   \   00006D   8B83         MOV     DPH,R3
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   F0           MOVX    @DPTR,A
   2906               crc_water_gage(temp_water);
   \   000075                ; Setup parameters for call to function crc_water_gage
   \   000075   12....       LCALL   ??crc_water_gage?relay
   2907               P1_0=1;
   \   000078   D290         SETB    0x90.0
   2908              // P2_0=1;
   2909               halWait(21);
   \   00007A                ; Setup parameters for call to function halWait
   \   00007A   7915         MOV     R1,#0x15
   \   00007C   12....       LCALL   ??halWait?relay
   2910             //  halWait(251);
   2911             //  halWait(251);
   2912            // HalUARTWrite(0, (uint8 *)(temp_water),sizeof(Water_Send_Infor_t)); 
   2913             HalUARTWrite(1, (uint8 *)temp_water,sizeof(Water_Send_Infor_t)); 
   \   00007F                ; Setup parameters for call to function HalUARTWrite
   \   00007F   7C08         MOV     R4,#0x8
   \   000081   7D00         MOV     R5,#0x0
   \   000083   AA..         MOV     R2,?V0 + 0
   \   000085   AB..         MOV     R3,?V0 + 1
   \   000087   7901         MOV     R1,#0x1
   \   000089   12....       LCALL   ??HalUARTWrite?relay
   2914             halWait(15);
   \   00008C                ; Setup parameters for call to function halWait
   \   00008C   790F         MOV     R1,#0xf
   \   00008E   12....       LCALL   ??halWait?relay
   2915             osal_msg_deallocate((uint8 *)temp_water);
   \   000091                ; Setup parameters for call to function osal_msg_deallocate
   \   000091   AA..         MOV     R2,?V0 + 0
   \   000093   AB..         MOV     R3,?V0 + 1
   \   000095   12....       LCALL   ??osal_msg_deallocate?relay
   2916             P1_0=~P1_0;
   \   000098   A290         MOV     C,0x90.0
   \   00009A   B3           CPL     C
   \   00009B   9290         MOV     0x90.0,C
   2917              
   2918             //  halWait(20);
   2919             
   2920              // Water_Gage_t  temp_water_gage;
   2921           
   2922             
   2923              /* temp_water.station_number=0x01;
   2924               temp_water.func_code=0x03;
   2925               temp_water.first_addr[0]=0x00;
   2926               temp_water.first_addr[1]=0x01;
   2927               temp_water.read_num[0]=0x00;
   2928               temp_water.read_num[1]=0x02;
   2929              // uint8 a=0x01;
   2930               crc_water_gage(&temp_water);*/
   2931               
   2932              // temp_water.crc[0]=0xc4;//LO_UINT16(crc_water_gage(&temp));
   2933               //temp_water.crc[1]=0x0b;//HI_UINT16(crc_water_gage(&temp));
   2934                //p2p_test_SendToUart((uint8 *)(&a),1);
   2935          #if DEBUG 
   2936                    uint8 x3 = 0xCC;
   \   00009D   74CC         MOV     A,#-0x34
   \   00009F   12....       LCALL   ?Subroutine27 & 0xFFFF
   2937                    HalUARTWrite(0,&x3, sizeof(x3));
   2938          #endif  
   2939            }   
   2940           }
   \                     ??CrossCallReturnLabel_76:
   \   0000A2   7401         MOV     A,#0x1
   \   0000A4   02....       LJMP    ?Subroutine59 & 0xFFFF
   \   0000A7                REQUIRE _A_P1
   2941          
   2942          
   2943          
   2944          /*********************************************************************
   2945           * @fn      halWait
   2946           *
   2947           * @brief   
   2948           *
   2949           * @param   none
   2950           *
   2951           * @return  none
   2952           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2953          uint8 halWait(unsigned char wait){
   \                     halWait:
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   2954             unsigned long largeWait;
   2955          
   2956             if(wait == 0)
   \   000005   E9           MOV     A,R1
   \   000006   7005         JNZ     ??halWait_0
   2957             {return 0;}
   \                     ??halWait_1:
   \   000008   7900         MOV     R1,#0x0
   \   00000A   02....       LJMP    ??Subroutine53_0 & 0xFFFF
   2958             largeWait = ((unsigned short) (wait << 7));
   2959             largeWait += 114*wait;
   2960          
   2961          
   2962             largeWait = (largeWait >> CLKSPD);
   \                     ??halWait_0:
   \   00000D   8982         MOV     DPL,R1
   \   00000F   AA82         MOV     R2,DPL
   \   000011   8A..         MOV     ?V0 + 0,R2
   \   000013   75..00       MOV     ?V0 + 1,#0x0
   \   000016   7407         MOV     A,#0x7
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   F5..         MOV     ?V0 + 2,A
   \   00001F   F5..         MOV     ?V0 + 3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F072       MOV     B,#0x72
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   ACF0         MOV     R4,B
   \   000029   E4           CLR     A
   \   00002A   2C           ADD     A,R4
   \   00002B   8A..         MOV     ?V0 + 4,R2
   \   00002D   F5..         MOV     ?V0 + 5,A
   \   00002F   33           RLC     A
   \   000030   95E0         SUBB    A,0xE0 /* A   */
   \   000032   F5..         MOV     ?V0 + 6,A
   \   000034   F5..         MOV     ?V0 + 7,A
   \   000036   78..         MOV     R0,#?V0 + 0
   \   000038   79..         MOV     R1,#?V0 + 4
   \   00003A   12....       LCALL   ?L_ADD
   \   00003D   E5C6         MOV     A,0xc6
   \   00003F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000041   E4           CLR     A
   \   000042   92E0         MOV     0xE0 /* A   */.0,C
   \   000044   78..         MOV     R0,#?V0 + 0
   \   000046   12....       LCALL   ?UL_SHR
   2963             while(largeWait--);
   \                     ??halWait_2:
   \   000049   85....       MOV     ?V0 + 4,?V0 + 0
   \   00004C   85....       MOV     ?V0 + 5,?V0 + 1
   \   00004F   85....       MOV     ?V0 + 6,?V0 + 2
   \   000052   85....       MOV     ?V0 + 7,?V0 + 3
   \   000055   90....       MOV     DPTR,#__Constant_ffffffff
   \   000058   78..         MOV     R0,#?V0 + 0
   \   00005A   12....       LCALL   ?L_ADD_X
   \   00005D   90....       MOV     DPTR,#__Constant_0
   \   000060   78..         MOV     R0,#?V0 + 4
   \   000062   12....       LCALL   ?L_EQ_X
   \   000065   70E2         JNZ     ??halWait_2
   \   000067   809F         SJMP    ??halWait_1
   \   000069                REQUIRE CLKCON
   2964          
   2965             return 0;
   2966          }
   2967          
   2968          //test for route to route
   2969          
   2970          /*
   2971          void READ_TEST(afIncomingMSGPacket_t *pkt )
   2972          {
   2973             // afIncomingMSGPacket_t *tmp_pkt=(afIncomingMSGPacket_t)*pkt;
   2974             // p2p_test_SendToUart(pkt->cmd.Data, pkt->cmd.DataLength);
   2975              HalUARTWrite(0,(pkt->cmd.Data), pkt->cmd.DataLength);
   2976          }
   2977          */
   2978          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2979          void insert_RelationMap(struct RelationMap_t *map,uint16 addr,uint8 zigbee_id)
   \                     insert_RelationMap:
   2980          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 2,R1
   2981             struct RelationMap_t *temp_map=Tail_Map;
   \   00000B   90....       MOV     DPTR,#Tail_Map
   \   00000E   12....       LCALL   ?Subroutine14 & 0xFFFF
   2982             map=(struct RelationMap_t *)osal_msg_allocate(sizeof(struct RelationMap_t));
   \                     ??CrossCallReturnLabel_40:
   \   000011                ; Setup parameters for call to function osal_msg_allocate
   \   000011   7A05         MOV     R2,#0x5
   \   000013   7B00         MOV     R3,#0x0
   \   000015   12....       LCALL   ??osal_msg_allocate?relay
   \   000018   8A..         MOV     ?V0 + 4,R2
   \   00001A   8B..         MOV     ?V0 + 5,R3
   \   00001C   A8..         MOV     R0,?V0 + 4
   \   00001E   A9..         MOV     R1,?V0 + 5
   2983             map->addr16=addr;
   \   000020   8882         MOV     DPL,R0
   \   000022   8983         MOV     DPH,R1
   \   000024   EE           MOV     A,R6
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EF           MOV     A,R7
   \   000028   F0           MOVX    @DPTR,A
   2984             map->Zigbee_id=zigbee_id;
   \   000029   8882         MOV     DPL,R0
   \   00002B   8983         MOV     DPH,R1
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E5..         MOV     A,?V0 + 2
   \   000031   F0           MOVX    @DPTR,A
   2985             map->next = NULL;
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   A3           INC     DPTR
   \   00003C   F0           MOVX    @DPTR,A
   2986             if(temp_map!=NULL && map!=NULL)
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   7002         JNZ     ??insert_RelationMap_0
   \   000041   E5..         MOV     A,?V0 + 1
   \                     ??insert_RelationMap_0:
   \   000043   601A         JZ      ??CrossCallReturnLabel_92
   \   000045   E8           MOV     A,R0
   \   000046   7001         JNZ     ??insert_RelationMap_1
   \   000048   E9           MOV     A,R1
   \                     ??insert_RelationMap_1:
   \   000049   6014         JZ      ??CrossCallReturnLabel_92
   2987             {
   2988               Tail_Map->next=map;
   \   00004B   90....       MOV     DPTR,#Tail_Map
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   FA           MOV     R2,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F583         MOV     DPH,A
   \   000054   8A82         MOV     DPL,R2
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   2989               Tail_Map=map;
   \                     ??CrossCallReturnLabel_91:
   \   00005C   12....       LCALL   ?Subroutine31 & 0xFFFF
   2990             }
   2991             //osal_msg_deallocate((uint8 *)map);
   2992          }
   \                     ??CrossCallReturnLabel_92:
   \   00005F   7F06         MOV     R7,#0x6
   \   000061   02....       LJMP    ?BANKED_LEAVE_XDATA
   2993          
   2994          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2995          uint8 search_RelationMap(uint16 addr)
   \                     search_RelationMap:
   2996          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2997            struct RelationMap_t *temp_map;
   2998            temp_map=Head_Map;
   \   000004   90....       MOV     DPTR,#Head_Map
   \   000007   8001         SJMP    ??search_RelationMap_0
   2999            while(temp_map!=NULL)
   3000            {
   3001              if(addr==temp_map->addr16)
   3002              {
   3003                return (temp_map->Zigbee_id);
   3004              }
   3005              else
   3006              {
   3007                temp_map=temp_map->next;
   \                     ??search_RelationMap_1:
   \   000009   A3           INC     DPTR
   \                     ??search_RelationMap_0:
   \   00000A   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   3008              }
   \                     ??CrossCallReturnLabel_53:
   \   00000D   E8           MOV     A,R0
   \   00000E   7001         JNZ     ??search_RelationMap_2
   \   000010   E9           MOV     A,R1
   \                     ??search_RelationMap_2:
   \   000011   6017         JZ      ??search_RelationMap_3
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6A           XRL     A,R2
   \   000019   7003         JNZ     ??search_RelationMap_4
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6B           XRL     A,R3
   \                     ??search_RelationMap_4:
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   70E3         JNZ     ??search_RelationMap_1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   8002         SJMP    ??search_RelationMap_5
   3009            }
   3010            return 0;
   \                     ??search_RelationMap_3:
   \   00002A   7900         MOV     R1,#0x0
   \                     ??search_RelationMap_5:
   \   00002C   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   3011          }

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_40400000:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_40400000>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffffff:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffffff>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for p2p_test_ClusterList>`:
   \   000000   01000200     DW 1, 2, 4
   \            0400    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for p2p_test_SimpleDesc>`:
   \   000000   0A           DB 10
   \   000001   040F0100     DW 3844, 1
   \   000005   0003         DB 0, 3
   \   000007   ....         DW p2p_test_ClusterList
   \   000009   03           DB 3
   \   00000A   ....         DW p2p_test_ClusterList

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_40400000>`:
   \   000000   00004040     DD 40400000H

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffffff>`:
   \   000000   FFFFFFFF     DD 4294967295

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??check_water_gage_charge?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    check_water_gage_charge

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTWrite_uint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTWrite_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Water_gage_forecastValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Water_gage_forecastValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??start_Water_gage_timer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    start_Water_gage_timer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_ProcessZDOMsgs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_ProcessZDOMsgs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_MessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_MessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_recv_108clusterId?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_recv_108clusterId

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_recv_RelationMsgclusterId?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_recv_RelationMsgclusterId

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_RecvFromUart?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_RecvFromUart

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_SendToUart?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_SendToUart

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??fill_AppHead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    fill_AppHead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??fill_AppHead_sn?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    fill_AppHead_sn

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??fill_NodeId_time?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    fill_NodeId_time

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SendMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SendMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_SendRelationPkt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_SendRelationPkt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_StartDataSensorTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_StartDataSensorTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??crc_water_gage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    crc_water_gage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??p2p_test_Send_Water_Gage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    p2p_test_Send_Water_Gage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halWait?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halWait

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??insert_RelationMap?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    insert_RelationMap

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??search_RelationMap?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    search_RelationMap

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     HalUARTWrite_uint16                3      0     39
       -> HalUARTWrite                  4      0      4
     SendMsg                            0      0     64
       -> p2p_test_SendToUart           0      0     24
       -> AF_DataRequest                0      0     42
     Water_gage_forecastValue           8      0    107
     check_water_gage_charge            3      0     24
       -> osal_start_timerEx            4      0      2
       -> osal_start_timerEx            4      0      2
       -> HalUARTWrite                  4      0      2
     crc_water_gage                     1      0     30
     fill_AppHead                       3      0     48
     fill_AppHead_sn                    3      0     31
     fill_NodeId_time                   1      0     52
       -> osal_GetSystemClock           0      0     30
     halWait                            0      0     33
     insert_RelationMap                 1      0     36
       -> osal_msg_allocate             0      0     28
     p2p_test_Init                      3      0      0
       -> osal_msg_allocate             4      0      0
       -> afRegister                    4      0      0
       -> OpenP1Interrupt               4      0      0
       -> RegisterP1Interrupt           4      0      0
       -> StartP1Interrupt              4      0      0
       -> SPIMgr_RegisterTaskID         4      0      0
       -> ZDO_RegisterForZDOMsg         4      0      0
       -> ZDO_RegisterForZDOMsg         4      0      0
     p2p_test_MessageMSGCB              0      0     33
       -> p2p_test_recv_108clusterId
                                        0      0     20
       -> p2p_test_recv_RelationMsgclusterId
                                        0      0     20
     p2p_test_ProcessEvent              1      0     23
       -> osal_msg_receive              0      0     46
       -> HalUARTWrite                  0      0     46
       -> osal_msg_deallocate           0      0     46
       -> osal_msg_receive              0      0     46
       -> p2p_test_ProcessZDOMsgs       0      0     46
       -> HalUARTWrite                  0      0     46
       -> p2p_test_RecvFromUart         0      0     46
       -> p2p_test_MessageMSGCB         0      0     46
       -> osal_start_timerEx            0      0     46
       -> HalUARTWrite                  0      0     46
       -> osal_stop_timerEx             0      0     46
       -> osal_stop_timerEx             0      0     46
       -> HalUARTWrite                  0      0     46
       -> osal_start_timerEx            0      0     46
       -> HalUARTWrite                  0      0     46
       -> HalUARTWrite                  0      0     46
       -> HalUARTWrite                  0      0     46
       -> HalUARTWrite                  0      0     46
       -> HalUARTWrite                  0      0     46
       -> HalUARTWrite                  0      0     46
       -> HalUARTWrite                  0      0     46
       -> p2p_test_SendRelationPkt      0      0     46
       -> p2p_test_Send_Water_Gage      0      0     46
       -> start_Water_gage_timer        0      0     46
       -> check_water_gage_charge       0      0     46
     p2p_test_ProcessZDOMsgs            0      0     33
       -> HalLedSet                     0      0     20
       -> HalLedSet                     0      0     20
       -> ZDO_ParseEPListRsp            0      0     20
       -> HalLedSet                     0      0     20
       -> osal_mem_free                 0      0     20
     p2p_test_RecvFromUart              2      0     78
       -> HalUARTWrite                  0      0     74
       -> fill_AppHead                  0      0     78
       -> fill_NodeId_time              0      0     74
       -> SendMsg                       0      0     86
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite_uint16           0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite                  0      0     74
       -> HalUARTWrite_uint16           0      0     74
       -> Water_gage_forecastValue      0      0    110
       -> HalUARTWrite_uint16           0      0     74
       -> start_Water_gage_timer        0      0     74
       -> osal_stop_timerEx             0      0     74
       -> p2p_test_StartDataSensorTimer
                                        0      0     74
       -> AF_DataRequest                0      0     92
       -> p2p_test_recv_108clusterId
                                        0      0     74
       -> AF_DataRequest                0      0     92
     p2p_test_SendRelationPkt           1      0     61
       -> osal_start_timerEx            0      0     64
       -> fill_AppHead                  0      0     68
       -> SendMsg                       0      0     76
       -> SendMsg                       0      0     76
     p2p_test_SendToUart                1      0     34
       -> SPIMgr_CalcFCS                0      0     34
       -> SPIMgr_CalcFCS                0      0     34
       -> SPIMgr_CalcFCS                0      0     34
       -> HalUARTWrite                  0      0     34
       -> HalUARTWrite                  0      0     34
       -> HalUARTWrite                  0      0     34
     p2p_test_Send_Water_Gage           1      0     36
       -> osal_start_timerEx            0      0     26
       -> osal_msg_allocate             0      0     26
       -> crc_water_gage                0      0     26
       -> halWait                       0      0     26
       -> HalUARTWrite                  0      0     26
       -> halWait                       0      0     26
       -> osal_msg_deallocate           0      0     26
       -> HalUARTWrite                  0      0     26
     p2p_test_StartDataSensorTimer      2      0     37
       -> osal_start_timerEx            4      0      0
       -> osal_start_timerEx            4      0      0
     p2p_test_recv_108clusterId         1      0     60
       -> p2p_test_SendToUart           0      0     34
       -> osal_msg_allocate             0      0     34
       -> fill_AppHead_sn               0      0     42
       -> SendMsg                       0      0     46
       -> HalUARTWrite_uint16           0      0     34
       -> osal_msg_deallocate           0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite_uint16           0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite                  0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite                  0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite                  0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite                  0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite_uint16           0      0     34
       -> HalUARTWrite_uint16           0      0     34
       -> HalUARTWrite_uint16           0      0     34
       -> HalUARTWrite                  0      0     34
       -> HalUARTWrite                  0      0     34
       -> HalUARTWrite                  0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite                  0      0     34
       -> SendMsg                       0      0     46
       -> HalUARTWrite                  0      0     34
       -> halWait                       0      0     34
     p2p_test_recv_RelationMsgclusterId
                                        1      0     41
       -> osal_msg_allocate             0      0     44
       -> fill_AppHead                  0      0     48
       -> search_RelationMap            0      0     44
       -> insert_RelationMap            0      0     44
       -> AF_DataRequest                0      0     62
       -> SendMsg                       0      0     56
       -> osal_msg_deallocate           0      0     44
       -> osal_stop_timerEx             0      0     44
       -> p2p_test_StartDataSensorTimer
                                        0      0     44
     search_RelationMap                 2      0     22
     start_Water_gage_timer             2      0     37
       -> osal_start_timerEx            4      0      0
       -> osal_start_timerEx            4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P1                             1
     _A_P2                             1
     _A_IEN0                           1
     CLKCON                            1
     WDCTL                             1
     P1SEL                             1
     P2SEL                             1
     P1DIR                             1
     P2DIR                             1
     RES                               1
     ARM_ID                            1
     Zigbee_ID                         1
     Water_gage_err                    2
     Water_gage_SerialNumber           2
     Water_gage_time                   2
     now                               4
     Water_gage_forValue               2
     Water_Gage_data_and_time         18
     no_charge_flag                    1
     water_gage_on                     1
     CheckWaterGageChargeTimeFreq      2
     Water_gage_err_a                  1
     Water_gage_err_b                  1
     Water_gage_err_c                  1
     relation_done                     1
     acceptance                        1
     p2p_test_ClusterList              6
     p2p_test_SimpleDesc              12
     p2p_test_epDesc                   6
     p2p_test_TaskID                   1
     p2p_test_NwkState                 1
     p2p_test_TransID                  1
     p2p_test_DstAddr                  4
     p2p_test_EnddeviceAddr            4
     shortaddr                         2
     fatheraddr                        2
     SendWaterGageTimeFreq             2
     SendWaterGageRemainTime           2
     WaterGageUnit                     2
     WaterGageFlag                     1
     Head_Map                          2
     Tail_Map                          2
     FlagMap                           2
     check_water_gage_charge          49
     ?Subroutine52                    10
     ?Subroutine27                    21
     ?Subroutine44                     6
     ?Subroutine20                    10
     ?Subroutine46                    11
     ?Subroutine2                     17
     ?Subroutine49                    22
     HalUARTWrite_uint16              48
     Water_gage_forecastValue       1244
     ?Subroutine0                     12
     ?Subroutine14                     4
     ?Subroutine43                     8
     ?Subroutine53                     8
     start_Water_gage_timer          101
     ?Subroutine31                     9
     p2p_test_Init                   337
     ?Subroutine16                    12
     ?Subroutine9                     13
     ?Subroutine8                      6
     ?Subroutine47                    12
     p2p_test_ProcessEvent           472
     ?Subroutine59                     8
     ?Subroutine19                    12
     ?Subroutine54                     6
     ?Subroutine55                     6
     ?Subroutine45                    11
     p2p_test_ProcessZDOMsgs         149
     ?Subroutine35                    10
     ?Subroutine60                     5
     p2p_test_MessageMSGCB            65
     ?Subroutine6                     22
     p2p_test_recv_108clusterId      830
     ?Subroutine21                     5
     ?Subroutine58                     5
     ?Subroutine11                    19
     ?Subroutine57                     5
     ?Subroutine7                     18
     ?Subroutine1                     18
     ?Subroutine56                     6
     ?Subroutine39                    10
     ?Subroutine36                    18
     ?Subroutine37                     9
     ?Subroutine23                     9
     ?Subroutine3                     12
     ?Subroutine38                    14
     ?Subroutine25                     9
     p2p_test_recv_RelationMsgclusterId
                                     505
     ?Subroutine30                    11
     ?Subroutine26                    12
     ?Subroutine12                    14
     p2p_test_RecvFromUart          1496
     ?Subroutine42                    16
     ?Subroutine41                     6
     ?Subroutine50                    11
     ?Subroutine28                     8
     ?Subroutine24                    12
     ?Subroutine22                     8
     ?Subroutine18                    11
     ?Subroutine15                    26
     ?Subroutine13                    11
     ?Subroutine10                    17
     ?Subroutine5                     13
     ?Subroutine4                     16
     ack_num                           1
     p2p_test_SendToUart             158
     fill_AppHead                     77
     ?Subroutine61                     5
     ?Subroutine34                     4
     ?Subroutine48                     6
     ?Subroutine51                     7
     ?Subroutine33                     8
     fill_AppHead_sn                 105
     fill_NodeId_time                134
     ?Subroutine40                     8
     ?Subroutine29                     8
     SendMsg                         107
     p2p_test_SendRelationPkt        202
     p2p_test_StartDataSensorTimer    17
     crc_water_gage                  240
     ?Subroutine32                     5
     p2p_test_Send_Water_Gage        167
     halWait                         105
     insert_RelationMap              100
     search_RelationMap               47
     __Constant_40400000               4
     __Constant_ffffffff               4
     __Constant_0                      4
     ?<Initializer for p2p_test_ClusterList>
                                       6
     ?<Initializer for p2p_test_SimpleDesc>
                                      12
     ?<Initializer for __Constant_40400000>
                                       4
     ?<Initializer for __Constant_ffffffff>
                                       4
     ?<Initializer for __Constant_0>
                                       4
     ??check_water_gage_charge?relay
                                       6
     ??HalUARTWrite_uint16?relay       6
     ??Water_gage_forecastValue?relay
                                       6
     ??start_Water_gage_timer?relay    6
     ??p2p_test_Init?relay             6
     ??p2p_test_ProcessEvent?relay     6
     ??p2p_test_ProcessZDOMsgs?relay
                                       6
     ??p2p_test_MessageMSGCB?relay     6
     ??p2p_test_recv_108clusterId?relay
                                       6
     ??p2p_test_recv_RelationMsgclusterId?relay
                                       6
     ??p2p_test_RecvFromUart?relay     6
     ??p2p_test_SendToUart?relay       6
     ??fill_AppHead?relay              6
     ??fill_AppHead_sn?relay           6
     ??fill_NodeId_time?relay          6
     ??SendMsg?relay                   6
     ??p2p_test_SendRelationPkt?relay
                                       6
     ??p2p_test_StartDataSensorTimer?relay
                                       6
     ??crc_water_gage?relay            6
     ??p2p_test_Send_Water_Gage?relay
                                       6
     ??halWait?relay                   6
     ??insert_RelationMap?relay        6
     ??search_RelationMap?relay        6

 
 7 416 bytes in segment BANKED_CODE
   138 bytes in segment BANK_RELAYS
     9 bytes in segment SFR_AN
    30 bytes in segment XDATA_I
    30 bytes in segment XDATA_ID
    77 bytes in segment XDATA_Z
 
 7 572 bytes of CODE  memory (+ 12 bytes shared)
     0 bytes of DATA  memory (+  9 bytes shared)
    95 bytes of XDATA memory (+ 12 bytes shared)

Errors: none
Warnings: none
