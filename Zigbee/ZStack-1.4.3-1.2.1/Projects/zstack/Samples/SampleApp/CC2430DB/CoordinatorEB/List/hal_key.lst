###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    24/Jun/2011  23:53:24 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430EB\hal_key.c                     #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\SampleApp\CC2430DB\..\..\..\Tool #
#                          s\CC2430DB\f8wCoord.cfg" (-DCPU32MHZ               #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS           #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wConfig.cfg" (-DSECURE=0                 #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430EB\hal_key.c" -D CC2430EB -D ZAPP_P1 -D   #
#                          MT_TASK -D LCD_SUPPORTED=DEBUG -lC "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\CoordinatorEB\List\" -lA   #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\CoordinatorEB\Li #
#                          st\" --diag_suppress Pe001,Pa010 --diag_remark     #
#                          pe550 -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\SampleApp\CC2430DB\Coordin #
#                          atorEB\Obj\" -e --require_prototypes -z9           #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\" -I "C:\Texas   #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\SOURCE\" -I "C:\Texas   #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\"  #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\. #
#                          .\COMPONENTS\MT\" -I "C:\Texas                     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          HAL\INCLUDE\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          HAL\TARGET\CC2430EB\" -I "C:\Texas                 #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          OSAL\MCU\CCSOC\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          OSAL\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\SampleApp\CC2430DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas   #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\SEC\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\SYS\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\ZDO\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          ZMAC\F8W\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\SampleApp\CC2430DB\.. #
#                          \..\..\..\..\COMPONENTS\ZMAC\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          SERVICES\SADDR\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          SERVICES\SDATA\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          MAC\INCLUDE\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          MAC\HIGH_LEVEL\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          MAC\LOW_LEVEL\SRF03\" -I "C:\Texas                 #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\COMPONENTS\ #
#                          MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\CoordinatorEB\Lis #
#                          t\hal_key.lst                                      #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\CoordinatorEB\Obj #
#                          \hal_key.r51                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2007-11-07 11:54:17 -0800 (Wed, 07 Nov 2007) $
      4            Revision:       $Revision: 15885 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x8a
   \   unsigned char volatile __sfr P1IFG
   \                     P1IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr P1IEN
   \                     P1IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf6
   \   unsigned char volatile __sfr P1INP
   \                     P1INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_drivers.h"
     87          #include "hal_adc.h"
     88          #include "hal_key.h"
     89          #include "osal.h"
     90          
     91          /**************************************************************************************************
     92           *                                              MACROS
     93           **************************************************************************************************/
     94          
     95          /**************************************************************************************************
     96           *                                            CONSTANTS
     97           **************************************************************************************************/
     98          #define HAL_KEY_BIT0   0x01
     99          #define HAL_KEY_BIT1   0x02
    100          #define HAL_KEY_BIT2   0x04
    101          #define HAL_KEY_BIT3   0x08
    102          #define HAL_KEY_BIT4   0x10
    103          #define HAL_KEY_BIT5   0x20
    104          #define HAL_KEY_BIT6   0x40
    105          #define HAL_KEY_BIT7   0x80
    106          
    107          #define HAL_KEY_RISING_EDGE   0
    108          #define HAL_KEY_FALLING_EDGE  1
    109          
    110          #define HAL_KEY_PDUP2           0x80
    111          #define HAL_KEY_PDUP1           0x40
    112          #define HAL_KEY_PDUP0           0x20
    113          
    114          #define HAL_KEY_DEBOUNCE_VALUE  25
    115          #define HAL_KEY_POLLING_VALUE   100
    116          
    117          
    118          #if defined (HAL_BOARD_CC2430DB)
    119            #define HAL_KEY_SW_6_ENABLE
    120            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    121            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    122            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    123            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    124            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    125            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    126            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    127            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    128            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    129            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    130            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    131          
    132            #define HAL_KEY_JOYSTICK_ENABLE
    133            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    134          
    135            #define HAL_KEY_SW_5_ENABLE   /* 2430DB - SW5 is enabled based on key interrupt enable or not - see config */
    136            #define HAL_KEY_SW_5_PORT     P2                      /* Port location of SW5 */
    137            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT0            /* Bit location of SW5 */
    138            #define HAL_KEY_SW_5_SEL      P2SEL                   /* Port Select Register for SW5 */
    139            #define HAL_KEY_SW_5_DIR      P2DIR                   /* Port Direction Register for SW5 */
    140            #define HAL_KEY_SW_5_INP      P2INP                   /* Port Input Mode Register for SW5 */
    141            #define HAL_KEY_SW_5_IEN      IEN2                    /* Interrupt Enable Register for SW5 */
    142            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT1            /* Interrupt Enable bit for SW5 */
    143            #define HAL_KEY_SW_5_EDGE     HAL_KEY_FALLING_EDGE    /* Type of interrupt for SW5 */
    144            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    145            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    146            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT5            /* Interrupt enable bit for SW5 */
    147            #define HAL_KEY_SW_5_PXIFG    P2IFG                   /* Port Interrupt Flag for SW5 */
    148          
    149            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    150            #define HAL_KEY_POINT_HIGH_USED   0                   /* P0 can only be enabled/disabled as group of high or low nibble */
    151          #endif
    152          
    153          #if defined (HAL_BOARD_CC2430EB) || defined (HAL_BOARD_CC2430BB)
    154            #define HAL_KEY_SW_6_ENABLE
    155            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    156            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    157            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    158            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    159            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    160            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    161            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    162            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    163            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    164            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    165            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    166          
    167            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    168          #endif
    169          
    170          #if defined (HAL_BOARD_CC2430BB)
    171            #define HAL_KEY_POINT_HIGH_USED  0
    172          #endif
    173          
    174          #if defined (HAL_BOARD_CC2430EB)
    175            #define HAL_KEY_JOYSTICK_ENABLE
    176            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    177          
    178            #define HAL_KEY_SW_5_ENABLE
    179            #define HAL_KEY_SW_5_PORT     P0                      /* Port location of SW5 */
    180            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT5            /* Bit location of SW5 */
    181            #define HAL_KEY_SW_5_SEL      P0SEL                   /* Port Select Register for SW5 */
    182            #define HAL_KEY_SW_5_DIR      P0DIR                   /* Port Direction Register for SW5 */
    183            #define HAL_KEY_SW_5_INP      P0INP                   /* Port Input Mode Register for SW5 */
    184            #define HAL_KEY_SW_5_IEN      IEN1                    /* Interrupt Enable Register for SW5 */
    185            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW5 */
    186            #define HAL_KEY_SW_5_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW5 */
    187            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    188            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    189            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT4            /* Interrupt enable bit for SW5 */
    190            #define HAL_KEY_SW_5_PXIFG    P0IFG                   /* Port Interrupt Flag for SW5 */
    191          
    192            #define HAL_KEY_POINT_HIGH_USED   HAL_KEY_SW_5_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    193          #endif
    194          
    195          /**************************************************************************************************
    196           *                                            TYPEDEFS
    197           **************************************************************************************************/
    198          
    199          
    200          /**************************************************************************************************
    201           *                                        GLOBAL VARIABLES
    202           **************************************************************************************************/
    203          //static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
    204          //static halKeyCBack_t pHalKeyProcessFunction;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    205          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          uint8 halSaveIntKey;              /* used by ISR to save state of interrupt-driven keys */
   \                     halSaveIntKey:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          
    208          //static uint8 HalKeyConfigured;
    209          
    210          /**************************************************************************************************
    211           *                                        FUNCTIONS - Local
    212           **************************************************************************************************/
    213          void halProcessKeyInterrupt (void);
    214          
    215          
    216          /**************************************************************************************************
    217           *                                        FUNCTIONS - API
    218           **************************************************************************************************/
    219          /**************************************************************************************************
    220           * @fn      HalKeyInit
    221           *
    222           * @brief   Initilize Key Service
    223           *
    224           * @param   none
    225           *
    226           * @return  None
    227           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    228          void HalKeyInit( void )
   \                     HalKeyInit:
    229          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    230          #if (HAL_KEY == TRUE)
    231            /* Initialize previous key to 0 */
    232            halKeySavedKeys = 0;
    233          
    234          #if defined (HAL_KEY_SW_6_ENABLE)
    235            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
    236            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
    237          #endif
    238          
    239          #if defined (HAL_KEY_SW_5_ENABLE)
    240            HAL_KEY_SW_5_SEL &= ~(HAL_KEY_SW_5_BIT);    /* Set pin function to GPIO */
    241            HAL_KEY_SW_5_DIR &= ~(HAL_KEY_SW_5_BIT);    /* Set pin direction to Input */
    242            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
    243          #endif
    244          
    245            /* Initialize callback function */
    246            pHalKeyProcessFunction  = NULL;
    247          
    248            /* Start with key is not configured */
    249            HalKeyConfigured = FALSE;
    250          #endif /* HAL_KEY */
    251          }
   \   000000   02....       LJMP    ?BRET
    252          
    253          /**************************************************************************************************
    254           * @fn      HalKeyConfig
    255           *
    256           * @brief   Configure the Key serivce
    257           *
    258           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    259           *          cback - pointer to the CallBack function
    260           *
    261           * @return  None
    262           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    263          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    264          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    265          #if (HAL_KEY == TRUE)
    266            /* Enable/Disable Interrupt or */
    267            Hal_KeyIntEnable = interruptEnable;
    268          
    269            /* Register the callback fucntion */
    270            pHalKeyProcessFunction = cback;
    271          
    272            /* Determine if interrupt is enable or not */
    273            if (Hal_KeyIntEnable)
    274            {
    275          
    276              /*
    277                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    278                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    279                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    280                 will stop this problem.
    281              */
    282              #if defined (HAL_BOARD_CC2430DB)
    283                #undef HAL_KEY_SW_5_ENABLE                      /* Dis-allow SW5 when key interrupt is enable */
    284              #endif
    285          
    286          #if defined (HAL_KEY_SW_5_ENABLE)
    287              PICTL &= ~(HAL_KEY_SW_5_EDGEBIT);                 /* Set rising or falling edge */
    288            #if (HAL_KEY_SW_5_EDGE == HAL_KEY_FALLING_EDGE)
    289              PICTL |= HAL_KEY_SW_5_EDGEBIT;
    290            #endif
    291              HAL_KEY_SW_5_ICTL |= HAL_KEY_SW_5_ICTLBIT;        /* Set interrupt enable bit */
    292              HAL_KEY_SW_5_IEN |= HAL_KEY_SW_5_IENBIT;
    293              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);        /* Clear any pending interrupts */
    294          #endif
    295          
    296          #if defined (HAL_KEY_SW_6_ENABLE)
    297              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);                 /* Set rising or falling edge */
    298            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    299              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    300            #endif
    301              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;        /* Set interrupt enable bit */
    302              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
    303              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);        /* Clear any pending interrupts */
    304          #endif
    305          
    306              /* Do this only after the hal_key is configured - to work with sleep stuff */
    307              if (HalKeyConfigured == TRUE)
    308              {
    309                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
    310              }
    311            }
    312            else    /* Interrupts NOT enabled */
    313            {
    314          
    315              /*
    316                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    317                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    318                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    319                 will stop this problem.
    320              */
    321              #if defined (HAL_BOARD_CC2430DB)
    322                #define HAL_KEY_SW_5_ENABLE                     /* Allow SW5 only when key interrupt is disable */
    323              #endif
    324          
    325          #if defined (HAL_KEY_SW_6_ENABLE)
    326              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT);     /* Clear interrupt enable bit */
    327              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);
    328          #endif
    329          
    330          #if defined (HAL_KEY_SW_5_ENABLE)
    331              HAL_KEY_SW_5_ICTL &= ~(HAL_KEY_SW_5_ICTLBIT);     /* Clear interrupt enable bit */
    332              HAL_KEY_SW_5_IEN &= ~(HAL_KEY_SW_5_IENBIT);
    333          #endif
    334              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
    335            }
    336          
    337            /* Key now is configured */
    338            HalKeyConfigured = TRUE;
    339          #endif /* HAL_KEY */
    340          }
   \   000000   02....       LJMP    ?BRET
    341          
    342          /**************************************************************************************************
    343           * @fn      HalKeyRead
    344           *
    345           * @brief   Read the current value of a key
    346           *
    347           * @param   None
    348           *
    349           * @return  keys - current keys status
    350           **************************************************************************************************/
    351          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    353          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    354          
    355            uint8 keys = 0;
    356          
    357          #if (HAL_KEY == TRUE)
    358          
    359          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    360            uint8 ksave0 = 0;
    361            uint8 ksave1;
    362            uint8 adc;
    363          #endif
    364          
    365          #if defined (HAL_KEY_SW_6_ENABLE)
    366            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
    367            {
    368              keys |= HAL_KEY_SW_6;
    369            }
    370          #endif
    371          #if defined (HAL_KEY_SW_5_ENABLE)
    372            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
    373            {
    374              keys |= HAL_KEY_SW_5;
    375            }
    376          #endif
    377          
    378          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    379          /*
    380          *  The joystick control is encoded as an analog voltage.  Keep on reading
    381          *  the ADC until two consecutive key decisions are the same.
    382          */
    383          
    384            do
    385            {
    386              ksave1 = ksave0;    /* save previouse key reading */
    387          
    388              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
    389          
    390              if  (CHVER == 0x01)
    391              {
    392                /* Rev B */
    393                if ((adc >= 90) && (adc <= 100))
    394                {
    395                   ksave0 |= HAL_KEY_UP;
    396                }
    397                else if ((adc >= 75) && (adc <= 85))
    398                {
    399                  ksave0 |= HAL_KEY_RIGHT;
    400                }
    401                else if ((adc >= 45) && (adc <= 55))
    402                {
    403                  ksave0 |= HAL_KEY_LEFT;
    404                }
    405                else if (adc <= 10)
    406                {
    407                  ksave0 |= HAL_KEY_DOWN;
    408                }
    409                else if ((adc >= 101) && (adc <= 115))
    410                {
    411                }
    412              }
    413              else
    414              {
    415                 /* Rev C */
    416                if ((adc >= 90)  && (adc <= 104))
    417                {
    418                   ksave0 |= HAL_KEY_UP;
    419                }
    420                else if ((adc >= 75)  && (adc <= 89))
    421                {
    422                  ksave0 |= HAL_KEY_RIGHT;
    423                }
    424                else if ((adc >= 45)  && (adc <= 56))
    425                {
    426                  ksave0 |= HAL_KEY_LEFT;
    427                }
    428                else if (adc <= 10)
    429                {
    430                  ksave0 |= HAL_KEY_DOWN;
    431                }
    432                else if ((adc >= 105) && (adc <= 121))
    433                {
    434                }
    435              }
    436          
    437            } while (ksave0 != ksave1);
    438          
    439            keys |= ksave0;
    440          
    441          #endif
    442          
    443          #endif /* HAL_KEY */
    444          
    445            return keys;
   \   000000                REQUIRE ?Subroutine7
   \   000000                ; // Fall through to label ?Subroutine7

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    446          
    447          }
    448          
    449          
    450          /**************************************************************************************************
    451           * @fn      HalKeyPoll
    452           *
    453           * @brief   Called by hal_driver to poll the keys
    454           *
    455           * @param   None
    456           *
    457           * @return  None
    458           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    459          void HalKeyPoll (void)
   \                     HalKeyPoll:
    460          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    461          #if (HAL_KEY == TRUE)
    462          
    463            uint8 keys = 0;
    464          
    465          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    466            uint8 ksave0 = 0;
    467            uint8 ksave1;
    468            uint8 adc;
    469          #endif
    470          
    471            /*
    472            *  If interrupts are enabled, get the status of the interrupt-driven keys from 'halSaveIntKey'
    473            *  which is updated by the key ISR.  If Polling, read these keys directly.
    474            */
    475          #if defined (HAL_KEY_SW_6_ENABLE)
    476            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
    477            {
    478              keys |= HAL_KEY_SW_6;
    479            }
    480          #endif
    481          #if defined (HAL_KEY_SW_5_ENABLE)
    482            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
    483            {
    484              keys |= HAL_KEY_SW_5;
    485            }
    486          #endif
    487          
    488          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    489          /*
    490          *  The joystick control is encoded as an analog voltage.  Keep on reading
    491          *  the ADC until two consecutive key decisions are the same.
    492          */
    493          
    494            do
    495            {
    496              ksave1 = ksave0;    /* save previouse key reading */
    497          
    498              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
    499          
    500              if  (CHVER == 0x01)
    501              {
    502                /* Rev B */
    503                if ((adc >= 90) && (adc <= 100))
    504                {
    505                   ksave0 |= HAL_KEY_UP;
    506                }
    507                else if ((adc >= 75) && (adc <= 85))
    508                {
    509                  ksave0 |= HAL_KEY_RIGHT;
    510                }
    511                else if ((adc >= 45) && (adc <= 55))
    512                {
    513                  ksave0 |= HAL_KEY_LEFT;
    514                }
    515                else if (adc <= 10)
    516                {
    517                  ksave0 |= HAL_KEY_DOWN;
    518                }
    519                else if ((adc >= 101) && (adc <= 115))
    520                {
    521                }
    522              }
    523              else
    524              {
    525                 /* Rev C */
    526                if ((adc >= 90)  && (adc <= 104))
    527                {
    528                   ksave0 |= HAL_KEY_UP;
    529                }
    530                else if ((adc >= 75)  && (adc <= 89))
    531                {
    532                  ksave0 |= HAL_KEY_RIGHT;
    533                }
    534                else if ((adc >= 45)  && (adc <= 56))
    535                {
    536                  ksave0 |= HAL_KEY_LEFT;
    537                }
    538                else if (adc <= 10)
    539                {
    540                  ksave0 |= HAL_KEY_DOWN;
    541                }
    542                else if ((adc >= 105) && (adc <= 121))
    543                {
    544                }
    545              }
    546          
    547          
    548            } while (ksave0 != ksave1);
    549          
    550            keys |= ksave0;
    551          
    552          #endif
    553          
    554            /* Exit if polling and no keys have changed */
    555            if (!Hal_KeyIntEnable)
    556            {
    557              if (keys == halKeySavedKeys)
    558              {
    559                return;
    560              }
    561              halKeySavedKeys = keys;     /* Store the current keys for comparation next time */
    562            }
    563          
    564            /* Invoke Callback if new keys were depressed */
    565            if (keys && (pHalKeyProcessFunction))
    566            {
    567              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
    568            }
    569          
    570          #endif /* HAL_KEY */
    571          
    572          }
   \   000000   02....       LJMP    ?BRET
    573          
    574          
    575          /**************************************************************************************************
    576           * @fn      halProcessKeyInterrupt
    577           *
    578           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    579           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    580           *
    581           * @param
    582           *
    583           * @return
    584           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    585          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    586          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    587          
    588          #if (HAL_KEY == TRUE)
    589          
    590            bool    valid=FALSE;
    591          
    592          #if defined (HAL_KEY_SW_6_ENABLE)
    593            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)      /* Interrupt Flag has been set */
    594            {
    595              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);    /* Clear Interrupt Flag */
    596              valid = TRUE;
    597            }
    598          #endif
    599          
    600          #if defined (HAL_KEY_SW_5_ENABLE)
    601            if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)      /* Interrupt Flag has been set */
    602            {
    603              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);    /* Clear Interrupt Flag */
    604              valid = TRUE;
    605            }
    606          #endif
    607          
    608            if (valid)
    609            {
    610              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
    611            }
    612          #endif /* HAL_KEY */
    613          }
   \   000000   02....       LJMP    ?BRET
    614          
    615          /**************************************************************************************************
    616           * @fn      HalKeyEnterSleep
    617           *
    618           * @brief  - Get called to enter sleep mode
    619           *
    620           * @param
    621           *
    622           * @return
    623           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    624          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    625          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    626            /* Sleep!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    627             * It was set to tri-state during active state. It needs to be pulled-up.
    628             */
    629          #if defined (HAL_KEY_SW_5_ENABLE)
    630            HAL_KEY_SW_5_INP &= ~HAL_KEY_SW_5_BIT;       /* Set pin input mode to pull-up */
   \   000000   538FDF       ANL     0x8f,#0xdf
    631          #endif
    632          }
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE P0INP
    633          
    634          /**************************************************************************************************
    635           * @fn      HalKeyExitSleep
    636           *
    637           * @brief   - Get called when sleep is over
    638           *
    639           * @param
    640           *
    641           * @return  - return saved keys
    642           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    643          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    644          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    645            /* Wakeup!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    646             * It was pulled up during sleep. It needs to be set to tri-state during active state.
    647             */
    648          #if defined (HAL_KEY_SW_5_ENABLE)
    649            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
   \   000000   438F20       ORL     0x8f,#0x20
    650          #endif
    651          
    652            /* Wake up and read keys */
    653            return ( HalKeyRead () );
   \   000003   80..         SJMP    ?Subroutine7
   \   000005                REQUIRE P0INP
    654          }
    655          
    656          /***************************************************************************************************
    657           *                                    INTERRUPT SERVICE ROUTINE
    658           ***************************************************************************************************/
    659          
    660          /**************************************************************************************************
    661           * @fn      halKeyPort0Isr
    662           *
    663           * @brief   Port0 ISR
    664           *
    665           * @param
    666           *
    667           * @return
    668           **************************************************************************************************/
    669          //HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    670          //{
    671            /* P0IF is cleared by HW for CHVER < REV_E */
    672          
    673          //  halProcessKeyInterrupt();
    674          
    675          //  if( CHVER >= REV_E )
    676          //  {
    677              /* Make sure that we clear all enabled, but unused P0IFG bits.
    678               * For P0 we can only enable or disable high or low nibble, not bit by
    679               * bit. For P1 and P2 enabling of single bits are possible, therefore
    680               * will not any unused pins generate interrupts on P1 or P2.
    681               * We could have checked for low and high nibble in P0, but this
    682               * isn't necessary as long as we only clear unused pin interrupts.
    683               */
    684          //    P0IFG = (HAL_KEY_P0INT_LOW_USED | HAL_KEY_POINT_HIGH_USED);
    685          //    P0IF = 0;
    686          //    CLEAR_SLEEP_MODE();
    687          //  }
    688          //}
    689          
    690          /**************************************************************************************************
    691           * @fn      halKeyPort1Isr
    692           *
    693           * @brief   Port1 ISR
    694           *
    695           * @param
    696           *
    697           * @return
    698           **************************************************************************************************/
    699          /*
    700          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
    701          {
    702            if( CHVER <= REV_D )
    703            {
    704              P1IF = 0;
    705            }
    706          
    707            halProcessKeyInterrupt();
    708          
    709            if( CHVER >= REV_E )
    710            {
    711              P1IF = 0;
    712              CLEAR_SLEEP_MODE();
    713            }
    714          }
    715          */
    716          /**************************************************************************************************
    717           * @fn      halKeyPort2Isr
    718           *
    719           * @brief   Port2 ISR
    720           *
    721           * @param
    722           *
    723           * @return
    724           **************************************************************************************************/
    725          /*
    726          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
    727          {
    728            if( CHVER <= REV_D )
    729            {
    730              P2IF = 0;
    731            }
    732          
    733            halProcessKeyInterrupt();
    734          
    735            if( CHVER >= REV_E )
    736            {
    737              P2IF = 0;
    738              CLEAR_SLEEP_MODE();
    739            }
    740          */
    741          
    742          /**************************************************************************************************
    743          zyq add 
    744          **************************************************************************************************/
    745          #define FUN_SELECT_GENERAL      0
    746          #define FUN_SELECT_PERIPHERAL   1
    747          
    748          #define DIRECTION_INPUT         0
    749          #define DIRECTION_OUTPUT        1
    750          
    751          #define INPUT_MODE_PULLUP       0
    752          #define INPUT_MODE_PULLDOWN     1
    753          #define INPUT_MODE_TRISTATE     2
    754          #define INPUT_MODE_NULL         3
    755          
    756          #define RISE_EDGE               0
    757          #define FALL_EDGE               1
    758          
    759          //
    760          typedef void (*ISR_t) (void);
    761          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    762          static ISR_t P1_ISR_fun[8];
   \                     P1_ISR_fun:
   \   000000                DS 16
   \   000010                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    763          static uint8 P1InterruptTaskID[8];
   \                     P1InterruptTaskID:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    764          static rain_t sensor_rain;
   \                     sensor_rain:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    765          
    766          /**************************************************************************************************
    767           * @fn      OpenP1Interrupt
    768           *
    769           * @brief   
    770           *
    771           * @param
    772           *
    773           * @return
    774           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    775          void OpenP1Interrupt( uint8 pin, uint8 FunSelect, uint8 direction, uint8 InputMode, uint8 RiseFallEdge)
   \                     OpenP1Interrupt:
    776          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    777            if(FunSelect==FUN_SELECT_GENERAL)
   \   000005   EA           MOV     A,R2
   \   000006   75..01       MOV     ?V0 + 0,#0x1
   \   000009   75..00       MOV     ?V0 + 1,#0x0
   \   00000C   700D         JNZ     ??OpenP1Interrupt_0
    778            {
    779              P1SEL &= ~(1<<pin);
   \   00000E   E9           MOV     A,R1
   \   00000F   78..         MOV     R0,#?V0 + 0
   \   000011   12....       LCALL   ?S_SHL
   \   000014   E5..         MOV     A,?V0 + 0
   \   000016   F4           CPL     A
   \   000017   55F4         ANL     A,0xf4
   \   000019   800A         SJMP    ??OpenP1Interrupt_1
    780            } 
    781            else 
    782            {
    783              P1SEL |= (1<<pin);
   \                     ??OpenP1Interrupt_0:
   \   00001B   E9           MOV     A,R1
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?S_SHL
   \   000021   E5..         MOV     A,?V0 + 0
   \   000023   45F4         ORL     A,0xf4
   \                     ??OpenP1Interrupt_1:
   \   000025   F5F4         MOV     0xf4,A
    784            }
    785            
    786            if(direction==DIRECTION_INPUT)
   \   000027   EB           MOV     A,R3
   \   000028   75..01       MOV     ?V0 + 0,#0x1
   \   00002B   75..00       MOV     ?V0 + 1,#0x0
   \   00002E   7069         JNZ     ??OpenP1Interrupt_2
    787            {
    788              P1DIR &= ~(1<<pin);
   \   000030   E9           MOV     A,R1
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?S_SHL
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   F4           CPL     A
   \   000039   55FE         ANL     A,0xfe
   \   00003B   F5FE         MOV     0xfe,A
    789          
    790              if(InputMode==INPUT_MODE_PULLUP)
   \   00003D   EC           MOV     A,R4
   \   00003E   7018         JNZ     ??OpenP1Interrupt_3
    791              {
    792                P1INP &= ~(1<<pin);
   \   000040   75..01       MOV     ?V0 + 0,#0x1
   \   000043   75..00       MOV     ?V0 + 1,#0x0
   \   000046   E9           MOV     A,R1
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   F4           CPL     A
   \   00004F   55F6         ANL     A,0xf6
   \   000051   F5F6         MOV     0xf6,A
    793                P2INP &= ~(0x40);
   \   000053   53F7BF       ANL     0xf7,#0xbf
   \   000056   8034         SJMP    ??OpenP1Interrupt_4
    794              }
    795              else if (InputMode==INPUT_MODE_PULLDOWN)
   \                     ??OpenP1Interrupt_3:
   \   000058   7401         MOV     A,#0x1
   \   00005A   6C           XRL     A,R4
   \   00005B   7018         JNZ     ??OpenP1Interrupt_5
    796              {
    797                P1INP &= ~(1<<pin);
   \   00005D   75..01       MOV     ?V0 + 0,#0x1
   \   000060   75..00       MOV     ?V0 + 1,#0x0
   \   000063   E9           MOV     A,R1
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?S_SHL
   \   000069   E5..         MOV     A,?V0 + 0
   \   00006B   F4           CPL     A
   \   00006C   55F6         ANL     A,0xf6
   \   00006E   F5F6         MOV     0xf6,A
    798                P2INP |= (0x40);
   \   000070   43F740       ORL     0xf7,#0x40
   \   000073   8017         SJMP    ??OpenP1Interrupt_4
    799              } else if (InputMode==INPUT_MODE_TRISTATE)
   \                     ??OpenP1Interrupt_5:
   \   000075   7402         MOV     A,#0x2
   \   000077   6C           XRL     A,R4
   \   000078   7012         JNZ     ??OpenP1Interrupt_4
    800              {
    801                P1INP |= (1<<pin);
   \   00007A   75..01       MOV     ?V0 + 0,#0x1
   \   00007D   75..00       MOV     ?V0 + 1,#0x0
   \   000080   E9           MOV     A,R1
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   12....       LCALL   ?S_SHL
   \   000086   E5..         MOV     A,?V0 + 0
   \   000088   45F6         ORL     A,0xf6
   \   00008A   F5F6         MOV     0xf6,A
    802              }
    803              
    804              if(RiseFallEdge==RISE_EDGE)
   \                     ??OpenP1Interrupt_4:
   \   00008C   ED           MOV     A,R5
   \   00008D   7005         JNZ     ??OpenP1Interrupt_6
    805              {
    806                PICTL &= ~(0x02);
   \   00008F   538CFD       ANL     0x8c,#0xfd
   \   000092   8011         SJMP    ??OpenP1Interrupt_7
    807              }
    808              else
    809              {
    810                PICTL |= (0x02);
   \                     ??OpenP1Interrupt_6:
   \   000094   438C02       ORL     0x8c,#0x2
   \   000097   800C         SJMP    ??OpenP1Interrupt_7
    811              }
    812            } 
    813            else 
    814            {
    815              P1DIR |= (1<<pin);
   \                     ??OpenP1Interrupt_2:
   \   000099   E9           MOV     A,R1
   \   00009A   78..         MOV     R0,#?V0 + 0
   \   00009C   12....       LCALL   ?S_SHL
   \   00009F   E5..         MOV     A,?V0 + 0
   \   0000A1   45FE         ORL     A,0xfe
   \   0000A3   F5FE         MOV     0xfe,A
    816            }
    817            
    818            P1IFG &= ~(1<<pin);//clean
   \                     ??OpenP1Interrupt_7:
   \   0000A5   75..01       MOV     ?V0 + 0,#0x1
   \   0000A8   75..00       MOV     ?V0 + 1,#0x0
   \   0000AB   E9           MOV     A,R1
   \   0000AC   78..         MOV     R0,#?V0 + 0
   \   0000AE   12....       LCALL   ?S_SHL
   \   0000B1   E5..         MOV     A,?V0 + 0
   \   0000B3   F4           CPL     A
   \   0000B4   558A         ANL     A,0x8a
   \   0000B6   F58A         MOV     0x8a,A
    819            
    820            
    821            switch(pin)
   \   0000B8   E9           MOV     A,R1
   \   0000B9   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for OpenP1Interrupt>_0`:
   \   0000BC   00           DB        0
   \   0000BD   07           DB        7
   \   0000BE   ....         DW        ??OpenP1Interrupt_8
   \   0000C0   ....         DW        ??OpenP1Interrupt_9
   \   0000C2   ....         DW        ??OpenP1Interrupt_10
   \   0000C4   ....         DW        ??OpenP1Interrupt_11
   \   0000C6   ....         DW        ??OpenP1Interrupt_12
   \   0000C8   ....         DW        ??OpenP1Interrupt_13
   \   0000CA   ....         DW        ??OpenP1Interrupt_14
   \   0000CC   ....         DW        ??OpenP1Interrupt_15
   \   0000CE   ....         DW        ??OpenP1Interrupt_16
    822            {
    823              case PIN_0:
    824                P1_ISR_fun[pin] = P1_0_ISR_fun;
   \                     ??OpenP1Interrupt_9:
   \   0000D0   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000D3   74..         MOV     A,#(??P1_0_ISR_fun?relay & 0xff)
   \   0000D5   F0           MOVX    @DPTR,A
   \   0000D6   A3           INC     DPTR
   \   0000D7   74..         MOV     A,#((??P1_0_ISR_fun?relay >> 8) & 0xff)
   \   0000D9   804B         SJMP    ??OpenP1Interrupt_17
    825                break;
    826              case PIN_1:
    827                P1_ISR_fun[pin] = P1_1_ISR_fun;
   \                     ??OpenP1Interrupt_10:
   \   0000DB   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000DE   74..         MOV     A,#(??P1_1_ISR_fun?relay & 0xff)
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   74..         MOV     A,#((??P1_1_ISR_fun?relay >> 8) & 0xff)
   \   0000E4   8040         SJMP    ??OpenP1Interrupt_17
    828                break;
    829              case PIN_2:
    830                P1_ISR_fun[pin] = P1_2_ISR_fun;
   \                     ??OpenP1Interrupt_11:
   \   0000E6   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000E9   74..         MOV     A,#(??P1_2_ISR_fun?relay & 0xff)
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   74..         MOV     A,#((??P1_2_ISR_fun?relay >> 8) & 0xff)
   \   0000EF   8035         SJMP    ??OpenP1Interrupt_17
    831                break;
    832              case PIN_3:
    833                P1_ISR_fun[pin] = P1_3_ISR_fun;
   \                     ??OpenP1Interrupt_12:
   \   0000F1   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000F4   74..         MOV     A,#(??P1_3_ISR_fun?relay & 0xff)
   \   0000F6   F0           MOVX    @DPTR,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   74..         MOV     A,#((??P1_3_ISR_fun?relay >> 8) & 0xff)
   \   0000FA   802A         SJMP    ??OpenP1Interrupt_17
    834                break;
    835              case PIN_4:
    836                P1_ISR_fun[pin] = P1_4_ISR_fun;
   \                     ??OpenP1Interrupt_13:
   \   0000FC   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000FF   74..         MOV     A,#(??P1_4_ISR_fun?relay & 0xff)
   \   000101   F0           MOVX    @DPTR,A
   \   000102   A3           INC     DPTR
   \   000103   74..         MOV     A,#((??P1_4_ISR_fun?relay >> 8) & 0xff)
   \   000105   801F         SJMP    ??OpenP1Interrupt_17
    837                break;
    838              case PIN_5:
    839                P1_ISR_fun[pin] = P1_5_ISR_fun;
   \                     ??OpenP1Interrupt_14:
   \   000107   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00010A   74..         MOV     A,#(??P1_5_ISR_fun?relay & 0xff)
   \   00010C   F0           MOVX    @DPTR,A
   \   00010D   A3           INC     DPTR
   \   00010E   74..         MOV     A,#((??P1_5_ISR_fun?relay >> 8) & 0xff)
   \   000110   8014         SJMP    ??OpenP1Interrupt_17
    840                break;
    841              case PIN_6:
    842                P1_ISR_fun[pin] = P1_6_ISR_fun;
   \                     ??OpenP1Interrupt_15:
   \   000112   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000115   74..         MOV     A,#(??P1_6_ISR_fun?relay & 0xff)
   \   000117   F0           MOVX    @DPTR,A
   \   000118   A3           INC     DPTR
   \   000119   74..         MOV     A,#((??P1_6_ISR_fun?relay >> 8) & 0xff)
   \   00011B   8009         SJMP    ??OpenP1Interrupt_17
    843                break;
    844              case PIN_7:
    845                P1_ISR_fun[pin] = P1_7_ISR_fun;
   \                     ??OpenP1Interrupt_16:
   \   00011D   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000120   74..         MOV     A,#(??P1_7_ISR_fun?relay & 0xff)
   \   000122   F0           MOVX    @DPTR,A
   \   000123   A3           INC     DPTR
   \   000124   74..         MOV     A,#((??P1_7_ISR_fun?relay >> 8) & 0xff)
   \                     ??OpenP1Interrupt_17:
   \   000126   F0           MOVX    @DPTR,A
    846                break;
    847            }
    848          }
   \                     ??OpenP1Interrupt_8:
   \   000127                REQUIRE ?Subroutine8
   \   000127                REQUIRE P1IFG
   \   000127                REQUIRE PICTL
   \   000127                REQUIRE P1SEL
   \   000127                REQUIRE P1INP
   \   000127                REQUIRE P2INP
   \   000127                REQUIRE P1DIR
   \   000127                ; // Fall through to label ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E9           MOV     A,R1
   \   000001   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   24..         ADD     A,#(P1_ISR_fun & 0xff)
   \   000009   F582         MOV     DPL,A
   \   00000B   E9           MOV     A,R1
   \   00000C   34..         ADDC    A,#((P1_ISR_fun >> 8) & 0xff)
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET
    849          
    850          /**************************************************************************************************
    851           * @fn      CloseP1Interrupt
    852           *
    853           * @brief   
    854           *
    855           * @param
    856           *
    857           * @return
    858           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    859          void CloseP1Interrupt(uint8 pin)
   \                     CloseP1Interrupt:
    860          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    861            P1_ISR_fun[pin]=0;
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?Subroutine0 & 0xFFFF
    862          }
   \                     ??CrossCallReturnLabel_0:
   \   000008   02....       LJMP    ?Subroutine6 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET
    863          
    864          /**************************************************************************************************
    865           * @fn      StartP1Interrupt
    866           *
    867           * @brief   
    868           *
    869           * @param
    870           *
    871           * @return
    872           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          void StartP1Interrupt(uint8 pin)
   \                     StartP1Interrupt:
    874          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    875            EA = 1;
   \   000004   D2AF         SETB    0xa8.7
    876            IEN2 |= (0x10);
   \   000006   439A10       ORL     0x9a,#0x10
    877            P1IEN |= (1<<pin);
   \   000009   75..01       MOV     ?V0 + 0,#0x1
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   \   00000F   E9           MOV     A,R1
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?S_SHL
   \   000015   E5..         MOV     A,?V0 + 0
   \   000017   458D         ORL     A,0x8d
   \   000019                REQUIRE ?Subroutine5
   \   000019                REQUIRE P1IEN
   \   000019                REQUIRE IEN2
   \   000019                REQUIRE _A_IEN0
   \   000019                ; // Fall through to label ?Subroutine5
    878          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F58D         MOV     0x8d,A
   \   000002   D0..         POP     ?V0 + 1
   \   000004   D0..         POP     ?V0 + 0
   \   000006   02....       LJMP    ?BRET
    879          
    880          /**************************************************************************************************
    881           * @fn      StopP1Interrupt
    882           *
    883           * @brief   
    884           *
    885           * @param
    886           *
    887           * @return
    888           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    889          void StopP1Interrupt(uint8 pin)
   \                     StopP1Interrupt:
    890          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    891            P1IEN &= ~(1<<pin);  
   \   000004   75..01       MOV     ?V0 + 0,#0x1
   \   000007   75..00       MOV     ?V0 + 1,#0x0
   \   00000A   E9           MOV     A,R1
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?S_SHL
   \   000010   E5..         MOV     A,?V0 + 0
   \   000012   F4           CPL     A
   \   000013   558D         ANL     A,0x8d
   \   000015   80..         SJMP    ?Subroutine5
   \   000017                REQUIRE P1IEN
    892          }
    893          
    894          /**************************************************************************************************
    895           * @fn      RegisterP1Interrupt
    896           *
    897           * @brief   
    898           *
    899           * @param
    900           *
    901           * @return
    902           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    903          void RegisterP1Interrupt(uint8 pin, uint8 TaskID)
   \                     RegisterP1Interrupt:
    904          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    905              P1InterruptTaskID[pin]=TaskID;
   \   000005   E9           MOV     A,R1
   \   000006   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000009   EA           MOV     A,R2
   \   00000A   F0           MOVX    @DPTR,A
    906          }
   \   00000B   80..         SJMP    ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   24..         ADD     A,#(P1InterruptTaskID & 0xff)
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   34..         ADDC    A,#((P1InterruptTaskID >> 8) & 0xff)
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET
    907          
    908          /**************************************************************************************************
    909           * @fn      QueryP1Interrupt
    910           *
    911           * @brief   
    912           *
    913           * @param
    914           *
    915           * @return
    916           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    917          uint8 QueryP1Interrupt(uint8 pin)
   \                     QueryP1Interrupt:
    918          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    919            switch(pin)
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for QueryP1Interrupt>_0`:
   \   000008   02           DB        2
   \   000009   00           DB        0
   \   00000A   ....         DW        ??QueryP1Interrupt_0
   \   00000C   ....         DW        ??QueryP1Interrupt_1
    920            {
    921              case PIN_0:
    922          
    923                break;
    924              case PIN_1:
    925          
    926                break;
    927              case PIN_2:
    928                sensor_rain.ReadState=1;
   \                     ??QueryP1Interrupt_1:
   \   00000E   7401         MOV     A,#0x1
   \   000010   90....       MOV     DPTR,#(sensor_rain + 3)
   \   000013   F0           MOVX    @DPTR,A
    929                return sensor_rain.count;
   \   000014   90....       MOV     DPTR,#(sensor_rain + 2)
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   8002         SJMP    ??QueryP1Interrupt_2
    930          //      break;
    931              case PIN_3:
    932                break;
    933              case PIN_4:
    934          
    935                break;
    936              case PIN_5:
    937          
    938                break;
    939              case PIN_6:
    940          
    941                break;
    942              case PIN_7:
    943          
    944                break;
    945            }
    946            return 0xFF;
   \                     ??QueryP1Interrupt_0:
   \   00001B   79FF         MOV     R1,#-0x1
   \                     ??QueryP1Interrupt_2:
   \   00001D   80..         SJMP    ?Subroutine6
    947          }
    948          
    949          /**************************************************************************************************
    950           * @fn      HalP1InterruptConfigBefore
    951           *
    952           * @brief   
    953           *
    954           * @param
    955           *
    956           * @return
    957           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    958          void HalP1InterruptConfigBefore( void )
   \                     HalP1InterruptConfigBefore:
    959          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    960            EA=1;
   \   000004   D2AF         SETB    0xa8.7
    961            uint8 pin;
    962            for(pin=0;pin<8;pin++)
   \   000006   7C00         MOV     R4,#0x0
    963            {
    964              P1_ISR_fun[pin]=0;
   \                     ??HalP1InterruptConfigBefore_0:
   \   000008   8C82         MOV     DPL,R4
   \   00000A   AA82         MOV     R2,DPL
   \   00000C   EA           MOV     A,R2
   \   00000D   12....       LCALL   ?Subroutine0 & 0xFFFF
    965              P1InterruptTaskID[pin]=0xFF;  //0xFF is not register
   \                     ??CrossCallReturnLabel_1:
   \   000010   EA           MOV     A,R2
   \   000011   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000014   74FF         MOV     A,#-0x1
   \   000016   F0           MOVX    @DPTR,A
    966            }
   \   000017   0C           INC     R4
   \   000018   EC           MOV     A,R4
   \   000019   C3           CLR     C
   \   00001A   9408         SUBB    A,#0x8
   \   00001C   40EA         JC      ??HalP1InterruptConfigBefore_0
    967            EA=0;  
   \   00001E   C2AF         CLR     0xa8.7
    968          }
   \   000020                REQUIRE ?Subroutine6
   \   000020                REQUIRE _A_IEN0
   \   000020                ; // Fall through to label ?Subroutine6
    969          /**************************************************************************************************
    970           * @fn      HalP1InterruptConfigAfter
    971           *
    972           * @brief   
    973           *
    974           * @param
    975           *
    976           * @return
    977           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    978          void HalP1InterruptConfigAfter( void )
   \                     HalP1InterruptConfigAfter:
    979          {  
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    980            //add here
    981            P2SEL &= ~(0x01);  //LED general-- test purpose
   \   000004   53F5FE       ANL     0xf5,#0xfe
    982            P2DIR |= (0x01);   //LED output-- test purpose
   \   000007   43FF01       ORL     0xff,#0x1
    983            P2_0=1;            //LED brig.hten-- test purpose
   \   00000A   D2A0         SETB    0xa0.0
    984            //p1.2 -- general -- input -- pullup -- FallEdge
    985            OpenP1Interrupt(PIN_2, FUN_SELECT_GENERAL, DIRECTION_INPUT, INPUT_MODE_PULLUP, FALL_EDGE);
   \   00000C                ; Setup parameters for call to function OpenP1Interrupt
   \   00000C   7D01         MOV     R5,#0x1
   \   00000E   7C00         MOV     R4,#0x0
   \   000010   7B00         MOV     R3,#0x0
   \   000012   7A00         MOV     R2,#0x0
   \   000014   7902         MOV     R1,#0x2
   \   000016   12....       LCALL   ??OpenP1Interrupt?relay
    986            StartP1Interrupt(PIN_2);
   \   000019                ; Setup parameters for call to function StartP1Interrupt
   \   000019   7902         MOV     R1,#0x2
   \   00001B   12....       LCALL   ??StartP1Interrupt?relay
    987          }
   \   00001E   80..         SJMP    ?Subroutine6
   \   000020                REQUIRE _A_P2
   \   000020                REQUIRE P2SEL
   \   000020                REQUIRE P2DIR
    988          
    989          /**************************************************************************************************
    990           * @fn      halP1Isr
    991           *
    992           * @brief   
    993           *
    994           * @param
    995           *
    996           * @return
    997           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    998          HAL_ISR_FUNCTION( halP1Isr, P1INT_VECTOR )
   \                     halP1Isr:
    999          {
   \   000000   C0E0         PUSH    A
   \   000002   74F1         MOV     A,#-0xf
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 16
   \   000007                ; Auto size: 0
   1000            uint8 pin;  
   1001            for(pin=0;pin<8;pin++)
   \   000007   7E00         MOV     R6,#0x0
   1002            {
   1003              if((P1IFG & (1<<pin)) && P1_ISR_fun[pin])
   \                     ??halP1Isr_0:
   \   000009   75..01       MOV     ?V0 + 0,#0x1
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   \   00000F   EE           MOV     A,R6
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?S_SHL
   \   000015   E5..         MOV     A,?V0 + 0
   \   000017   558A         ANL     A,0x8a
   \   000019   6039         JZ      ??halP1Isr_1
   \   00001B   EE           MOV     A,R6
   \   00001C   C3           CLR     C
   \   00001D   33           RLC     A
   \   00001E   F8           MOV     R0,A
   \   00001F   E4           CLR     A
   \   000020   33           RLC     A
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_14:
   \   000026   7002         JNZ     ??halP1Isr_2
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \                     ??halP1Isr_2:
   \   00002A   6028         JZ      ??halP1Isr_1
   1004              {
   1005                P2_0=!P2_0;           //LED -- test purpose      
   \   00002C   A2A0         MOV     C,0xa0.0
   \   00002E   B3           CPL     C
   \   00002F   92A0         MOV     0xa0.0,C
   1006                P1IFG &= ~(1<<pin);   //clean
   \   000031   75..01       MOV     ?V0 + 0,#0x1
   \   000034   75..00       MOV     ?V0 + 1,#0x0
   \   000037   EE           MOV     A,R6
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?S_SHL
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   F4           CPL     A
   \   000040   558A         ANL     A,0x8a
   \   000042   F58A         MOV     0x8a,A
   1007                (P1_ISR_fun[pin])();
   \   000044                ; Setup parameters for indirect call
   \   000044   EE           MOV     A,R6
   \   000045   C3           CLR     C
   \   000046   33           RLC     A
   \   000047   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_15:
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F583         MOV     DPH,A
   \   00004F   8882         MOV     DPL,R0
   \   000051   12....       LCALL   ?CALL_IND
   1008              }
   1009            }
   \                     ??halP1Isr_1:
   \   000054   0E           INC     R6
   \   000055   EE           MOV     A,R6
   \   000056   C3           CLR     C
   \   000057   9408         SUBB    A,#0x8
   \   000059   40AE         JC      ??halP1Isr_0
   1010            P1IF=0;
   \   00005B   C2EB         CLR     0xe8.3
   1011          }
   \   00005D   7F02         MOV     R7,#0x2
   \   00005F   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000062                REQUIRE P1IFG
   \   000062                REQUIRE _A_P2
   \   000062                REQUIRE _A_IRCON2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   24..         ADD     A,#(P1_ISR_fun & 0xff)
   \   000002   F582         MOV     DPL,A
   \   000004   E9           MOV     A,R1
   \   000005   34..         ADDC    A,#((P1_ISR_fun >> 8) & 0xff)
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
   1012          
   1013          /**************************************************************************************************
   1014           * @fn      P1_0_ISR_fun
   1015           *
   1016           * @brief   
   1017           *
   1018           * @param
   1019           *
   1020           * @return
   1021           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1022          void P1_0_ISR_fun()
   \                     P1_0_ISR_fun:
   1023          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1024            
   1025          }
   \   000000   02....       LJMP    ?BRET
   1026          
   1027          /**************************************************************************************************
   1028           * @fn      P1_1_ISR_fun
   1029           *
   1030           * @brief   
   1031           *
   1032           * @param
   1033           *
   1034           * @return
   1035           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1036          void P1_1_ISR_fun()
   \                     P1_1_ISR_fun:
   1037          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1038            
   1039          }
   \   000000   02....       LJMP    ?BRET
   1040          
   1041          /**************************************************************************************************
   1042           * @fn      P1_2_ISR_fun
   1043           *
   1044           * @brief   
   1045           *
   1046           * @param
   1047           *
   1048           * @return
   1049           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1050          void P1_2_ISR_fun()
   \                     P1_2_ISR_fun:
   1051          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1052            sensor_rain.count++;
   \   000005   90....       MOV     DPTR,#(sensor_rain + 2)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   04           INC     A
   \   00000A   F0           MOVX    @DPTR,A
   1053            sensor_rain.ReadState=0;
   \   00000B   E4           CLR     A
   \   00000C   90....       MOV     DPTR,#(sensor_rain + 3)
   \   00000F   F0           MOVX    @DPTR,A
   1054            if(P1InterruptTaskID[2]!=0xFF)
   \   000010   90....       MOV     DPTR,#(P1InterruptTaskID + 2)
   \   000013   E0           MOVX    A,@DPTR
   \   000014   64FF         XRL     A,#0xff
   \   000016   602D         JZ      ??P1_2_ISR_fun_0
   1055            {
   1056              rain_t *msgPtr;
   1057              msgPtr = (rain_t *)osal_msg_allocate( sizeof(rain_t) );
   \   000018                ; Setup parameters for call to function osal_msg_allocate
   \   000018   7A04         MOV     R2,#0x4
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   12....       LCALL   ??osal_msg_allocate?relay
   1058              if ( msgPtr )
   \   00001F   EA           MOV     A,R2
   \   000020   7001         JNZ     ??P1_2_ISR_fun_1
   \   000022   EB           MOV     A,R3
   \                     ??P1_2_ISR_fun_1:
   \   000023   6020         JZ      ??P1_2_ISR_fun_0
   1059              {
   1060                msgPtr->hdr.event = P1_2_INTERRUPT;
   \   000025   74C3         MOV     A,#-0x3d
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   F0           MOVX    @DPTR,A
   1061                msgPtr->count = sensor_rain.count;
   \   00002C   90....       MOV     DPTR,#(sensor_rain + 2)
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   8A82         MOV     DPL,R2
   \   000032   8B83         MOV     DPH,R3
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
   1062                osal_msg_send(P1InterruptTaskID[2], (uint8 *)msgPtr);         
   \   000037                ; Setup parameters for call to function osal_msg_send
   \   000037   90....       MOV     DPTR,#(P1InterruptTaskID + 2)
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   12....       LCALL   ??osal_msg_send?relay
   1063                sensor_rain.ReadState=1;
   \   00003F   7401         MOV     A,#0x1
   \   000041   90....       MOV     DPTR,#(sensor_rain + 3)
   \   000044   F0           MOVX    @DPTR,A
   1064              }
   1065            }
   1066          }
   \                     ??P1_2_ISR_fun_0:
   \   000045   02....       LJMP    ?Subroutine8 & 0xFFFF
   1067          
   1068          /**************************************************************************************************
   1069           * @fn      P1_3_ISR_fun
   1070           *
   1071           * @brief   
   1072           *
   1073           * @param
   1074           *
   1075           * @return
   1076           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1077          void P1_3_ISR_fun()
   \                     P1_3_ISR_fun:
   1078          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1079          }
   \   000000   02....       LJMP    ?BRET
   1080          
   1081          /**************************************************************************************************
   1082           * @fn      P1_4_ISR_fun
   1083           *
   1084           * @brief   
   1085           *
   1086           * @param
   1087           *
   1088           * @return
   1089           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1090          void P1_4_ISR_fun()
   \                     P1_4_ISR_fun:
   1091          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1092          }
   \   000000   02....       LJMP    ?BRET
   1093          
   1094          /**************************************************************************************************
   1095           * @fn      P1_5_ISR_fun
   1096           *
   1097           * @brief   
   1098           *
   1099           * @param
   1100           *
   1101           * @return
   1102           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1103          void P1_5_ISR_fun()
   \                     P1_5_ISR_fun:
   1104          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1105          }
   \   000000   02....       LJMP    ?BRET
   1106          
   1107          /**************************************************************************************************
   1108           * @fn      P1_6_ISR_fun
   1109           *
   1110           * @brief   
   1111           *
   1112           * @param
   1113           *
   1114           * @return
   1115           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1116          void P1_6_ISR_fun()
   \                     P1_6_ISR_fun:
   1117          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1118          }
   \   000000   02....       LJMP    ?BRET
   1119          
   1120          /**************************************************************************************************
   1121           * @fn      P1_7_ISR_fun
   1122           *
   1123           * @brief   
   1124           *
   1125           * @param
   1126           *
   1127           * @return
   1128           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1129          void P1_7_ISR_fun()
   \                     P1_7_ISR_fun:
   1130          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1131          }
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment INTVEC, offset 0x7b, root
   \                     `??halP1Isr??INTVEC 123`:
   \   00007B   02....       LJMP       (halP1Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OpenP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OpenP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??CloseP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    CloseP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??StartP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    StartP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??StopP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    StopP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??RegisterP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RegisterP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??QueryP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    QueryP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalP1InterruptConfigBefore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalP1InterruptConfigBefore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalP1InterruptConfigAfter?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalP1InterruptConfigAfter

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_0_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_0_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_1_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_1_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_2_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_2_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_3_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_3_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_4_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_4_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_5_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_5_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_6_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_6_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_7_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_7_ISR_fun
   1132          

   Maximum stack usage in bytes:

     Function                   ISTACK PSTACK XSTACK
     --------                   ------ ------ ------
     CloseP1Interrupt               2      0      0
     HalKeyConfig                   0      0      0
     HalKeyEnterSleep               0      0      0
     HalKeyExitSleep                0      0      0
     HalKeyInit                     0      0      0
     HalKeyPoll                     0      0      0
     HalKeyRead                     0      0      0
     HalP1InterruptConfigAfter      2      0      0
       -> OpenP1Interrupt           4      0      0
       -> StartP1Interrupt          4      0      0
     HalP1InterruptConfigBefore     3      0      0
     OpenP1Interrupt                0      0     10
     P1_0_ISR_fun                   0      0      0
     P1_1_ISR_fun                   0      0      0
     P1_2_ISR_fun                   1      0     10
       -> osal_msg_allocate         0      0     20
       -> osal_msg_send             0      0     20
     P1_3_ISR_fun                   0      0      0
     P1_4_ISR_fun                   0      0      0
     P1_5_ISR_fun                   0      0      0
     P1_6_ISR_fun                   0      0      0
     P1_7_ISR_fun                   0      0      0
     QueryP1Interrupt               2      0      0
     RegisterP1Interrupt            1      0     10
     StartP1Interrupt               2      0      0
     StopP1Interrupt                2      0      0
     halP1Isr                      16      0      0
     halProcessKeyInterrupt         0      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     P1IFG                             1
     PICTL                             1
     P1IEN                             1
     P0INP                             1
     IEN2                              1
     _A_P2                             1
     _A_IEN0                           1
     _A_IRCON2                         1
     P1SEL                             1
     P2SEL                             1
     P1INP                             1
     P2INP                             1
     P1DIR                             1
     P2DIR                             1
     Hal_KeyIntEnable                  1
     halSaveIntKey                     1
     HalKeyInit                        3
     HalKeyConfig                      3
     HalKeyRead                        0
     ?Subroutine7                      5
     HalKeyPoll                        3
     halProcessKeyInterrupt            3
     HalKeyEnterSleep                  6
     HalKeyExitSleep                   5
     P1_ISR_fun                       16
     P1InterruptTaskID                 8
     sensor_rain                       4
     OpenP1Interrupt                 295
     ?Subroutine8                      5
     ?Subroutine1                      5
     ?Subroutine3                     17
     CloseP1Interrupt                 11
     ?Subroutine6                      7
     ?Subroutine0                      8
     StartP1Interrupt                 25
     ?Subroutine5                      9
     StopP1Interrupt                  23
     RegisterP1Interrupt              13
     ?Subroutine2                     10
     QueryP1Interrupt                 31
     HalP1InterruptConfigBefore       32
     HalP1InterruptConfigAfter        32
     halP1Isr                         98
     ?Subroutine4                     11
     P1_0_ISR_fun                      3
     P1_1_ISR_fun                      3
     P1_2_ISR_fun                     72
     P1_3_ISR_fun                      3
     P1_4_ISR_fun                      3
     P1_5_ISR_fun                      3
     P1_6_ISR_fun                      3
     P1_7_ISR_fun                      3
     ??halP1Isr??INTVEC 123            3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6
     ??OpenP1Interrupt?relay           6
     ??CloseP1Interrupt?relay          6
     ??StartP1Interrupt?relay          6
     ??StopP1Interrupt?relay           6
     ??RegisterP1Interrupt?relay       6
     ??QueryP1Interrupt?relay          6
     ??HalP1InterruptConfigBefore?relay
                                       6
     ??HalP1InterruptConfigAfter?relay
                                       6
     ??P1_0_ISR_fun?relay              6
     ??P1_1_ISR_fun?relay              6
     ??P1_2_ISR_fun?relay              6
     ??P1_3_ISR_fun?relay              6
     ??P1_4_ISR_fun?relay              6
     ??P1_5_ISR_fun?relay              6
     ??P1_6_ISR_fun?relay              6
     ??P1_7_ISR_fun?relay              6

 
 644 bytes in segment BANKED_CODE
 138 bytes in segment BANK_RELAYS
   3 bytes in segment INTVEC
 109 bytes in segment NEAR_CODE
  14 bytes in segment SFR_AN
  30 bytes in segment XDATA_Z
 
 891 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of DATA  memory (+ 14 bytes shared)
  30 bytes of XDATA memory

Errors: none
Warnings: none
