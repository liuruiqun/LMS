###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    12/Sep/2012  16:16:37 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Documents and Settings\Administrator\桌面\8-22\ #
#                          Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\C #
#                          omponents\hal\target\CC2430EB\hal_key.c            #
#    Command line       =  -f "C:\Documents and Settings\Administrator\桌面\8 #
#                          -22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\1-network               #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wRoute #
#                          r.cfg" (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS "-DCONST=const __code"    #
#                          -DGENERIC=__generic) -f "C:\Documents and          #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfi #
#                          g.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800   #
#                          -DZDAPP_CONFIG_PAN_ID=0x1234                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Documents and           #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Compone #
#                          nts\hal\target\CC2430EB\hal_key.c" -D CC2430EB -D  #
#                          REFLECTOR -D ZTOOL_P1 -D MT_TASK -D MT_ZDO_FUNC    #
#                          -D xLCD_SUPPORTED=DEBUG -lC "C:\Documents and      #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\RouterEB\List\" -lA              #
#                          "C:\Documents and Settings\Administrator\桌面\8-22 #
#                          \Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\1-network                  #
#                          formaton\CC2430DB\RouterEB\List\" --diag_suppress  #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Documents   #
#                          and Settings\Administrator\桌面\8-22\Texas         #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\RouterEB\Obj\" -e                #
#                          --require_prototypes -z9 --no_code_motion --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Documents and Settings\Administrator\桌面\8 #
#                          -22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\1-network               #
#                          formaton\CC2430DB\" -I "C:\Documents and           #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\SOURCE\" -I "C:\Documents     #
#                          and Settings\Administrator\桌面\8-22\Texas         #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I     #
#                          "C:\Documents and Settings\Administrator\桌面\8-22 #
#                          \Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\1-network                  #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MT\"   #
#                          -I "C:\Documents and Settings\Administrator\桌面\8 #
#                          -22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\1-network               #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\IN #
#                          CLUDE\" -I "C:\Documents and                       #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\TA #
#                          RGET\CC2430EB\" -I "C:\Documents and               #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\M #
#                          CU\CCSOC\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\I #
#                          NCLUDE\" -I "C:\Documents and                      #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          AF\" -I "C:\Documents and                          #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          NWK\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SEC\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SYS\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          ZDO\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\F #
#                          8W\" -I "C:\Documents and                          #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\" #
#                           -I "C:\Documents and Settings\Administrator\桌面\ #
#                          8-22\Texas Instruments nongmenshan\ZStack-1.4.3-1. #
#                          2.1\Projects\zstack\Samples\1-network              #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SADDR\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SDATA\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\IN #
#                          CLUDE\" -I "C:\Documents and                       #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\HI #
#                          GH_LEVEL\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\" -I "C:\Documents and               #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\SINGLE_CHIP\" -I "D:\IAR             #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\" -I "D:\IAR Systems\Embedded     #
#                          Workbench 4.0 Evaluation version\8051\INC\CLIB\"   #
#    List file          =  C:\Documents and Settings\Administrator\桌面\8-22\ #
#                          Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\P #
#                          rojects\zstack\Samples\1-network                   #
#                          formaton\CC2430DB\RouterEB\List\hal_key.lst        #
#    Object file        =  C:\Documents and Settings\Administrator\桌面\8-22\ #
#                          Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\P #
#                          rojects\zstack\Samples\1-network                   #
#                          formaton\CC2430DB\RouterEB\Obj\hal_key.r51         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\桌面\8-22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2007-11-07 11:54:17 -0800 (Wed, 07 Nov 2007) $
      4            Revision:       $Revision: 15885 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x8a
   \   unsigned char volatile __sfr P1IFG
   \                     P1IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr P1IEN
   \                     P1IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf6
   \   unsigned char volatile __sfr P1INP
   \                     P1INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_drivers.h"
     87          #include "hal_adc.h"
     88          #include "hal_key.h"
     89          #include "osal.h"
     90          
     91          /**************************************************************************************************
     92           *                                              MACROS
     93           **************************************************************************************************/
     94          
     95          /**************************************************************************************************
     96           *                                            CONSTANTS
     97           **************************************************************************************************/
     98          #define HAL_KEY_BIT0   0x01
     99          #define HAL_KEY_BIT1   0x02
    100          #define HAL_KEY_BIT2   0x04
    101          #define HAL_KEY_BIT3   0x08
    102          #define HAL_KEY_BIT4   0x10
    103          #define HAL_KEY_BIT5   0x20
    104          #define HAL_KEY_BIT6   0x40
    105          #define HAL_KEY_BIT7   0x80
    106          
    107          #define HAL_KEY_RISING_EDGE   0
    108          #define HAL_KEY_FALLING_EDGE  1
    109          
    110          #define HAL_KEY_PDUP2           0x80
    111          #define HAL_KEY_PDUP1           0x40
    112          #define HAL_KEY_PDUP0           0x20
    113          
    114          #define HAL_KEY_DEBOUNCE_VALUE  25
    115          #define HAL_KEY_POLLING_VALUE   100
    116          
    117          
    118          #if defined (HAL_BOARD_CC2430DB)
    119            #define HAL_KEY_SW_6_ENABLE
    120            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    121            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    122            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    123            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    124            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    125            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    126            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    127            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    128            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    129            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    130            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    131          
    132            #define HAL_KEY_JOYSTICK_ENABLE
    133            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    134          
    135            #define HAL_KEY_SW_5_ENABLE   /* 2430DB - SW5 is enabled based on key interrupt enable or not - see config */
    136            #define HAL_KEY_SW_5_PORT     P2                      /* Port location of SW5 */
    137            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT0            /* Bit location of SW5 */
    138            #define HAL_KEY_SW_5_SEL      P2SEL                   /* Port Select Register for SW5 */
    139            #define HAL_KEY_SW_5_DIR      P2DIR                   /* Port Direction Register for SW5 */
    140            #define HAL_KEY_SW_5_INP      P2INP                   /* Port Input Mode Register for SW5 */
    141            #define HAL_KEY_SW_5_IEN      IEN2                    /* Interrupt Enable Register for SW5 */
    142            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT1            /* Interrupt Enable bit for SW5 */
    143            #define HAL_KEY_SW_5_EDGE     HAL_KEY_FALLING_EDGE    /* Type of interrupt for SW5 */
    144            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    145            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    146            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT5            /* Interrupt enable bit for SW5 */
    147            #define HAL_KEY_SW_5_PXIFG    P2IFG                   /* Port Interrupt Flag for SW5 */
    148          
    149            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    150            #define HAL_KEY_POINT_HIGH_USED   0                   /* P0 can only be enabled/disabled as group of high or low nibble */
    151          #endif
    152          
    153          #if defined (HAL_BOARD_CC2430EB) || defined (HAL_BOARD_CC2430BB)
    154            #define HAL_KEY_SW_6_ENABLE
    155            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    156            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    157            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    158            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    159            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    160            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    161            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    162            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    163            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    164            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    165            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    166          
    167            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    168          #endif
    169          
    170          #if defined (HAL_BOARD_CC2430BB)
    171            #define HAL_KEY_POINT_HIGH_USED  0
    172          #endif
    173          
    174          #if defined (HAL_BOARD_CC2430EB)
    175            #define HAL_KEY_JOYSTICK_ENABLE
    176            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    177          
    178            #define HAL_KEY_SW_5_ENABLE
    179            #define HAL_KEY_SW_5_PORT     P0                      /* Port location of SW5 */
    180            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT5            /* Bit location of SW5 */
    181            #define HAL_KEY_SW_5_SEL      P0SEL                   /* Port Select Register for SW5 */
    182            #define HAL_KEY_SW_5_DIR      P0DIR                   /* Port Direction Register for SW5 */
    183            #define HAL_KEY_SW_5_INP      P0INP                   /* Port Input Mode Register for SW5 */
    184            #define HAL_KEY_SW_5_IEN      IEN1                    /* Interrupt Enable Register for SW5 */
    185            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW5 */
    186            #define HAL_KEY_SW_5_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW5 */
    187            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    188            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    189            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT4            /* Interrupt enable bit for SW5 */
    190            #define HAL_KEY_SW_5_PXIFG    P0IFG                   /* Port Interrupt Flag for SW5 */
    191          
    192            #define HAL_KEY_POINT_HIGH_USED   HAL_KEY_SW_5_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    193          #endif
    194          
    195          /**************************************************************************************************
    196           *                                            TYPEDEFS
    197           **************************************************************************************************/
    198          
    199          
    200          /**************************************************************************************************
    201           *                                        GLOBAL VARIABLES
    202           **************************************************************************************************/
    203          //static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
    204          //static halKeyCBack_t pHalKeyProcessFunction;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    205          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          uint8 halSaveIntKey;              /* used by ISR to save state of interrupt-driven keys */
   \                     halSaveIntKey:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          
    208          //static uint8 HalKeyConfigured;
    209          
    210          /**************************************************************************************************
    211           *                                        FUNCTIONS - Local
    212           **************************************************************************************************/
    213          void halProcessKeyInterrupt (void);
    214          
    215          
    216          /**************************************************************************************************
    217           *                                        FUNCTIONS - API
    218           **************************************************************************************************/
    219          /**************************************************************************************************
    220           * @fn      HalKeyInit
    221           *
    222           * @brief   Initilize Key Service
    223           *
    224           * @param   none
    225           *
    226           * @return  None
    227           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    228          void HalKeyInit( void )
   \                     HalKeyInit:
    229          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    230          #if (HAL_KEY == TRUE)
    231            /* Initialize previous key to 0 */
    232            halKeySavedKeys = 0;
    233          
    234          #if defined (HAL_KEY_SW_6_ENABLE)
    235            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
    236            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
    237          #endif
    238          
    239          #if defined (HAL_KEY_SW_5_ENABLE)
    240            HAL_KEY_SW_5_SEL &= ~(HAL_KEY_SW_5_BIT);    /* Set pin function to GPIO */
    241            HAL_KEY_SW_5_DIR &= ~(HAL_KEY_SW_5_BIT);    /* Set pin direction to Input */
    242            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
    243          #endif
    244          
    245            /* Initialize callback function */
    246            pHalKeyProcessFunction  = NULL;
    247          
    248            /* Start with key is not configured */
    249            HalKeyConfigured = FALSE;
    250          #endif /* HAL_KEY */
    251          }
   \   000000   02....       LJMP    ?BRET
    252          
    253          /**************************************************************************************************
    254           * @fn      HalKeyConfig
    255           *
    256           * @brief   Configure the Key serivce
    257           *
    258           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    259           *          cback - pointer to the CallBack function
    260           *
    261           * @return  None
    262           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    263          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    264          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    265          #if (HAL_KEY == TRUE)
    266            /* Enable/Disable Interrupt or */
    267            Hal_KeyIntEnable = interruptEnable;
    268          
    269            /* Register the callback fucntion */
    270            pHalKeyProcessFunction = cback;
    271          
    272            /* Determine if interrupt is enable or not */
    273            if (Hal_KeyIntEnable)
    274            {
    275          
    276              /*
    277                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    278                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    279                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    280                 will stop this problem.
    281              */
    282              #if defined (HAL_BOARD_CC2430DB)
    283                #undef HAL_KEY_SW_5_ENABLE                      /* Dis-allow SW5 when key interrupt is enable */
    284              #endif
    285          
    286          #if defined (HAL_KEY_SW_5_ENABLE)
    287              PICTL &= ~(HAL_KEY_SW_5_EDGEBIT);                 /* Set rising or falling edge */
    288            #if (HAL_KEY_SW_5_EDGE == HAL_KEY_FALLING_EDGE)
    289              PICTL |= HAL_KEY_SW_5_EDGEBIT;
    290            #endif
    291              HAL_KEY_SW_5_ICTL |= HAL_KEY_SW_5_ICTLBIT;        /* Set interrupt enable bit */
    292              HAL_KEY_SW_5_IEN |= HAL_KEY_SW_5_IENBIT;
    293              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);        /* Clear any pending interrupts */
    294          #endif
    295          
    296          #if defined (HAL_KEY_SW_6_ENABLE)
    297              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);                 /* Set rising or falling edge */
    298            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    299              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    300            #endif
    301              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;        /* Set interrupt enable bit */
    302              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
    303              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);        /* Clear any pending interrupts */
    304          #endif
    305          
    306              /* Do this only after the hal_key is configured - to work with sleep stuff */
    307              if (HalKeyConfigured == TRUE)
    308              {
    309                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
    310              }
    311            }
    312            else    /* Interrupts NOT enabled */
    313            {
    314          
    315              /*
    316                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    317                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    318                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    319                 will stop this problem.
    320              */
    321              #if defined (HAL_BOARD_CC2430DB)
    322                #define HAL_KEY_SW_5_ENABLE                     /* Allow SW5 only when key interrupt is disable */
    323              #endif
    324          
    325          #if defined (HAL_KEY_SW_6_ENABLE)
    326              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT);     /* Clear interrupt enable bit */
    327              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);
    328          #endif
    329          
    330          #if defined (HAL_KEY_SW_5_ENABLE)
    331              HAL_KEY_SW_5_ICTL &= ~(HAL_KEY_SW_5_ICTLBIT);     /* Clear interrupt enable bit */
    332              HAL_KEY_SW_5_IEN &= ~(HAL_KEY_SW_5_IENBIT);
    333          #endif
    334              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
    335            }
    336          
    337            /* Key now is configured */
    338            HalKeyConfigured = TRUE;
    339          #endif /* HAL_KEY */
    340          }
   \   000000   02....       LJMP    ?BRET
    341          
    342          /**************************************************************************************************
    343           * @fn      HalKeyRead
    344           *
    345           * @brief   Read the current value of a key
    346           *
    347           * @param   None
    348           *
    349           * @return  keys - current keys status
    350           **************************************************************************************************/
    351          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    353          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    354          
    355            uint8 keys = 0;
    356          
    357          #if (HAL_KEY == TRUE)
    358          
    359          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    360            uint8 ksave0 = 0;
    361            uint8 ksave1;
    362            uint8 adc;
    363          #endif
    364          
    365          #if defined (HAL_KEY_SW_6_ENABLE)
    366            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
    367            {
    368              keys |= HAL_KEY_SW_6;
    369            }
    370          #endif
    371          #if defined (HAL_KEY_SW_5_ENABLE)
    372            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
    373            {
    374              keys |= HAL_KEY_SW_5;
    375            }
    376          #endif
    377          
    378          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    379          /*
    380          *  The joystick control is encoded as an analog voltage.  Keep on reading
    381          *  the ADC until two consecutive key decisions are the same.
    382          */
    383          
    384            do
    385            {
    386              ksave1 = ksave0;    /* save previouse key reading */
    387          
    388              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
    389          
    390              if  (CHVER == 0x01)
    391              {
    392                /* Rev B */
    393                if ((adc >= 90) && (adc <= 100))
    394                {
    395                   ksave0 |= HAL_KEY_UP;
    396                }
    397                else if ((adc >= 75) && (adc <= 85))
    398                {
    399                  ksave0 |= HAL_KEY_RIGHT;
    400                }
    401                else if ((adc >= 45) && (adc <= 55))
    402                {
    403                  ksave0 |= HAL_KEY_LEFT;
    404                }
    405                else if (adc <= 10)
    406                {
    407                  ksave0 |= HAL_KEY_DOWN;
    408                }
    409                else if ((adc >= 101) && (adc <= 115))
    410                {
    411                }
    412              }
    413              else
    414              {
    415                 /* Rev C */
    416                if ((adc >= 90)  && (adc <= 104))
    417                {
    418                   ksave0 |= HAL_KEY_UP;
    419                }
    420                else if ((adc >= 75)  && (adc <= 89))
    421                {
    422                  ksave0 |= HAL_KEY_RIGHT;
    423                }
    424                else if ((adc >= 45)  && (adc <= 56))
    425                {
    426                  ksave0 |= HAL_KEY_LEFT;
    427                }
    428                else if (adc <= 10)
    429                {
    430                  ksave0 |= HAL_KEY_DOWN;
    431                }
    432                else if ((adc >= 105) && (adc <= 121))
    433                {
    434                }
    435              }
    436          
    437            } while (ksave0 != ksave1);
    438          
    439            keys |= ksave0;
    440          
    441          #endif
    442          
    443          #endif /* HAL_KEY */
    444          
    445            return keys;
   \   000000                REQUIRE ?Subroutine7
   \   000000                ; // Fall through to label ?Subroutine7

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    446          
    447          }
    448          
    449          
    450          /**************************************************************************************************
    451           * @fn      HalKeyPoll
    452           *
    453           * @brief   Called by hal_driver to poll the keys
    454           *
    455           * @param   None
    456           *
    457           * @return  None
    458           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    459          void HalKeyPoll (void)
   \                     HalKeyPoll:
    460          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    461          #if (HAL_KEY == TRUE)
    462          
    463            uint8 keys = 0;
    464          
    465          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    466            uint8 ksave0 = 0;
    467            uint8 ksave1;
    468            uint8 adc;
    469          #endif
    470          
    471            /*
    472            *  If interrupts are enabled, get the status of the interrupt-driven keys from 'halSaveIntKey'
    473            *  which is updated by the key ISR.  If Polling, read these keys directly.
    474            */
    475          #if defined (HAL_KEY_SW_6_ENABLE)
    476            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
    477            {
    478              keys |= HAL_KEY_SW_6;
    479            }
    480          #endif
    481          #if defined (HAL_KEY_SW_5_ENABLE)
    482            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
    483            {
    484              keys |= HAL_KEY_SW_5;
    485            }
    486          #endif
    487          
    488          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    489          /*
    490          *  The joystick control is encoded as an analog voltage.  Keep on reading
    491          *  the ADC until two consecutive key decisions are the same.
    492          */
    493          
    494            do
    495            {
    496              ksave1 = ksave0;    /* save previouse key reading */
    497          
    498              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
    499          
    500              if  (CHVER == 0x01)
    501              {
    502                /* Rev B */
    503                if ((adc >= 90) && (adc <= 100))
    504                {
    505                   ksave0 |= HAL_KEY_UP;
    506                }
    507                else if ((adc >= 75) && (adc <= 85))
    508                {
    509                  ksave0 |= HAL_KEY_RIGHT;
    510                }
    511                else if ((adc >= 45) && (adc <= 55))
    512                {
    513                  ksave0 |= HAL_KEY_LEFT;
    514                }
    515                else if (adc <= 10)
    516                {
    517                  ksave0 |= HAL_KEY_DOWN;
    518                }
    519                else if ((adc >= 101) && (adc <= 115))
    520                {
    521                }
    522              }
    523              else
    524              {
    525                 /* Rev C */
    526                if ((adc >= 90)  && (adc <= 104))
    527                {
    528                   ksave0 |= HAL_KEY_UP;
    529                }
    530                else if ((adc >= 75)  && (adc <= 89))
    531                {
    532                  ksave0 |= HAL_KEY_RIGHT;
    533                }
    534                else if ((adc >= 45)  && (adc <= 56))
    535                {
    536                  ksave0 |= HAL_KEY_LEFT;
    537                }
    538                else if (adc <= 10)
    539                {
    540                  ksave0 |= HAL_KEY_DOWN;
    541                }
    542                else if ((adc >= 105) && (adc <= 121))
    543                {
    544                }
    545              }
    546          
    547          
    548            } while (ksave0 != ksave1);
    549          
    550            keys |= ksave0;
    551          
    552          #endif
    553          
    554            /* Exit if polling and no keys have changed */
    555            if (!Hal_KeyIntEnable)
    556            {
    557              if (keys == halKeySavedKeys)
    558              {
    559                return;
    560              }
    561              halKeySavedKeys = keys;     /* Store the current keys for comparation next time */
    562            }
    563          
    564            /* Invoke Callback if new keys were depressed */
    565            if (keys && (pHalKeyProcessFunction))
    566            {
    567              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
    568            }
    569          
    570          #endif /* HAL_KEY */
    571          
    572          }
   \   000000   02....       LJMP    ?BRET
    573          
    574          
    575          /**************************************************************************************************
    576           * @fn      halProcessKeyInterrupt
    577           *
    578           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    579           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    580           *
    581           * @param
    582           *
    583           * @return
    584           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    585          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    586          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    587          
    588          #if (HAL_KEY == TRUE)
    589          
    590            bool    valid=FALSE;
    591          
    592          #if defined (HAL_KEY_SW_6_ENABLE)
    593            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)      /* Interrupt Flag has been set */
    594            {
    595              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);    /* Clear Interrupt Flag */
    596              valid = TRUE;
    597            }
    598          #endif
    599          
    600          #if defined (HAL_KEY_SW_5_ENABLE)
    601            if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)      /* Interrupt Flag has been set */
    602            {
    603              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);    /* Clear Interrupt Flag */
    604              valid = TRUE;
    605            }
    606          #endif
    607          
    608            if (valid)
    609            {
    610              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
    611            }
    612          #endif /* HAL_KEY */
    613          }
   \   000000   02....       LJMP    ?BRET
    614          
    615          /**************************************************************************************************
    616           * @fn      HalKeyEnterSleep
    617           *
    618           * @brief  - Get called to enter sleep mode
    619           *
    620           * @param
    621           *
    622           * @return
    623           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    624          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    625          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    626            /* Sleep!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    627             * It was set to tri-state during active state. It needs to be pulled-up.
    628             */
    629          #if defined (HAL_KEY_SW_5_ENABLE)
    630            HAL_KEY_SW_5_INP &= ~HAL_KEY_SW_5_BIT;       /* Set pin input mode to pull-up */
   \   000000   538FDF       ANL     0x8f,#0xdf
    631          #endif
    632          }
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE P0INP
    633          
    634          /**************************************************************************************************
    635           * @fn      HalKeyExitSleep
    636           *
    637           * @brief   - Get called when sleep is over
    638           *
    639           * @param
    640           *
    641           * @return  - return saved keys
    642           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    643          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    644          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    645            /* Wakeup!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    646             * It was pulled up during sleep. It needs to be set to tri-state during active state.
    647             */
    648          #if defined (HAL_KEY_SW_5_ENABLE)
    649            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
   \   000000   438F20       ORL     0x8f,#0x20
    650          #endif
    651          
    652            /* Wake up and read keys */
    653            return ( HalKeyRead () );
   \   000003   80..         SJMP    ?Subroutine7
   \   000005                REQUIRE P0INP
    654          }
    655          
    656          /***************************************************************************************************
    657           *                                    INTERRUPT SERVICE ROUTINE
    658           ***************************************************************************************************/
    659          
    660          /**************************************************************************************************
    661           * @fn      halKeyPort0Isr
    662           *
    663           * @brief   Port0 ISR
    664           *
    665           * @param
    666           *
    667           * @return
    668           **************************************************************************************************/
    669          //HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    670          //{
    671            /* P0IF is cleared by HW for CHVER < REV_E */
    672          
    673          //  halProcessKeyInterrupt();
    674          
    675          //  if( CHVER >= REV_E )
    676          //  {
    677              /* Make sure that we clear all enabled, but unused P0IFG bits.
    678               * For P0 we can only enable or disable high or low nibble, not bit by
    679               * bit. For P1 and P2 enabling of single bits are possible, therefore
    680               * will not any unused pins generate interrupts on P1 or P2.
    681               * We could have checked for low and high nibble in P0, but this
    682               * isn't necessary as long as we only clear unused pin interrupts.
    683               */
    684          //    P0IFG = (HAL_KEY_P0INT_LOW_USED | HAL_KEY_POINT_HIGH_USED);
    685          //    P0IF = 0;
    686          //    CLEAR_SLEEP_MODE();
    687          //  }
    688          //}
    689          
    690          /**************************************************************************************************
    691           * @fn      halKeyPort1Isr
    692           *
    693           * @brief   Port1 ISR
    694           *
    695           * @param
    696           *
    697           * @return
    698           **************************************************************************************************/
    699          /*
    700          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
    701          {
    702            if( CHVER <= REV_D )
    703            {
    704              P1IF = 0;
    705            }
    706          
    707            halProcessKeyInterrupt();
    708          
    709            if( CHVER >= REV_E )
    710            {
    711              P1IF = 0;
    712              CLEAR_SLEEP_MODE();
    713            }
    714          }
    715          */
    716          /**************************************************************************************************
    717           * @fn      halKeyPort2Isr
    718           *
    719           * @brief   Port2 ISR
    720           *
    721           * @param
    722           *
    723           * @return
    724           **************************************************************************************************/
    725          /*
    726          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
    727          {
    728            if( CHVER <= REV_D )
    729            {
    730              P2IF = 0;
    731            }
    732          
    733            halProcessKeyInterrupt();
    734          
    735            if( CHVER >= REV_E )
    736            {
    737              P2IF = 0;
    738              CLEAR_SLEEP_MODE();
    739            }
    740          */
    741          typedef void (*ISR_t) (void);
    742          /**************************************************************************************************
    743          zyq add 
    744          **************************************************************************************************/
    745          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    746          static ISR_t P1_ISR_fun[8];
   \                     P1_ISR_fun:
   \   000000                DS 16
   \   000010                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    747          static uint8 P1InterruptTaskID[8];
   \                     P1InterruptTaskID:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    748          static rain_t sensor_rain;
   \                     sensor_rain:
   \   000000                DS 5
   \   000005                REQUIRE __INIT_XDATA_Z
    749          
    750          /**************************************************************************************************
    751           * @fn      OpenP1Interrupt
    752           *
    753           * @brief   
    754           *
    755           * @param
    756           *
    757           * @return
    758           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    759          void OpenP1Interrupt( uint8 pin, uint8 FunSelect, uint8 direction, uint8 InputMode, uint8 RiseFallEdge)
   \                     OpenP1Interrupt:
    760          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    761            if(FunSelect==FUN_SELECT_GENERAL)
   \   000005   EA           MOV     A,R2
   \   000006   75..01       MOV     ?V0 + 0,#0x1
   \   000009   75..00       MOV     ?V0 + 1,#0x0
   \   00000C   700D         JNZ     ??OpenP1Interrupt_0
    762            {
    763              P1SEL &= ~(1<<pin);
   \   00000E   E9           MOV     A,R1
   \   00000F   78..         MOV     R0,#?V0 + 0
   \   000011   12....       LCALL   ?S_SHL
   \   000014   E5..         MOV     A,?V0 + 0
   \   000016   F4           CPL     A
   \   000017   55F4         ANL     A,0xf4
   \   000019   800A         SJMP    ??OpenP1Interrupt_1
    764            } 
    765            else 
    766            {
    767              P1SEL |= (1<<pin);
   \                     ??OpenP1Interrupt_0:
   \   00001B   E9           MOV     A,R1
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?S_SHL
   \   000021   E5..         MOV     A,?V0 + 0
   \   000023   45F4         ORL     A,0xf4
   \                     ??OpenP1Interrupt_1:
   \   000025   F5F4         MOV     0xf4,A
    768            }
    769            
    770            if(direction==DIRECTION_INPUT)
   \   000027   EB           MOV     A,R3
   \   000028   75..01       MOV     ?V0 + 0,#0x1
   \   00002B   75..00       MOV     ?V0 + 1,#0x0
   \   00002E   7069         JNZ     ??OpenP1Interrupt_2
    771            {
    772              P1DIR &= ~(1<<pin);
   \   000030   E9           MOV     A,R1
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?S_SHL
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   F4           CPL     A
   \   000039   55FE         ANL     A,0xfe
   \   00003B   F5FE         MOV     0xfe,A
    773          
    774              if(InputMode==INPUT_MODE_PULLUP)
   \   00003D   EC           MOV     A,R4
   \   00003E   7018         JNZ     ??OpenP1Interrupt_3
    775              {
    776                P1INP &= ~(1<<pin);
   \   000040   75..01       MOV     ?V0 + 0,#0x1
   \   000043   75..00       MOV     ?V0 + 1,#0x0
   \   000046   E9           MOV     A,R1
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   F4           CPL     A
   \   00004F   55F6         ANL     A,0xf6
   \   000051   F5F6         MOV     0xf6,A
    777                P2INP &= ~(0x40);
   \   000053   53F7BF       ANL     0xf7,#0xbf
   \   000056   8034         SJMP    ??OpenP1Interrupt_4
    778              }
    779              else if (InputMode==INPUT_MODE_PULLDOWN)
   \                     ??OpenP1Interrupt_3:
   \   000058   7401         MOV     A,#0x1
   \   00005A   6C           XRL     A,R4
   \   00005B   7018         JNZ     ??OpenP1Interrupt_5
    780              {
    781                P1INP &= ~(1<<pin);
   \   00005D   75..01       MOV     ?V0 + 0,#0x1
   \   000060   75..00       MOV     ?V0 + 1,#0x0
   \   000063   E9           MOV     A,R1
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?S_SHL
   \   000069   E5..         MOV     A,?V0 + 0
   \   00006B   F4           CPL     A
   \   00006C   55F6         ANL     A,0xf6
   \   00006E   F5F6         MOV     0xf6,A
    782                P2INP |= (0x40);
   \   000070   43F740       ORL     0xf7,#0x40
   \   000073   8017         SJMP    ??OpenP1Interrupt_4
    783              } 
    784              else if (InputMode==INPUT_MODE_TRISTATE)
   \                     ??OpenP1Interrupt_5:
   \   000075   7402         MOV     A,#0x2
   \   000077   6C           XRL     A,R4
   \   000078   7012         JNZ     ??OpenP1Interrupt_4
    785              {
    786                P1INP |= (1<<pin);
   \   00007A   75..01       MOV     ?V0 + 0,#0x1
   \   00007D   75..00       MOV     ?V0 + 1,#0x0
   \   000080   E9           MOV     A,R1
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   12....       LCALL   ?S_SHL
   \   000086   E5..         MOV     A,?V0 + 0
   \   000088   45F6         ORL     A,0xf6
   \   00008A   F5F6         MOV     0xf6,A
    787              }
    788              
    789              if(RiseFallEdge==RISE_EDGE)
   \                     ??OpenP1Interrupt_4:
   \   00008C   ED           MOV     A,R5
   \   00008D   7005         JNZ     ??OpenP1Interrupt_6
    790              {
    791                PICTL &= ~(0x02);
   \   00008F   538CFD       ANL     0x8c,#0xfd
   \   000092   8011         SJMP    ??OpenP1Interrupt_7
    792              }
    793              else
    794              {
    795                PICTL |= (0x02);
   \                     ??OpenP1Interrupt_6:
   \   000094   438C02       ORL     0x8c,#0x2
   \   000097   800C         SJMP    ??OpenP1Interrupt_7
    796              }
    797            } 
    798            else 
    799            {
    800              P1DIR |= (1<<pin);
   \                     ??OpenP1Interrupt_2:
   \   000099   E9           MOV     A,R1
   \   00009A   78..         MOV     R0,#?V0 + 0
   \   00009C   12....       LCALL   ?S_SHL
   \   00009F   E5..         MOV     A,?V0 + 0
   \   0000A1   45FE         ORL     A,0xfe
   \   0000A3   F5FE         MOV     0xfe,A
    801            }
    802            
    803            P1IFG &= ~(1<<pin);//clean
   \                     ??OpenP1Interrupt_7:
   \   0000A5   75..01       MOV     ?V0 + 0,#0x1
   \   0000A8   75..00       MOV     ?V0 + 1,#0x0
   \   0000AB   E9           MOV     A,R1
   \   0000AC   78..         MOV     R0,#?V0 + 0
   \   0000AE   12....       LCALL   ?S_SHL
   \   0000B1   E5..         MOV     A,?V0 + 0
   \   0000B3   F4           CPL     A
   \   0000B4   558A         ANL     A,0x8a
   \   0000B6   F58A         MOV     0x8a,A
    804            
    805            
    806            switch(pin)
   \   0000B8   E9           MOV     A,R1
   \   0000B9   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for OpenP1Interrupt>_0`:
   \   0000BC   00           DB        0
   \   0000BD   07           DB        7
   \   0000BE   ....         DW        ??OpenP1Interrupt_8
   \   0000C0   ....         DW        ??OpenP1Interrupt_9
   \   0000C2   ....         DW        ??OpenP1Interrupt_10
   \   0000C4   ....         DW        ??OpenP1Interrupt_11
   \   0000C6   ....         DW        ??OpenP1Interrupt_12
   \   0000C8   ....         DW        ??OpenP1Interrupt_13
   \   0000CA   ....         DW        ??OpenP1Interrupt_14
   \   0000CC   ....         DW        ??OpenP1Interrupt_15
   \   0000CE   ....         DW        ??OpenP1Interrupt_16
    807            {
    808              case PIN_0:
    809                P1_ISR_fun[pin] = P1_0_ISR_fun;
   \                     ??OpenP1Interrupt_9:
   \   0000D0   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000D3   74..         MOV     A,#(??P1_0_ISR_fun?relay & 0xff)
   \   0000D5   F0           MOVX    @DPTR,A
   \   0000D6   A3           INC     DPTR
   \   0000D7   74..         MOV     A,#((??P1_0_ISR_fun?relay >> 8) & 0xff)
   \   0000D9   804B         SJMP    ??OpenP1Interrupt_17
    810                break;
    811              case PIN_1:
    812                P1_ISR_fun[pin] = P1_1_ISR_fun;
   \                     ??OpenP1Interrupt_10:
   \   0000DB   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000DE   74..         MOV     A,#(??P1_1_ISR_fun?relay & 0xff)
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   74..         MOV     A,#((??P1_1_ISR_fun?relay >> 8) & 0xff)
   \   0000E4   8040         SJMP    ??OpenP1Interrupt_17
    813                break;
    814              case PIN_2:
    815                P1_ISR_fun[pin] = P1_2_ISR_fun;
   \                     ??OpenP1Interrupt_11:
   \   0000E6   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000E9   74..         MOV     A,#(??P1_2_ISR_fun?relay & 0xff)
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   74..         MOV     A,#((??P1_2_ISR_fun?relay >> 8) & 0xff)
   \   0000EF   8035         SJMP    ??OpenP1Interrupt_17
    816                break;
    817              case PIN_3:
    818                P1_ISR_fun[pin] = P1_3_ISR_fun;
   \                     ??OpenP1Interrupt_12:
   \   0000F1   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000F4   74..         MOV     A,#(??P1_3_ISR_fun?relay & 0xff)
   \   0000F6   F0           MOVX    @DPTR,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   74..         MOV     A,#((??P1_3_ISR_fun?relay >> 8) & 0xff)
   \   0000FA   802A         SJMP    ??OpenP1Interrupt_17
    819                break;
    820              case PIN_4:
    821                P1_ISR_fun[pin] = P1_4_ISR_fun;
   \                     ??OpenP1Interrupt_13:
   \   0000FC   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000FF   74..         MOV     A,#(??P1_4_ISR_fun?relay & 0xff)
   \   000101   F0           MOVX    @DPTR,A
   \   000102   A3           INC     DPTR
   \   000103   74..         MOV     A,#((??P1_4_ISR_fun?relay >> 8) & 0xff)
   \   000105   801F         SJMP    ??OpenP1Interrupt_17
    822                break;
    823              case PIN_5:
    824                P1_ISR_fun[pin] = P1_5_ISR_fun;
   \                     ??OpenP1Interrupt_14:
   \   000107   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00010A   74..         MOV     A,#(??P1_5_ISR_fun?relay & 0xff)
   \   00010C   F0           MOVX    @DPTR,A
   \   00010D   A3           INC     DPTR
   \   00010E   74..         MOV     A,#((??P1_5_ISR_fun?relay >> 8) & 0xff)
   \   000110   8014         SJMP    ??OpenP1Interrupt_17
    825                break;
    826              case PIN_6:
    827                P1_ISR_fun[pin] = P1_6_ISR_fun;
   \                     ??OpenP1Interrupt_15:
   \   000112   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000115   74..         MOV     A,#(??P1_6_ISR_fun?relay & 0xff)
   \   000117   F0           MOVX    @DPTR,A
   \   000118   A3           INC     DPTR
   \   000119   74..         MOV     A,#((??P1_6_ISR_fun?relay >> 8) & 0xff)
   \   00011B   8009         SJMP    ??OpenP1Interrupt_17
    828                break;
    829              case PIN_7:
    830                P1_ISR_fun[pin] = P1_7_ISR_fun;
   \                     ??OpenP1Interrupt_16:
   \   00011D   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000120   74..         MOV     A,#(??P1_7_ISR_fun?relay & 0xff)
   \   000122   F0           MOVX    @DPTR,A
   \   000123   A3           INC     DPTR
   \   000124   74..         MOV     A,#((??P1_7_ISR_fun?relay >> 8) & 0xff)
   \                     ??OpenP1Interrupt_17:
   \   000126   F0           MOVX    @DPTR,A
    831                break;
    832            }
    833          }
   \                     ??OpenP1Interrupt_8:
   \   000127                REQUIRE ?Subroutine8
   \   000127                REQUIRE P1IFG
   \   000127                REQUIRE PICTL
   \   000127                REQUIRE P1SEL
   \   000127                REQUIRE P1INP
   \   000127                REQUIRE P2INP
   \   000127                REQUIRE P1DIR
   \   000127                ; // Fall through to label ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E9           MOV     A,R1
   \   000001   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   24..         ADD     A,#(P1_ISR_fun & 0xff)
   \   000009   F582         MOV     DPL,A
   \   00000B   E9           MOV     A,R1
   \   00000C   34..         ADDC    A,#((P1_ISR_fun >> 8) & 0xff)
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET
    834          
    835          /**************************************************************************************************
    836           * @fn      CloseP1Interrupt
    837           *
    838           * @brief   
    839           *
    840           * @param
    841           *
    842           * @return
    843           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    844          void CloseP1Interrupt(uint8 pin)
   \                     CloseP1Interrupt:
    845          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    846            P1_ISR_fun[pin]=0;
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?Subroutine0 & 0xFFFF
    847          }
   \                     ??CrossCallReturnLabel_0:
   \   000008                REQUIRE ?Subroutine6
   \   000008                ; // Fall through to label ?Subroutine6

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   A3           INC     DPTR
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET
    848          
    849          /**************************************************************************************************
    850           * @fn      StartP1Interrupt
    851           *
    852           * @brief   
    853           *
    854           * @param
    855           *
    856           * @return
    857           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    858          void StartP1Interrupt(uint8 pin)
   \                     StartP1Interrupt:
    859          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    860            EA = 1;
   \   000004   D2AF         SETB    0xa8.7
    861            IEN2 |= (0x10);
   \   000006   439A10       ORL     0x9a,#0x10
    862            P1IEN |= (1<<pin);
   \   000009   75..01       MOV     ?V0 + 0,#0x1
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   \   00000F   E9           MOV     A,R1
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?S_SHL
   \   000015   E5..         MOV     A,?V0 + 0
   \   000017   458D         ORL     A,0x8d
   \   000019                REQUIRE ?Subroutine5
   \   000019                REQUIRE P1IEN
   \   000019                REQUIRE IEN2
   \   000019                REQUIRE _A_IEN0
   \   000019                ; // Fall through to label ?Subroutine5
    863          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F58D         MOV     0x8d,A
   \   000002   D0..         POP     ?V0 + 1
   \   000004   D0..         POP     ?V0 + 0
   \   000006   02....       LJMP    ?BRET
    864          
    865          /**************************************************************************************************
    866           * @fn      StopP1Interrupt
    867           *
    868           * @brief   
    869           *
    870           * @param
    871           *
    872           * @return
    873           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    874          void StopP1Interrupt(uint8 pin)
   \                     StopP1Interrupt:
    875          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    876            P1IEN &= ~(1<<pin);  
   \   000004   75..01       MOV     ?V0 + 0,#0x1
   \   000007   75..00       MOV     ?V0 + 1,#0x0
   \   00000A   E9           MOV     A,R1
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?S_SHL
   \   000010   E5..         MOV     A,?V0 + 0
   \   000012   F4           CPL     A
   \   000013   558D         ANL     A,0x8d
   \   000015   80..         SJMP    ?Subroutine5
   \   000017                REQUIRE P1IEN
    877          }
    878          
    879          /**************************************************************************************************
    880           * @fn      RegisterP1Interrupt
    881           *
    882           * @brief   
    883           *
    884           * @param
    885           *
    886           * @return
    887           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    888          void RegisterP1Interrupt(uint8 pin, uint8 TaskID)
   \                     RegisterP1Interrupt:
    889          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    890              P1InterruptTaskID[pin]=TaskID;
   \   000005   E9           MOV     A,R1
   \   000006   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000009   EA           MOV     A,R2
   \   00000A   F0           MOVX    @DPTR,A
    891          }
   \   00000B   80..         SJMP    ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   24..         ADD     A,#(P1InterruptTaskID & 0xff)
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   34..         ADDC    A,#((P1InterruptTaskID >> 8) & 0xff)
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET
    892          
    893          /**************************************************************************************************
    894           * @fn      QueryP1Interrupt
    895           *
    896           * @brief   
    897           *
    898           * @param
    899           *
    900           * @return
    901           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    902          uint8 QueryP1Interrupt(uint8 pin)
   \                     QueryP1Interrupt:
    903          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    904            switch(pin)
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for QueryP1Interrupt>_0`:
   \   000008   03           DB        3
   \   000009   00           DB        0
   \   00000A   ....         DW        ??QueryP1Interrupt_0
   \   00000C   ....         DW        ??QueryP1Interrupt_1
    905            {
    906              case PIN_0:
    907          
    908                break;
    909              case PIN_1:
    910          
    911                break;
    912              case PIN_2:
    913                break;
    914              case PIN_3:
    915                sensor_rain.ReadState=1;
   \                     ??QueryP1Interrupt_1:
   \   00000E   7401         MOV     A,#0x1
   \   000010   90....       MOV     DPTR,#(sensor_rain + 4)
   \   000013   F0           MOVX    @DPTR,A
    916                return sensor_rain.count;      
   \   000014   90....       MOV     DPTR,#(sensor_rain + 2)
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   8002         SJMP    ??QueryP1Interrupt_2
    917                //break;
    918              case PIN_4:
    919          
    920                break;
    921              case PIN_5:
    922          
    923                break;
    924              case PIN_6:
    925          
    926                break;
    927              case PIN_7:
    928          
    929                break;
    930            }
    931            return 0xFF;
   \                     ??QueryP1Interrupt_0:
   \   00001B   79FF         MOV     R1,#-0x1
   \                     ??QueryP1Interrupt_2:
   \   00001D   80..         SJMP    ?Subroutine6
    932          }
    933          
    934          /**************************************************************************************************
    935           * @fn      HalP1InterruptConfig
    936           *
    937           * @brief   
    938           *
    939           * @param
    940           *
    941           * @return
    942           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    943          void HalP1InterruptConfig( void )
   \                     HalP1InterruptConfig:
    944          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    945            EA=1;
   \   000004   D2AF         SETB    0xa8.7
    946            uint8 pin;
    947            for(pin=0;pin<8;pin++)
   \   000006   7C00         MOV     R4,#0x0
    948            {
    949              P1_ISR_fun[pin]=0;
   \                     ??HalP1InterruptConfig_0:
   \   000008   8C82         MOV     DPL,R4
   \   00000A   AA82         MOV     R2,DPL
   \   00000C   EA           MOV     A,R2
   \   00000D   12....       LCALL   ?Subroutine0 & 0xFFFF
    950              P1InterruptTaskID[pin]=0xFF;  //0xFF is not register
   \                     ??CrossCallReturnLabel_1:
   \   000010   EA           MOV     A,R2
   \   000011   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000014   74FF         MOV     A,#-0x1
   \   000016   F0           MOVX    @DPTR,A
    951            }
   \   000017   0C           INC     R4
   \   000018   EC           MOV     A,R4
   \   000019   C3           CLR     C
   \   00001A   9408         SUBB    A,#0x8
   \   00001C   40EA         JC      ??HalP1InterruptConfig_0
    952            EA=0;  
   \   00001E   C2AF         CLR     0xa8.7
    953          }
   \   000020   02....       LJMP    ?Subroutine6 & 0xFFFF
   \   000023                REQUIRE _A_IEN0
    954          
    955          
    956          /**************************************************************************************************
    957           * @fn      halP1Isr
    958           *
    959           * @brief   
    960           *
    961           * @param
    962           *
    963           * @return
    964           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    965          HAL_ISR_FUNCTION( halP1Isr, P1INT_VECTOR )
   \                     halP1Isr:
    966          {
   \   000000   C0E0         PUSH    A
   \   000002   74F1         MOV     A,#-0xf
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 16
   \   000007                ; Auto size: 0
    967            uint8 pin;  
    968            for(pin=0;pin<8;pin++)
   \   000007   7E00         MOV     R6,#0x0
    969            {
    970              if((P1IFG & (1<<pin)) && P1_ISR_fun[pin])
   \                     ??halP1Isr_0:
   \   000009   75..01       MOV     ?V0 + 0,#0x1
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   \   00000F   EE           MOV     A,R6
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?S_SHL
   \   000015   E5..         MOV     A,?V0 + 0
   \   000017   558A         ANL     A,0x8a
   \   000019   6039         JZ      ??halP1Isr_1
   \   00001B   EE           MOV     A,R6
   \   00001C   C3           CLR     C
   \   00001D   33           RLC     A
   \   00001E   F8           MOV     R0,A
   \   00001F   E4           CLR     A
   \   000020   33           RLC     A
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_14:
   \   000026   7002         JNZ     ??halP1Isr_2
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \                     ??halP1Isr_2:
   \   00002A   6028         JZ      ??halP1Isr_1
    971              {
    972                P2_0=!P2_0;           //LED -- test purpose      
   \   00002C   A2A0         MOV     C,0xa0.0
   \   00002E   B3           CPL     C
   \   00002F   92A0         MOV     0xa0.0,C
    973                P1IFG &= ~(1<<pin);   //clean
   \   000031   75..01       MOV     ?V0 + 0,#0x1
   \   000034   75..00       MOV     ?V0 + 1,#0x0
   \   000037   EE           MOV     A,R6
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?S_SHL
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   F4           CPL     A
   \   000040   558A         ANL     A,0x8a
   \   000042   F58A         MOV     0x8a,A
    974                (P1_ISR_fun[pin])();
   \   000044                ; Setup parameters for indirect call
   \   000044   EE           MOV     A,R6
   \   000045   C3           CLR     C
   \   000046   33           RLC     A
   \   000047   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_15:
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F583         MOV     DPH,A
   \   00004F   8882         MOV     DPL,R0
   \   000051   12....       LCALL   ?CALL_IND
    975              }
    976            }
   \                     ??halP1Isr_1:
   \   000054   0E           INC     R6
   \   000055   EE           MOV     A,R6
   \   000056   C3           CLR     C
   \   000057   9408         SUBB    A,#0x8
   \   000059   40AE         JC      ??halP1Isr_0
    977            P1IF=0;
   \   00005B   C2EB         CLR     0xe8.3
    978          }
   \   00005D   7F02         MOV     R7,#0x2
   \   00005F   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000062                REQUIRE P1IFG
   \   000062                REQUIRE _A_P2
   \   000062                REQUIRE _A_IRCON2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   24..         ADD     A,#(P1_ISR_fun & 0xff)
   \   000002   F582         MOV     DPL,A
   \   000004   E9           MOV     A,R1
   \   000005   34..         ADDC    A,#((P1_ISR_fun >> 8) & 0xff)
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
    979          
    980          /**************************************************************************************************
    981           * @fn      P1_0_ISR_fun
    982           *
    983           * @brief   
    984           *
    985           * @param
    986           *
    987           * @return
    988           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    989          void P1_0_ISR_fun()
   \                     P1_0_ISR_fun:
    990          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    991            
    992          }
   \   000000   02....       LJMP    ?BRET
    993          
    994          /**************************************************************************************************
    995           * @fn      P1_1_ISR_fun
    996           *
    997           * @brief   
    998           *
    999           * @param
   1000           *
   1001           * @return
   1002           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1003          void P1_1_ISR_fun()
   \                     P1_1_ISR_fun:
   1004          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1005            
   1006          }
   \   000000   02....       LJMP    ?BRET
   1007          
   1008          /**************************************************************************************************
   1009           * @fn      P1_2_ISR_fun
   1010           *
   1011           * @brief   
   1012           *
   1013           * @param
   1014           *
   1015           * @return
   1016           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1017          void P1_2_ISR_fun()
   \                     P1_2_ISR_fun:
   1018          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1019          
   1020          }
   \   000000   02....       LJMP    ?BRET
   1021          
   1022          /**************************************************************************************************
   1023           * @fn      P1_3_ISR_fun
   1024           *
   1025           * @brief   
   1026           *
   1027           * @param
   1028           *
   1029           * @return
   1030           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1031          void P1_3_ISR_fun()
   \                     P1_3_ISR_fun:
   1032          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1033            sensor_rain.count++;
   \   000005   90....       MOV     DPTR,#(sensor_rain + 2)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   2401         ADD     A,#0x1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F0           MOVX    @DPTR,A
   1034            sensor_rain.ReadState=0;
   \   000011   E4           CLR     A
   \   000012   90....       MOV     DPTR,#(sensor_rain + 4)
   \   000015   F0           MOVX    @DPTR,A
   1035            if(P1InterruptTaskID[3]!=0xFF)
   \   000016   90....       MOV     DPTR,#(P1InterruptTaskID + 3)
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   64FF         XRL     A,#0xff
   \   00001C   6035         JZ      ??P1_3_ISR_fun_0
   1036            {
   1037              rain_t *msgPtr;
   1038              msgPtr = (rain_t *)osal_msg_allocate( sizeof(rain_t) );
   \   00001E                ; Setup parameters for call to function osal_msg_allocate
   \   00001E   7A05         MOV     R2,#0x5
   \   000020   7B00         MOV     R3,#0x0
   \   000022   12....       LCALL   ??osal_msg_allocate?relay
   1039              if ( msgPtr )
   \   000025   EA           MOV     A,R2
   \   000026   7001         JNZ     ??P1_3_ISR_fun_1
   \   000028   EB           MOV     A,R3
   \                     ??P1_3_ISR_fun_1:
   \   000029   6028         JZ      ??P1_3_ISR_fun_0
   1040              {
   1041                msgPtr->hdr.event = P1_3_INTERRUPT;
   \   00002B   74C4         MOV     A,#-0x3c
   \   00002D   8A82         MOV     DPL,R2
   \   00002F   8B83         MOV     DPH,R3
   \   000031   F0           MOVX    @DPTR,A
   1042                msgPtr->count = sensor_rain.count;
   \   000032   90....       MOV     DPTR,#(sensor_rain + 2)
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   8A82         MOV     DPL,R2
   \   00003C   8B83         MOV     DPH,R3
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E8           MOV     A,R0
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   E9           MOV     A,R1
   \   000044   F0           MOVX    @DPTR,A
   1043                osal_msg_send(P1InterruptTaskID[3], (uint8 *)msgPtr);         
   \   000045                ; Setup parameters for call to function osal_msg_send
   \   000045   90....       MOV     DPTR,#(P1InterruptTaskID + 3)
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   12....       LCALL   ??osal_msg_send?relay
   1044                sensor_rain.ReadState=1;
   \   00004D   7401         MOV     A,#0x1
   \   00004F   90....       MOV     DPTR,#(sensor_rain + 4)
   \   000052   F0           MOVX    @DPTR,A
   1045              }
   1046            }  
   1047          }
   \                     ??P1_3_ISR_fun_0:
   \   000053   02....       LJMP    ?Subroutine8 & 0xFFFF
   1048          
   1049          /**************************************************************************************************
   1050           * @fn      P1_4_ISR_fun
   1051           *
   1052           * @brief   
   1053           *
   1054           * @param
   1055           *
   1056           * @return
   1057           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1058          void P1_4_ISR_fun()
   \                     P1_4_ISR_fun:
   1059          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1060          }
   \   000000   02....       LJMP    ?BRET
   1061          
   1062          /**************************************************************************************************
   1063           * @fn      P1_5_ISR_fun
   1064           *
   1065           * @brief   
   1066           *
   1067           * @param
   1068           *
   1069           * @return
   1070           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1071          void P1_5_ISR_fun()
   \                     P1_5_ISR_fun:
   1072          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1073          }
   \   000000   02....       LJMP    ?BRET
   1074          
   1075          /**************************************************************************************************
   1076           * @fn      P1_6_ISR_fun
   1077           *
   1078           * @brief   
   1079           *
   1080           * @param
   1081           *
   1082           * @return
   1083           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1084          void P1_6_ISR_fun()
   \                     P1_6_ISR_fun:
   1085          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1086          }
   \   000000   02....       LJMP    ?BRET
   1087          
   1088          /**************************************************************************************************
   1089           * @fn      P1_7_ISR_fun
   1090           *
   1091           * @brief   
   1092           *
   1093           * @param
   1094           *
   1095           * @return
   1096           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1097          void P1_7_ISR_fun()
   \                     P1_7_ISR_fun:
   1098          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1099          }
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment INTVEC, offset 0x7b, root
   \                     `??halP1Isr??INTVEC 123`:
   \   00007B   02....       LJMP       (halP1Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??OpenP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OpenP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??CloseP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    CloseP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??StartP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    StartP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??StopP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    StopP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??RegisterP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RegisterP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??QueryP1Interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    QueryP1Interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalP1InterruptConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalP1InterruptConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_0_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_0_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_1_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_1_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_2_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_2_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_3_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_3_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_4_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_4_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_5_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_5_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_6_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_6_ISR_fun

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??P1_7_ISR_fun?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    P1_7_ISR_fun
   1100          

   Maximum stack usage in bytes:

     Function               ISTACK PSTACK XSTACK
     --------               ------ ------ ------
     CloseP1Interrupt           2      0      0
     HalKeyConfig               0      0      0
     HalKeyEnterSleep           0      0      0
     HalKeyExitSleep            0      0      0
     HalKeyInit                 0      0      0
     HalKeyPoll                 0      0      0
     HalKeyRead                 0      0      0
     HalP1InterruptConfig       3      0      0
     OpenP1Interrupt            0      0     10
     P1_0_ISR_fun               0      0      0
     P1_1_ISR_fun               0      0      0
     P1_2_ISR_fun               0      0      0
     P1_3_ISR_fun               1      0     10
       -> osal_msg_allocate     0      0     20
       -> osal_msg_send         0      0     20
     P1_4_ISR_fun               0      0      0
     P1_5_ISR_fun               0      0      0
     P1_6_ISR_fun               0      0      0
     P1_7_ISR_fun               0      0      0
     QueryP1Interrupt           2      0      0
     RegisterP1Interrupt        1      0     10
     StartP1Interrupt           2      0      0
     StopP1Interrupt            2      0      0
     halP1Isr                  16      0      0
     halProcessKeyInterrupt     0      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     P1IFG                             1
     PICTL                             1
     P1IEN                             1
     P0INP                             1
     IEN2                              1
     _A_P2                             1
     _A_IEN0                           1
     _A_IRCON2                         1
     P1SEL                             1
     P1INP                             1
     P2INP                             1
     P1DIR                             1
     Hal_KeyIntEnable                  1
     halSaveIntKey                     1
     HalKeyInit                        3
     HalKeyConfig                      3
     HalKeyRead                        0
     ?Subroutine7                      5
     HalKeyPoll                        3
     halProcessKeyInterrupt            3
     HalKeyEnterSleep                  6
     HalKeyExitSleep                   5
     P1_ISR_fun                       16
     P1InterruptTaskID                 8
     sensor_rain                       5
     OpenP1Interrupt                 295
     ?Subroutine8                      5
     ?Subroutine1                      5
     ?Subroutine3                     17
     CloseP1Interrupt                  8
     ?Subroutine6                      7
     ?Subroutine0                      8
     StartP1Interrupt                 25
     ?Subroutine5                      9
     StopP1Interrupt                  23
     RegisterP1Interrupt              13
     ?Subroutine2                     10
     QueryP1Interrupt                 31
     HalP1InterruptConfig             35
     halP1Isr                         98
     ?Subroutine4                     11
     P1_0_ISR_fun                      3
     P1_1_ISR_fun                      3
     P1_2_ISR_fun                      3
     P1_3_ISR_fun                     86
     P1_4_ISR_fun                      3
     P1_5_ISR_fun                      3
     P1_6_ISR_fun                      3
     P1_7_ISR_fun                      3
     ??halP1Isr??INTVEC 123            3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6
     ??OpenP1Interrupt?relay           6
     ??CloseP1Interrupt?relay          6
     ??StartP1Interrupt?relay          6
     ??StopP1Interrupt?relay           6
     ??RegisterP1Interrupt?relay       6
     ??QueryP1Interrupt?relay          6
     ??HalP1InterruptConfig?relay      6
     ??P1_0_ISR_fun?relay              6
     ??P1_1_ISR_fun?relay              6
     ??P1_2_ISR_fun?relay              6
     ??P1_3_ISR_fun?relay              6
     ??P1_4_ISR_fun?relay              6
     ??P1_5_ISR_fun?relay              6
     ??P1_6_ISR_fun?relay              6
     ??P1_7_ISR_fun?relay              6

 
 626 bytes in segment BANKED_CODE
 132 bytes in segment BANK_RELAYS
   3 bytes in segment INTVEC
 109 bytes in segment NEAR_CODE
  12 bytes in segment SFR_AN
  31 bytes in segment XDATA_Z
 
 867 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of DATA  memory (+ 12 bytes shared)
  31 bytes of XDATA memory

Errors: none
Warnings: none
