###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    12/Sep/2012  16:16:36 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Documents and Settings\Administrator\桌面\8-22\ #
#                          Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\C #
#                          omponents\hal\target\CC2430EB\hal_adc.c            #
#    Command line       =  -f "C:\Documents and Settings\Administrator\桌面\8 #
#                          -22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\1-network               #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wRoute #
#                          r.cfg" (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS "-DCONST=const __code"    #
#                          -DGENERIC=__generic) -f "C:\Documents and          #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfi #
#                          g.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800   #
#                          -DZDAPP_CONFIG_PAN_ID=0x1234                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Documents and           #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Compone #
#                          nts\hal\target\CC2430EB\hal_adc.c" -D CC2430EB -D  #
#                          REFLECTOR -D ZTOOL_P1 -D MT_TASK -D MT_ZDO_FUNC    #
#                          -D xLCD_SUPPORTED=DEBUG -lC "C:\Documents and      #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\RouterEB\List\" -lA              #
#                          "C:\Documents and Settings\Administrator\桌面\8-22 #
#                          \Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\1-network                  #
#                          formaton\CC2430DB\RouterEB\List\" --diag_suppress  #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Documents   #
#                          and Settings\Administrator\桌面\8-22\Texas         #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\RouterEB\Obj\" -e                #
#                          --require_prototypes -z9 --no_code_motion --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Documents and Settings\Administrator\桌面\8 #
#                          -22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\1-network               #
#                          formaton\CC2430DB\" -I "C:\Documents and           #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\SOURCE\" -I "C:\Documents     #
#                          and Settings\Administrator\桌面\8-22\Texas         #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I     #
#                          "C:\Documents and Settings\Administrator\桌面\8-22 #
#                          \Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\1-network                  #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MT\"   #
#                          -I "C:\Documents and Settings\Administrator\桌面\8 #
#                          -22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\1-network               #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\IN #
#                          CLUDE\" -I "C:\Documents and                       #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\TA #
#                          RGET\CC2430EB\" -I "C:\Documents and               #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\M #
#                          CU\CCSOC\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\I #
#                          NCLUDE\" -I "C:\Documents and                      #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          AF\" -I "C:\Documents and                          #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          NWK\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SEC\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          SYS\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ #
#                          ZDO\" -I "C:\Documents and                         #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\F #
#                          8W\" -I "C:\Documents and                          #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\" #
#                           -I "C:\Documents and Settings\Administrator\桌面\ #
#                          8-22\Texas Instruments nongmenshan\ZStack-1.4.3-1. #
#                          2.1\Projects\zstack\Samples\1-network              #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SADDR\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\SERVIC #
#                          ES\SDATA\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\IN #
#                          CLUDE\" -I "C:\Documents and                       #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\HI #
#                          GH_LEVEL\" -I "C:\Documents and                    #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\" -I "C:\Documents and               #
#                          Settings\Administrator\桌面\8-22\Texas             #
#                          Instruments nongmenshan\ZStack-1.4.3-1.2.1\Project #
#                          s\zstack\Samples\1-network                         #
#                          formaton\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LO #
#                          W_LEVEL\SRF03\SINGLE_CHIP\" -I "D:\IAR             #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\" -I "D:\IAR Systems\Embedded     #
#                          Workbench 4.0 Evaluation version\8051\INC\CLIB\"   #
#    List file          =  C:\Documents and Settings\Administrator\桌面\8-22\ #
#                          Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\P #
#                          rojects\zstack\Samples\1-network                   #
#                          formaton\CC2430DB\RouterEB\List\hal_adc.lst        #
#    Object file        =  C:\Documents and Settings\Administrator\桌面\8-22\ #
#                          Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\P #
#                          rojects\zstack\Samples\1-network                   #
#                          formaton\CC2430DB\RouterEB\Obj\hal_adc.r51         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\桌面\8-22\Texas Instruments nongmenshan\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2007-11-01 08:44:53 -0700 (Thu, 01 Nov 2007) $
      4            Revision:       $Revision: 15821 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include  "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb5
   \   unsigned char volatile __sfr ADCCON2
   \                     ADCCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     44          #include  "hal_defs.h"
     45          #include  "hal_types.h"
     46          #include  "hal_adc.h"
     47          
     48          /**************************************************************************************************
     49           *                                            CONSTANTS
     50           **************************************************************************************************/
     51          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     52          #define HAL_ADC_START       0x40    /* Starts Conversion */
     53          
     54          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     55          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     56          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     57          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     58          
     59          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     60          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     61          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     62          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     63          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     64          
     65          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     66          #define HAL_ADC_REF_AIN7    0x40    /* AIN7 Reference */
     67          #define HAL_ADC_REF_AVDD    0x80    /* AVDD_SOC Pin Reference */
     68          #define HAL_ADC_REF_DIFF    0xc0    /* AIN7,AIN6 Differential Reference */
     69          #define HAL_ADC_REF_BITS    0xc0    /* Bits [7:6] */
     70          
     71          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     72          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     73          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     74          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     75          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     76          
     77          #define HAL_ADC_CHN_AIN0    0x00    /* AIN0 */
     78          #define HAL_ADC_CHN_AIN1    0x01    /* AIN1 */
     79          #define HAL_ADC_CHN_AIN2    0x02    /* AIN2 */
     80          #define HAL_ADC_CHN_AIN3    0x03    /* AIN3 */
     81          #define HAL_ADC_CHN_AIN4    0x04    /* AIN4 */
     82          #define HAL_ADC_CHN_AIN5    0x05    /* AIN5 */
     83          #define HAL_ADC_CHN_AIN6    0x06    /* AIN6 */
     84          #define HAL_ADC_CHN_AIN7    0x07    /* AIN7 */
     85          #define HAL_ADC_CHN_A0A1    0x08    /* AIN0,AIN1 */
     86          #define HAL_ADC_CHN_A2A3    0x09    /* AIN2,AIN3 */
     87          #define HAL_ADC_CHN_A4A5    0x0a    /* AIN4,AIN5 */
     88          #define HAL_ADC_CHN_A6A7    0x0b    /* AIN6,AIN7 */
     89          #define HAL_ADC_CHN_GND     0x0c    /* GND */
     90          #define HAL_ADC_CHN_VREF    0x0d    /* Positive voltage reference */
     91          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     92          #define HAL_ADC_CHN_VDD3    0x0f    /* VDD/3 */
     93          #define HAL_ADC_CHN_BITS    0x0f    /* Bits [3:0] */
     94          
     95          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     96          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     97          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     98          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     99          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
    100          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
    101          
    102          
    103          /* Vdd limit values */

   \                                 In  segment CODE_C, align 1
    104          static __code const uint16 HalAdcVddLimit[] =
   \                     HalAdcVddLimit:
   \   000000   9C36063A     DW 13980, 14854, 15728, 16601, 17475, 18349, 19223, 20097, 20970
   \            703DD940
   \            4344AD47
   \            174B814E
   \            EA51    
    105          {
    106            0x369C,       /*  VDD Limit - 1.6v  */
    107            0x3A06,       /*  VDD Limit - 1.7v  */
    108            0x3D70,       /*  VDD Limit - 1.8v  */
    109            0x40D9,       /*  VDD Limit - 1.9v  */
    110            0x4443,       /*  VDD Limit - 2.0v  */
    111            0x47AD,       /*  VDD Limit - 2.1v  */
    112            0x4B17,       /*  VDD Limit - 2.2v  */
    113            0x4E81,       /*  VDD Limit - 2.3v  */
    114            0x51EA,       /*  VDD Limit - 2.4v  */
    115          };
    116          
    117          
    118          /**************************************************************************************************
    119           *                                              MACROS
    120           **************************************************************************************************/
    121          #define HAL_ADC_CLR_EOC()   asm("PUSH A"); asm("MOV A,ADCL"); asm("MOV A,ADCH"); asm("POP A");
    122          
    123          /**************************************************************************************************
    124           *                                            TYPEDEFS
    125           **************************************************************************************************/
    126          
    127          /**************************************************************************************************
    128           *                                         GLOBAL VARIABLES
    129           **************************************************************************************************/
    130          
    131          /**************************************************************************************************
    132           *                                          FUNCTIONS - API
    133           **************************************************************************************************/
    134          extern bool HalAdcCheckVdd (uint8 limit);
    135          
    136          /**************************************************************************************************
    137           * @fn      HalAdcInit
    138           *
    139           * @brief   Initialize ADC Service
    140           *
    141           * @param   None
    142           *
    143           * @return  None
    144           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void HalAdcInit (void)
   \                     HalAdcInit:
    146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    147          #if (HAL_ADC == TRUE)
    148            volatile uint8  tmp;
    149          
    150            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    151            ADCCON2 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   75B58F       MOV     0xb5,#-0x71
    152            /*
    153            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    154            *  We will do a few dummy conversions to bypass this bug.
    155            */
    156            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00000F   E5BA         MOV     A,0xba
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   F0           MOVX    @DPTR,A
    157            tmp = ADCH;
   \   000018   E5BB         MOV     A,0xbb
   \   00001A   F0           MOVX    @DPTR,A
    158            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00001B   75B68C       MOV     0xb6,#-0x74
    159            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_0:
   \   00001E   E5B4         MOV     A,0xb4
   \   000020   A2E7         MOV     C,0xE0 /* A   */.7
   \   000022   50FA         JNC     ??HalAdcInit_0
    160            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000024   E5BA         MOV     A,0xba
   \   000026   F0           MOVX    @DPTR,A
    161            tmp = ADCH;
   \   000027   E5BB         MOV     A,0xbb
   \   000029   F0           MOVX    @DPTR,A
    162            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00002A   75B68C       MOV     0xb6,#-0x74
    163            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_1:
   \   00002D   E5B4         MOV     A,0xb4
   \   00002F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000031   50FA         JNC     ??HalAdcInit_1
    164            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000033   E5BA         MOV     A,0xba
   \   000035   F0           MOVX    @DPTR,A
    165            tmp = ADCH;
   \   000036   E5BB         MOV     A,0xbb
   \   000038   F0           MOVX    @DPTR,A
    166          #endif
    167          }
   \   000039   7401         MOV     A,#0x1
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E                REQUIRE ?Subroutine0
   \   00003E                REQUIRE ADCCON1
   \   00003E                REQUIRE ADCCON2
   \   00003E                REQUIRE ADCCON3
   \   00003E                REQUIRE ADCL
   \   00003E                REQUIRE ADCH
   \   00003E                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    168          
    169          /**************************************************************************************************
    170           * @fn      HalAdcRead
    171           *
    172           * @brief   Read the ADC based on given channel and resolution
    173           *
    174           * @param   channel - channel where ADC will be read
    175           * @param   resolution - the resolution of the value
    176           *
    177           * @return  16 bit value of the ADC in offset binary format.
    178           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    179           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    181          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    182            int16  reading = 0;
    183          
    184          #if (HAL_ADC == TRUE)
    185          
    186            uint8   i, resbits;
    187            uint8   adctemp;
    188            volatile  uint8 tmp;
    189            uint8  adcChannel = 1;
   \   00000A   7C01         MOV     R4,#0x1
    190          
    191            /*
    192            * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    193            * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    194            * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    195            * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    196            * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    197            * than actuality because the pin did not have time to fully charge.
    198            */
    199            if (channel < 8)
   \   00000C   E9           MOV     A,R1
   \   00000D   C3           CLR     C
   \   00000E   9408         SUBB    A,#0x8
   \   000010   500E         JNC     ??HalAdcRead_0
    200            {
    201              for (i=0; i < channel; i++)
   \   000012   7B00         MOV     R3,#0x0
   \   000014   8005         SJMP    ??HalAdcRead_1
    202              {
    203                adcChannel <<= 1;
   \                     ??HalAdcRead_2:
   \   000016   EC           MOV     A,R4
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   FC           MOV     R4,A
    204              }
   \   00001A   0B           INC     R3
   \                     ??HalAdcRead_1:
   \   00001B   EB           MOV     A,R3
   \   00001C   C3           CLR     C
   \   00001D   99           SUBB    A,R1
   \   00001E   40F6         JC      ??HalAdcRead_2
    205            }
    206          
    207            /* Enable channel */
    208            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   000020   EC           MOV     A,R4
   \   000021   45F2         ORL     A,0xf2
   \   000023   F5F2         MOV     0xf2,A
    209          
    210            /* Convert resolution to decimation rate */
    211            switch (resolution)
   \   000025   EA           MOV     A,R2
   \   000026   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_0`:
   \   000029   01           DB        1
   \   00002A   02           DB        2
   \   00002B   ....         DW        ??HalAdcRead_3
   \   00002D   ....         DW        ??HalAdcRead_4
   \   00002F   ....         DW        ??HalAdcRead_5
   \   000031   ....         DW        ??HalAdcRead_6
    212            {
    213              case HAL_ADC_RESOLUTION_8:
    214                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_4:
   \   000033   7B00         MOV     R3,#0x0
   \   000035   800A         SJMP    ??HalAdcRead_7
    215                break;
    216              case HAL_ADC_RESOLUTION_10:
    217                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_5:
   \   000037   7B10         MOV     R3,#0x10
   \   000039   8006         SJMP    ??HalAdcRead_7
    218                break;
    219              case HAL_ADC_RESOLUTION_12:
    220                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_6:
   \   00003B   7B20         MOV     R3,#0x20
   \   00003D   8002         SJMP    ??HalAdcRead_7
    221                break;
    222              case HAL_ADC_RESOLUTION_14:
    223              default:
    224                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_3:
   \   00003F   7B30         MOV     R3,#0x30
    225                break;
    226            }
    227          
    228            /* read ADCL,ADCH to clear EOC */
    229            tmp = ADCL;
   \                     ??HalAdcRead_7:
   \   000041   E5BA         MOV     A,0xba
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   F0           MOVX    @DPTR,A
    230            tmp = ADCH;
   \   00004A   E5BB         MOV     A,0xbb
   \   00004C   F0           MOVX    @DPTR,A
    231          
    232            /* Setup Sample */
    233            adctemp = ADCCON3;
   \   00004D   E5B6         MOV     A,0xb6
    234            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
    235            adctemp |= channel | resbits | HAL_ADC_REF_VOLT;
    236          
    237            /* writing to this register starts the extra conversion */
    238            ADCCON3 = adctemp;
   \   00004F   EB           MOV     A,R3
   \   000050   49           ORL     A,R1
   \   000051   4480         ORL     A,#0x80
   \   000053   F5B6         MOV     0xb6,A
    239          
    240            /* Wait for the conversion to be done */
    241            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_8:
   \   000055   E5B4         MOV     A,0xb4
   \   000057   A2E7         MOV     C,0xE0 /* A   */.7
   \   000059   50FA         JNC     ??HalAdcRead_8
    242          
    243            /* Disable channel after done conversion */
    244            ADCCFG &= ~adcChannel;
   \   00005B   EC           MOV     A,R4
   \   00005C   F4           CPL     A
   \   00005D   55F2         ANL     A,0xf2
   \   00005F   F5F2         MOV     0xf2,A
    245          
    246            /* Read the result */
    247            reading = (int16) (ADCL);
   \   000061   ABBA         MOV     R3,0xba
   \   000063   8B82         MOV     DPL,R3
   \   000065   8582..       MOV     ?V0 + 0,DPL
    248            reading |= (int16) (ADCH << 8);
   \   000068   E5BB         MOV     A,0xbb
   \   00006A   F8           MOV     R0,A
   \   00006B   E4           CLR     A
   \   00006C   C8           XCH     A,R0
   \   00006D   F5..         MOV     ?V0 + 1,A
    249          
    250            /* Treat small negative as 0 */
    251            if (reading < 0)
   \   00006F   C3           CLR     C
   \   000070   9400         SUBB    A,#0x0
   \   000072   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000074   65D0         XRL     A,PSW
   \   000076   33           RLC     A
   \   000077   5004         JNC     ??HalAdcRead_9
    252              reading = 0;
   \   000079   88..         MOV     ?V0 + 0,R0
   \   00007B   88..         MOV     ?V0 + 1,R0
    253          
    254            switch (resolution)
   \                     ??HalAdcRead_9:
   \   00007D   EA           MOV     A,R2
   \   00007E   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_1`:
   \   000081   01           DB        1
   \   000082   03           DB        3
   \   000083   ....         DW        ??HalAdcRead_10
   \   000085   ....         DW        ??HalAdcRead_11
   \   000087   ....         DW        ??HalAdcRead_12
   \   000089   ....         DW        ??HalAdcRead_13
   \   00008B   ....         DW        ??HalAdcRead_14
    255            {
    256              case HAL_ADC_RESOLUTION_8:
    257                reading >>= 8;
    258                reading &= 0x00FF;
   \                     ??HalAdcRead_11:
   \   00008D   7408         MOV     A,#0x8
   \   00008F   78..         MOV     R0,#?V0 + 0
   \   000091   12....       LCALL   ?SS_SHR
   \   000094   8021         SJMP    ??HalAdcRead_15
    259                break;
    260              case HAL_ADC_RESOLUTION_10:
    261                reading >>= 6;
    262                reading &= 0x03FF;
   \                     ??HalAdcRead_12:
   \   000096   7406         MOV     A,#0x6
   \   000098   78..         MOV     R0,#?V0 + 0
   \   00009A   12....       LCALL   ?SS_SHR
   \   00009D   7403         MOV     A,#0x3
   \   00009F   8014         SJMP    ??HalAdcRead_16
    263                break;
    264              case HAL_ADC_RESOLUTION_12:
    265                reading >>= 4;
    266                reading &= 0x0FFF;
   \                     ??HalAdcRead_13:
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   78..         MOV     R0,#?V0 + 0
   \   0000A5   12....       LCALL   ?SS_SHR
   \   0000A8   740F         MOV     A,#0xf
   \   0000AA   8009         SJMP    ??HalAdcRead_16
    267                break;
    268              case HAL_ADC_RESOLUTION_14:
    269                reading >>=2;    
    270                reading &= 0x3FFF;
   \                     ??HalAdcRead_14:
   \   0000AC   7402         MOV     A,#0x2
   \   0000AE   78..         MOV     R0,#?V0 + 0
   \   0000B0   12....       LCALL   ?SS_SHR
   \   0000B3   743F         MOV     A,#0x3f
   \                     ??HalAdcRead_16:
   \   0000B5   55..         ANL     A,?V0 + 1
   \                     ??HalAdcRead_15:
   \   0000B7   F5..         MOV     ?V0 + 1,A
    271              default:
    272              break;
    273            }
    274          #endif
    275          
    276            return ((uint16)reading);
   \                     ??HalAdcRead_10:
   \   0000B9                REQUIRE ?Subroutine1
   \   0000B9                REQUIRE ADCCON1
   \   0000B9                REQUIRE ADCCON3
   \   0000B9                REQUIRE ADCL
   \   0000B9                REQUIRE ADCH
   \   0000B9                REQUIRE ADCCFG
   \   0000B9                ; // Fall through to label ?Subroutine1
    277          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004   7401         MOV     A,#0x1
   \   000006   12....       LCALL   ?DEALLOC_XSTACK8
   \   000009   7F02         MOV     R7,#0x2
   \   00000B   02....       LJMP    ?BANKED_LEAVE_XDATA
    278          
    279          /**************************************************************************************************
    280           * @fn      HalAdcCheckVdd
    281           *
    282           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    283           *
    284           * @param   limit - limit that needs to be checked with the Vdd
    285           *
    286           * @return  TRUE if Vdd >= limit, FALSE otherwise
    287           *
    288           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    289          bool HalAdcCheckVdd (uint8 limit)
   \                     HalAdcCheckVdd:
    290          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    291            uint16 value;
    292          
    293            /* If rev C or earlier, dont check the voltage */
    294            if (CHVER < REV_D)
   \   000004   90DF60       MOV     DPTR,#-0x20a0
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C3           CLR     C
   \   000009   9403         SUBB    A,#0x3
   \   00000B   5004         JNC     ??HalAdcCheckVdd_0
    295            {
    296              return TRUE;
   \                     ??HalAdcCheckVdd_1:
   \   00000D   7901         MOV     R1,#0x1
   \   00000F   802F         SJMP    ??HalAdcCheckVdd_2
    297            }
    298          
    299            /* Clear ADC interrupt flag */
    300            ADCIF = 0;
   \                     ??HalAdcCheckVdd_0:
   \   000011   C28D         CLR     0x88.5
    301          
    302            /* Setup the new value for conversion */
    303            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_064 | HAL_ADC_CHN_VDD3);
   \   000013   75B60F       MOV     0xb6,#0xf
    304          
    305            /* Wait for the conversion to finish */
    306            while ( !ADCIF );
   \                     ??HalAdcCheckVdd_3:
   \   000016   A28D         MOV     C,0x88.5
   \   000018   50FC         JNC     ??HalAdcCheckVdd_3
    307          
    308            /* Get the result */
    309            value = ADCL;
   \   00001A   AABA         MOV     R2,0xba
    310            value |= ((uint16) ADCH) << 8;
   \   00001C   E5BB         MOV     A,0xbb
   \   00001E   FB           MOV     R3,A
    311          
    312            /* Check the limit and return */
    313            return ( value >= HalAdcVddLimit[limit] );
   \   00001F   E9           MOV     A,R1
   \   000020   C3           CLR     C
   \   000021   33           RLC     A
   \   000022   F8           MOV     R0,A
   \   000023   E4           CLR     A
   \   000024   33           RLC     A
   \   000025   F9           MOV     R1,A
   \   000026   E8           MOV     A,R0
   \   000027   24..         ADD     A,#(HalAdcVddLimit & 0xff)
   \   000029   F582         MOV     DPL,A
   \   00002B   E9           MOV     A,R1
   \   00002C   34..         ADDC    A,#((HalAdcVddLimit >> 8) & 0xff)
   \   00002E   F583         MOV     DPH,A
   \   000030   E4           CLR     A
   \   000031   93           MOVC    A,@A+DPTR
   \   000032   F8           MOV     R0,A
   \   000033   7401         MOV     A,#0x1
   \   000035   93           MOVC    A,@A+DPTR
   \   000036   F9           MOV     R1,A
   \   000037   C3           CLR     C
   \   000038   EA           MOV     A,R2
   \   000039   98           SUBB    A,R0
   \   00003A   EB           MOV     A,R3
   \   00003B   99           SUBB    A,R1
   \   00003C   50CF         JNC     ??HalAdcCheckVdd_1
   \   00003E   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_2:
   \   000040   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000043                REQUIRE _A_TCON
   \   000043                REQUIRE ADCCON3
   \   000043                REQUIRE ADCL
   \   000043                REQUIRE ADCH
    314          }
    315          
    316          /**************************************************************************************************
    317           * @fn      HalAdcCheckVdd
    318           *
    319           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    320           *
    321           * @param   limit - limit that needs to be checked with the Vdd
    322           *
    323           * @return  TRUE if Vdd >= limit, FALSE otherwise
    324           *
    325           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    326          uint16 HalAdcReadVcc ( uint8 resolution)
   \                     HalAdcReadVcc:
    327          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    328            int16  reading = 0;
    329          
    330          #if (HAL_ADC == TRUE)
    331          
    332            uint8   resbits;
    333            uint8   adctemp;
    334            volatile  uint8 tmp;
    335          
    336            /* Convert resolution to decimation rate */
    337            switch (resolution)
   \   00000A   E9           MOV     A,R1
   \   00000B   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcReadVcc>_0`:
   \   00000E   01           DB        1
   \   00000F   02           DB        2
   \   000010   ....         DW        ??HalAdcReadVcc_0
   \   000012   ....         DW        ??HalAdcReadVcc_1
   \   000014   ....         DW        ??HalAdcReadVcc_2
   \   000016   ....         DW        ??HalAdcReadVcc_3
    338            {
    339              case HAL_ADC_RESOLUTION_8:
    340                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcReadVcc_1:
   \   000018   7A00         MOV     R2,#0x0
   \   00001A   800A         SJMP    ??HalAdcReadVcc_4
    341                break;
    342              case HAL_ADC_RESOLUTION_10:
    343                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcReadVcc_2:
   \   00001C   7A10         MOV     R2,#0x10
   \   00001E   8006         SJMP    ??HalAdcReadVcc_4
    344                break;
    345              case HAL_ADC_RESOLUTION_12:
    346                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcReadVcc_3:
   \   000020   7A20         MOV     R2,#0x20
   \   000022   8002         SJMP    ??HalAdcReadVcc_4
    347                break;
    348              case HAL_ADC_RESOLUTION_14:
    349              default:
    350                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcReadVcc_0:
   \   000024   7A30         MOV     R2,#0x30
    351                break;
    352            }
    353          
    354            /* read ADCL,ADCH to clear EOC */
    355            tmp = ADCL;
   \                     ??HalAdcReadVcc_4:
   \   000026   E5BA         MOV     A,0xba
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   F0           MOVX    @DPTR,A
    356            tmp = ADCH;
   \   00002F   E5BB         MOV     A,0xbb
   \   000031   F0           MOVX    @DPTR,A
    357          
    358            /* Setup Sample */
    359            adctemp = ADCCON3;
   \   000032   E5B6         MOV     A,0xb6
    360            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
    361            adctemp |= HAL_ADC_CHN_VDD3 | resbits | HAL_ADC_REF_125V;
    362          
    363            /* writing to this register starts the extra conversion */
    364            ADCCON3 = adctemp;
   \   000034   740F         MOV     A,#0xf
   \   000036   4A           ORL     A,R2
   \   000037   F5B6         MOV     0xb6,A
    365          
    366            /* Wait for the conversion to be done */
    367            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcReadVcc_5:
   \   000039   E5B4         MOV     A,0xb4
   \   00003B   A2E7         MOV     C,0xE0 /* A   */.7
   \   00003D   50FA         JNC     ??HalAdcReadVcc_5
    368          
    369            ///* Read the result */
    370            reading = (int16) (ADCL);
   \   00003F   AABA         MOV     R2,0xba
   \   000041   8A82         MOV     DPL,R2
   \   000043   8582..       MOV     ?V0 + 0,DPL
    371            reading |= (int16) (ADCH << 8);
   \   000046   E5BB         MOV     A,0xbb
   \   000048   FA           MOV     R2,A
   \   000049   E4           CLR     A
   \   00004A   CA           XCH     A,R2
   \   00004B   F5..         MOV     ?V0 + 1,A
    372           
    373            //dong
    374            //reading = ADCL;
    375            //reading |=(ADCH<<8);
    376            
    377            /* Treat small negative as 0 */
    378            if (reading < 0)
   \   00004D   C3           CLR     C
   \   00004E   9400         SUBB    A,#0x0
   \   000050   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000052   65D0         XRL     A,PSW
   \   000054   33           RLC     A
   \   000055   5004         JNC     ??HalAdcReadVcc_6
    379              reading = 0;
   \   000057   8A..         MOV     ?V0 + 0,R2
   \   000059   8A..         MOV     ?V0 + 1,R2
    380          
    381            switch (resolution)
   \                     ??HalAdcReadVcc_6:
   \   00005B   E9           MOV     A,R1
   \   00005C   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcReadVcc>_1`:
   \   00005F   01           DB        1
   \   000060   03           DB        3
   \   000061   ....         DW        ??HalAdcReadVcc_7
   \   000063   ....         DW        ??HalAdcReadVcc_8
   \   000065   ....         DW        ??HalAdcReadVcc_9
   \   000067   ....         DW        ??HalAdcReadVcc_10
   \   000069   ....         DW        ??HalAdcReadVcc_11
    382            {
    383              case HAL_ADC_RESOLUTION_8:
    384                reading >>= 8;
    385                reading &= 0x00FF;
   \                     ??HalAdcReadVcc_8:
   \   00006B   7408         MOV     A,#0x8
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?SS_SHR
   \   000072   8021         SJMP    ??HalAdcReadVcc_12
    386                break;
    387              case HAL_ADC_RESOLUTION_10:
    388                reading >>= 6;
    389                reading &= 0x03FF;
   \                     ??HalAdcReadVcc_9:
   \   000074   7406         MOV     A,#0x6
   \   000076   78..         MOV     R0,#?V0 + 0
   \   000078   12....       LCALL   ?SS_SHR
   \   00007B   7403         MOV     A,#0x3
   \   00007D   8014         SJMP    ??HalAdcReadVcc_13
    390                break;
    391              case HAL_ADC_RESOLUTION_12:
    392                reading >>= 4;
    393                reading &= 0x0FFF;
   \                     ??HalAdcReadVcc_10:
   \   00007F   7404         MOV     A,#0x4
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   12....       LCALL   ?SS_SHR
   \   000086   740F         MOV     A,#0xf
   \   000088   8009         SJMP    ??HalAdcReadVcc_13
    394                break;
    395              case HAL_ADC_RESOLUTION_14:
    396                //dong
    397                reading >>=2;
    398                reading &= 0x3FFF;
   \                     ??HalAdcReadVcc_11:
   \   00008A   7402         MOV     A,#0x2
   \   00008C   78..         MOV     R0,#?V0 + 0
   \   00008E   12....       LCALL   ?SS_SHR
   \   000091   743F         MOV     A,#0x3f
   \                     ??HalAdcReadVcc_13:
   \   000093   55..         ANL     A,?V0 + 1
   \                     ??HalAdcReadVcc_12:
   \   000095   F5..         MOV     ?V0 + 1,A
    399              default:
    400              break;
    401            }
    402          #endif
    403          
    404            return ((uint16)reading);
   \                     ??HalAdcReadVcc_7:
   \   000097   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   00009A                REQUIRE ADCCON1
   \   00009A                REQUIRE ADCCON3
   \   00009A                REQUIRE ADCL
   \   00009A                REQUIRE ADCH
    405          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcReadVcc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcReadVcc
    406          /**************************************************************************************************
    407          **************************************************************************************************/
    408          
    409          
    410          
    411          

   Maximum stack usage in bytes:

     Function       ISTACK PSTACK XSTACK
     --------       ------ ------ ------
     HalAdcCheckVdd     2      0      0
     HalAdcInit         3      0      1
     HalAdcRead         1      0     11
     HalAdcReadVcc      1      0     11


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_TCON                   1
     ADCCON1                   1
     ADCCON2                   1
     ADCCON3                   1
     ADCL                      1
     ADCH                      1
     ADCCFG                    1
     HalAdcVddLimit           18
     HalAdcInit               62
     ?Subroutine0              7
     HalAdcRead              185
     ?Subroutine1             14
     HalAdcCheckVdd           67
     HalAdcReadVcc           154
     ??HalAdcInit?relay        6
     ??HalAdcRead?relay        6
     ??HalAdcCheckVdd?relay    6
     ??HalAdcReadVcc?relay     6

 
 489 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
  18 bytes in segment CODE_C
   7 bytes in segment SFR_AN
 
 531 bytes of CODE memory
   0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
